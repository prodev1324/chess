/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _rsgChess = __webpack_require__(1);

self.addEventListener('message', function (e) {
  if (e.data && e.data.game) {
    var bestMove = (0, _rsgChess.AI)(4, e.data.game, true);
    console.log(e.data.game.board[7][6], bestMove);
    self.postMessage(bestMove);
  }
}); // self.importScripts("game.js");

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("rsg-chess", [], factory);
	else if(typeof exports === 'object')
		exports["rsg-chess"] = factory();
	else
		root["rsg-chess"] = factory();
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 3);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _pieces = __webpack_require__(1);

var _AI = __webpack_require__(2);

var _AI2 = _interopRequireDefault(_AI);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function Game(promoCallback) {
  // the game board
  this.board = [];
  // fill the board
  for (var i = 0; i < 8; i++) {
    var arrayIn = [];
    for (var j = 0; j < 8; j++) {
      arrayIn.push(null);
    }
    this.board.push(arrayIn);
  }

  // the history of all turns
  this.turn = [];
  // the current FEN status
  this.FEN = [];
  // the current game configuration as FEN
  this.FENboard = [];
  // the history of all game configurations displayed using FEN
  this.threefold = [];
}

Game.prototype.piece = function (type, x, y, color) {
  var piece = _pieces.Piece[type](x, y, color, this);
  this.board[y][x] = piece;

  this.FEN = this.gameToFEN();
  this.FENboard = this.boardToFEN();
};

Game.prototype.moveSelected = function (selected, to, promotionCallback, checkmateCallback, playAgainstAI, comingAI, simulate) {
  var x = to.x;
  var y = to.y;

  if (selected) {
    var from = { x: selected.x, y: selected.y };

    if (this.board[y][x] !== selected) {
      var validMoves = selected.getValidMoves(!simulate);
      var validMove = null;

      for (var i = 0; i < validMoves.length; i++) {
        var vm = validMoves[i];
        if (vm.x === x && vm.y === y) {
          validMove = vm;
          break;
        }
      }

      if (!validMove) return false;
      var movePiece = validMove.movePiece;
      var take, paste, rook;
      if (movePiece) {
        take = movePiece.from;
        paste = movePiece.to;
        if (paste === null) {
          this.board[take.y][take.x] = null;
        } else {
          rook = this.board[take.y][take.x];
          this.board[paste.y][paste.x] = rook;
          rook.x = paste.x;
          rook.y = paste.y;
          this.board[take.y][take.x] = null;
        }
      }

      var piece = this.board[y][x] ? this.board[y][x] : null;
      movePiece = movePiece ? validMove.movePiece : null;
      this.turn.push({
        from: from,
        to: to,
        color: selected.color,
        type: selected.type,
        piece: piece,
        movePiece: movePiece
      });

      this.board[y][x] = selected;
      this.board[selected.y][selected.x] = null;
      this.board[y][x].x = x;
      this.board[y][x].y = y;

      this.FEN = this.gameToFEN();
      this.FENboard = this.boardToFEN();
      // check for threefold repetition

      this.threefold.push(this.FENboard);
      if (selected.type === 'pawn' || piece) this.threefold = [];
      if (this.threefoldCheck()) checkmateCallback('D');

      // check for the fifty-move rule
      if (this.halfmoveClock() >= 50) checkmateCallback('D');

      // check for pawn promotion
      if (selected.type === 'pawn') {
        if (selected.color === 'W' && y === 0 || selected.color === 'B' && y === 7) {
          if (promotionCallback) {
            !playAgainstAI && comingAI && selected.color === 'B' ? this.promotePawn(selected, x, y, selected.color, 'queen') : promotionCallback(selected, x, y, selected.color);
          }
        }
      };

      var checkmateColor = selected.color === 'W' ? 'B' : 'W';
      var checkmateValue = this.checkmate(checkmateColor);
      if (checkmateValue) checkmateCallback(checkmateValue);

      // Play AI
      if (playAgainstAI) {
        var bestMove = (0, _AI2.default)(playAgainstAI.depth, this, false);
        this.moveSelected(this.board[bestMove.from.y][bestMove.from.x], bestMove.to, promotionCallback, checkmateCallback, false, true, simulate);
      }
      // end
    }
    selected = null;
    return true;
  }
};

Game.prototype.promotePawn = function (pawn, x, y, color, type) {
  this.piece(type, x, y, color);
};

Game.prototype.simulateAndFilter = function (moves, piece) {
  var validMoves = [];
  var self = this;
  var board = this.board;

  moves.forEach(function (move, i) {
    var y = move.y;
    var x = move.x;
    var from = { x: piece.x, y: piece.y };
    var movePiece = board[y][x] ? {
      piece: board[y][x],
      from: { x: x, y: y },
      to: null
    } : null;

    if (move.movePiece) movePiece = move.movePiece;
    if (movePiece) self.simpleMovePiece(movePiece.piece, movePiece.from, movePiece.to);

    self.simpleMovePiece(piece, from, { x: x, y: y });
    var warning = self.warning(piece.color);

    // Return king
    self.simpleMovePiece(piece, { x: x, y: y }, from);

    // return the movePiece with simpleMovePiece() method
    if (movePiece) self.simpleMovePiece(movePiece.piece, movePiece.to, movePiece.from);

    if (!warning) validMoves.push(move);
  });
  return validMoves;
};

Game.prototype.checkmate = function (color) {
  // using let will allow us to make the code a bit simpler
  for (var i = 0; i < 8; i++) {
    for (var j = 0; j < 8; j++) {
      if (this.board[i][j] && this.board[i][j].color === color && this.board[i][j].getValidMoves(true).length) return false;
    }
  }
  if (this.warning(color)) return color;
  return 'D';
};

Game.prototype.simpleMovePiece = function (piece, from, to) {
  var board = this.board;
  if (to) {
    board[to.y][to.x] = piece;
    piece.x = to.x;
    piece.y = to.y;
  }
  if (from) board[from.y][from.x] = null;
};

Game.prototype.simpleMove = function (move) {
  var self = this;
  var board = self.board;
  var from = move.from;
  var to = move.to;
  var piece = board[from.y][from.x];
  var capturedPiece = this.board[to.y][to.x] ? this.board[to.y][to.x] : null;
  var movePiece = board[to.y][to.x] ? {
    piece: board[to.y][to.x],
    from: { x: to.x, y: to.y },
    to: null
  } : null;

  this.turn.push({
    from: from,
    to: { x: to.x, y: to.y },
    color: move.color,
    type: piece.type,
    piece: capturedPiece,
    movePiece: movePiece
  });

  if (to.movePiece) movePiece = to.movePiece;
  if (movePiece) self.simpleMovePiece(movePiece.piece, movePiece.from, movePiece.to);
  self.simpleMovePiece(piece, from, { x: to.x, y: to.y });

  return function () {
    // return the current move /ev/
    if (movePiece) self.simpleMovePiece(movePiece.piece, movePiece.to, movePiece.from);
    self.simpleMovePiece(piece, { x: to.x, y: to.y }, from);
    if (capturedPiece) board[to.y][to.x] = capturedPiece;
    self.turn.pop();
  };
};

Game.prototype.warning = function (color) {
  var result = false;
  var king;

  this.board.forEach(function (yyy) {
    yyy.forEach(function (xxx) {
      if (xxx && xxx.color === color && xxx.type === 'king') {
        king = xxx;
      }
    });
  });

  this.board.forEach(function (yyy) {
    yyy.forEach(function (xxx) {
      if (xxx && xxx.color !== color) {
        xxx.getValidMoves().forEach(function (mmm) {
          if (mmm.x === king.x && mmm.y === king.y) result = true;
        });
      }
    });
  });
  return result;
};

Game.prototype.threefoldCheck = function () {
  var threefold = this.threefold;
  var length = threefold.length;

  for (var i = 0; i < length; i++) {
    // using let will allow us to make the code simpler
    var count = 0;
    for (var j = i + 1; j < length; j++) {
      if (threefold[i] === threefold[j]) count += 1;
    }
    if (count >= 2) return true;
  }

  return false;
};

Game.prototype.pieceToAN = function (x, y) {
  var xChars = 'abcdefgh';
  return xChars.charAt(x) + (8 - y);
};

// Support FEN functions in the API
Game.prototype.boardToFEN = function () {
  var board = this.board;

  // Convert the board configuration into FEN
  var FENboard = '';
  var missingPieces = 0;
  for (var i = 0; i < 8; i++) {
    for (var j = 0; j < 8; j++) {
      if (board[i][j]) {
        if (missingPieces) FENboard += missingPieces;
        missingPieces = 0;
        FENboard += board[i][j].FENname;
      } else {
        missingPieces++;
      }
    }
    if (missingPieces) FENboard += missingPieces;
    missingPieces = 0;
    FENboard += i < 7 ? '/' : '';
  }

  return FENboard;
};

Game.prototype.halfmoveClock = function () {
  var turn = this.turn;
  var length = turn.length;
  var count = 0;
  if (turn.length === 0) return count;

  var ev = turn[length - 1 - count];
  while (count <= length - 1 && ev.type !== 'pawn' && !ev.piece) {
    count++;
    ev = turn[length - 1 - count];
  }

  return count;
};

Game.prototype.activeColour = function () {
  var turn = this.turn;
  var activeColor = turn.length && turn[turn.length - 1].color === 'W' ? 'b' : 'w';

  return activeColor;
};

Game.prototype.castlingTarget = function () {
  var board = this.board;
  var turn = this.turn;
  var possibleCastling = '';

  var whiteKingMoved;
  var blackKingMoved;
  turn.forEach(function (turn) {
    whiteKingMoved = turn.type === 'king' && turn.color === 'W';
    blackKingMoved = turn.type === 'king' && turn.color === 'B';
  });

  [[7, 0], [0, 0], [7, 7], [0, 7]].forEach(function (props) {
    var rookX = props[0];
    var rookY = props[1];
    var rook = board[rookY][rookX];

    if (rookY === 7 && whiteKingMoved) return;
    if (rookY === 0 && blackKingMoved) return;

    // Check rook on position
    if (!rook || !rook.type === 'rook') return;

    // Check rook hasn't moved
    if (turn.some(function (ev) {
      if (ev.type !== 'rook') return false;
      return ev.from.x === rookX && ev.from.y === rookY;
    })) return;

    var castlingSide = rookX === 0 ? 'q' : 'k';
    possibleCastling += rookY === 0 ? castlingSide.toUpperCase() : castlingSide;
  });

  if (!possibleCastling) possibleCastling = '-';
  return possibleCastling;
};

Game.prototype.enPassantTarget = function () {
  var turn = this.turn;
  var enPassantTarget = '';

  if (turn.length) {
    var ev = turn[turn.length - 1];
    if (ev.color === 'W' && ev.to.y === 4) {
      enPassantTarget = this.pieceToAN(ev.to.x, ev.to.y + 1);
    }

    if (ev.color === 'B' && ev.to.y === 3) {
      enPassantTarget = this.pieceToAN(ev.to.x, ev.to.y - 1);
    }
  }

  if (!enPassantTarget) enPassantTarget = '-';
  return enPassantTarget;
};

Game.prototype.fullmoveCount = function () {
  var count = 1;
  this.turn.forEach(function (ev) {
    if (ev.color === 'B') count += 1;
  });

  return count;
};

Game.prototype.gameToFEN = function () {
  var FEN = '';

  // Check the board configuration
  FEN += this.boardToFEN();

  // Find the active colour
  FEN += ' ' + this.activeColour();

  // Check castling availability
  FEN += ' ' + this.castlingTarget();

  // Check the En-passant target
  FEN += ' ' + this.enPassantTarget();

  // Add the halfmove clock
  FEN += ' ' + this.halfmoveClock();

  // Add the fullmove number
  FEN += ' ' + this.fullmoveCount();

  /*
    More information about the FEN notation:
    https://en.wikipedia.org/wiki/Forsyth%E2%80%93Edwards_Notation
    https://chessprogramming.wikispaces.com/Forsyth-Edwards+Notation
  */

  return FEN;
};

// Set up default game configuration
Game.prototype.initializeGame = function () {
  var defaultGame = new Game();

  // Pawns:
  for (var i = 0; i < 8; i++) {
    defaultGame.piece('pawn', i, 6, 'W');
    defaultGame.piece('pawn', i, 1, 'B');
  }

  // Black figs:
  defaultGame.piece('rook', 0, 0, 'B');
  defaultGame.piece('knight', 1, 0, 'B');
  defaultGame.piece('bishop', 2, 0, 'B');
  defaultGame.piece('queen', 3, 0, 'B');
  defaultGame.piece('king', 4, 0, 'B');
  defaultGame.piece('bishop', 5, 0, 'B');
  defaultGame.piece('knight', 6, 0, 'B');
  defaultGame.piece('rook', 7, 0, 'B');

  // White figs:
  defaultGame.piece('rook', 0, 7, 'W');
  defaultGame.piece('knight', 1, 7, 'W');
  defaultGame.piece('bishop', 2, 7, 'W');
  defaultGame.piece('queen', 3, 7, 'W');
  defaultGame.piece('king', 4, 7, 'W');
  defaultGame.piece('bishop', 5, 7, 'W');
  defaultGame.piece('knight', 6, 7, 'W');
  defaultGame.piece('rook', 7, 7, 'W');

  return defaultGame;
};

Game.prototype.allMoves = function () {
  var board = this.board;
  var allMoves = [];
  var activeColour = this.activeColour().toUpperCase();

  for (var i = 0; i < 8; i++) {
    for (var j = 0; j < 8; j++) {
      if (board[i][j] && board[i][j].color === activeColour) {
        var validMoves = board[i][j].getValidMoves(true);
        validMoves.forEach(function (ev) {
          allMoves.push({
            color: board[i][j].color,
            from: { x: j, y: i },
            to: ev,
            FENname: board[i][j].FENname
          });
        });
      }
    }
  }

  return allMoves;
};

exports.default = Game;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
//
// RSG Chess
// Licensed under Apache 2.0 LICENSE

var PIECE_CHARS = exports.PIECE_CHARS = {
  pawn: { W: '♙', B: '♟' },
  rook: { W: '♖', B: '♜' },
  knight: { W: '♘', B: '♞' },
  bishop: { W: '♗', B: '♝' },
  queen: { W: '♕', B: '♛' },
  king: { W: '♔', B: '♚' }
};

function Piece(x, y, charBase, color, game, type) {
  if (charBase) this.char = charBase[color];
  this.color = color;
  this.x = x;
  this.y = y;
  this.game = game;
  this.type = type;
  if (type) {
    var FENname = type === 'knight' ? 'n' : type.charAt(0);
    if (this.color === 'W') FENname = FENname.toUpperCase();
    this.FENname = FENname;
  }
}

Piece.empty = function () {
  return new Piece();
};

Piece.prototype.getValidMoves = function () {
  return [{ x: 0, y: 0 }, { x: 7, y: 7 }];
};

function Pawn(x, y, color, game) {
  Piece.call(this, x, y, PIECE_CHARS.pawn, color, game, 'pawn');
}

Pawn.prototype = Piece.empty();
Pawn.prototype.getValidMoves = function (simulate) {
  var game = this.game;
  var moves = [];
  /* eslint-disable */
  var y = this.y,
      x = this.x;
  var board = game.board,
      turn = game.turn,
      length = turn.length;
  var last, turnTo, turnFrom, figX, passantLast, passantFig;
  var colorY = this.color === 'W' ? y - 1 : y + 1;
  var colorY2 = this.color === 'W' ? y - 2 : y + 2;
  var passantY2 = this.color === 'W' ? 3 : 4;
  var figXArray = [x - 1, x + 1];
  /* eslint-enable */

  if (colorY < 8 && colorY >= 0 && !board[colorY][x]) {
    moves.push({ x: x, y: colorY });
    if ((y === 1 || y === 6) && colorY2 < 8 && colorY2 >= 0 && !game.board[colorY2][x]) {
      moves.push({ x: x, y: colorY2 });
    }
  }

  for (var i = 0; i < 2; i++) {
    figX = figXArray[i];
    if (colorY < 8 && colorY >= 0 && board[colorY][figX] && board[colorY][figX].color !== this.color) moves.push({ x: figX, y: colorY });
  }

  // Check for en-passant
  for (var _i = 0; _i < 2; _i++) {
    figX = figXArray[_i];
    last = turn[length - 1];

    if (last && last.type === 'pawn' && last.to.x === figX && last.to.y === y && last.color !== this.color && (last.from.y === 1 || last.from.y === 6) && (y === 3 || y === 4)) {
      moves.push({
        x: figX,
        y: colorY,
        movePiece: {
          piece: game.board[y][figX],
          from: {
            x: figX,
            y: y
          },
          to: null
        }
      });
    }
  }

  var validMoves = [];
  if (simulate) {
    validMoves = game.simulateAndFilter(moves, this);
  } else {
    validMoves = moves;
  }

  return validMoves;
};

Piece.pawn = function (x, y, color, game) {
  return new Pawn(x, y, color, game);
};

// //

function Rook(x, y, color, game) {
  Piece.call(this, x, y, PIECE_CHARS.rook, color, game, 'rook');
}

Rook.prototype = Piece.empty();
Rook.prototype.getValidMoves = function (simulate) {
  var game = this.game;
  var moves = [];

  [[-1, 0], [1, 0], [0, 1], [0, -1]].forEach(function (coef) {
    var index, x, y, piece;
    for (index = 1;; index++) {
      x = this.x + coef[0] * index;
      y = this.y + coef[1] * index;
      if (y < 0 || y > 7 || x < 0 || x > 7) break;

      piece = game.board[y][x];
      if (piece && piece.color === this.color) break;

      moves.push({ x: x, y: y });
      if (piece) break;
    }
  }, this);

  var validMoves = [];
  if (simulate) {
    validMoves = game.simulateAndFilter(moves, this);
  } else {
    validMoves = moves;
  }

  return validMoves;
};

Piece.rook = function (x, y, color, game) {
  return new Rook(x, y, color, game);
};

// //

function Knight(x, y, color, game) {
  Piece.call(this, x, y, PIECE_CHARS.knight, color, game, 'knight');
}

Knight.prototype = Piece.empty();
Knight.prototype.getValidMoves = function (simulate) {
  var game = this.game;
  var moves = [];

  var coordinates = [[2, 1], [-2, 1], [1, 2], [-1, 2], [2, -1], [-2, -1], [1, -2], [-1, -2]];

  var one, two;
  for (var i = 0; i < coordinates.length; i++) {
    var help = false;
    var boardPiece;
    one = coordinates[i][0];
    two = coordinates[i][1];

    if (this.x + one < 8 && this.x + one >= 0 && this.y + two < 8 && this.y + two >= 0) {
      boardPiece = game.board[this.y + two][this.x + one];
      help = boardPiece ? boardPiece.color !== this.color : true;
    }

    if (help) {
      moves.push({ x: this.x + one, y: this.y + two });
    }
  }

  var validMoves = [];
  if (simulate) {
    validMoves = game.simulateAndFilter(moves, this);
  } else {
    validMoves = moves;
  }

  return validMoves;
};

Piece.knight = function (x, y, color, game) {
  return new Knight(x, y, color, game);
};

// //

function Bishop(x, y, color, game) {
  Piece.call(this, x, y, PIECE_CHARS.bishop, color, game, 'bishop');
}

Bishop.prototype = Piece.empty();
Bishop.prototype.getValidMoves = function (simulate) {
  var game = this.game;
  var moves = [];

  [[-1, -1], [1, 1], [-1, 1], [1, -1]].forEach(function (coef) {
    var index, x, y, piece;
    for (index = 1;; index++) {
      x = this.x + coef[0] * index;
      y = this.y + coef[1] * index;
      if (y < 0 || y > 7 || x < 0 || x > 7) break;

      piece = game.board[y][x];
      if (piece && piece.color === this.color) break;

      moves.push({ x: x, y: y });
      if (piece) break;
    }
  }, this);

  var validMoves = [];
  if (simulate) {
    validMoves = game.simulateAndFilter(moves, this);
  } else {
    validMoves = moves;
  }

  return validMoves;
};

Piece.bishop = function (x, y, color, game) {
  return new Bishop(x, y, color, game);
};

// //

function Queen(x, y, color, game) {
  Piece.call(this, x, y, PIECE_CHARS.queen, color, game, 'queen');
}

Queen.prototype = Piece.empty();
Queen.prototype.getValidMoves = function (simulate) {
  var game = this.game;
  var rookMoves = Rook.prototype.getValidMoves.call(this);
  var bishopMoves = Bishop.prototype.getValidMoves.call(this);
  var moves = rookMoves.concat(bishopMoves);

  var validMoves = [];
  if (simulate) {
    validMoves = game.simulateAndFilter(moves, this);
  } else {
    validMoves = moves;
  }

  return validMoves;
};

Piece.queen = function (x, y, color, game) {
  return new Queen(x, y, color, game);
};

// //

function King(x, y, color, game) {
  Piece.call(this, x, y, PIECE_CHARS.king, color, game, 'king');
}

King.prototype = Piece.empty();
King.prototype.getValidMoves = function (simulate) {
  var moves = [];
  var coordinates = [[0, 1], [0, -1], [1, 1], [-1, -1], [1, -1], [-1, 1], [-1, 0], [1, 0]];
  var x = this.x;
  var y = this.y;
  var game = this.game;
  var turn = game.turn;
  var self = this;

  coordinates.forEach(function (coord) {
    var piece;
    var xx = x + coord[0];
    var yy = y + coord[1];

    if (xx < 8 && xx >= 0 && yy < 8 && yy >= 0) {
      piece = game.board[yy][xx];
      if (!piece || piece.color !== self.color) {
        moves.push({ x: xx, y: yy });
      }
    }
  });

  // Check king hasn't moved
  var kingMoved = turn.some(function (turn) {
    return turn.type === 'king' && turn.color === self.color;
  });

  if (!kingMoved) {
    [[0, 2, -1], [7, 6, +1]].forEach(function (props) {
      var rookX = props[0];
      var newKingX = props[1];
      var dir = props[2];
      var rook = game.board[y][rookX];

      // Check rook on position
      if (!rook || !rook.type === 'rook') return;

      // Check rook hasn't moved
      if (turn.some(function (ev) {
        return ev.from.x === rookX && ev.from.y === y;
      })) return;

      // Check squares empty and safe
      for (var xx = x + dir; xx !== rookX; xx += dir) {
        if (game.board[y][xx]) return;
        var safe = true;
        game.board.forEach(function (ev) {
          ev.forEach(function (evv) {
            if (evv && evv.type !== 'king' && evv.color !== self.color) {
              evv.getValidMoves().forEach(function (evMove) {
                if (evMove && evMove.y === y && evMove.x === xx) safe = false;
              });
            }
          });
        });
        if (!safe) return;
      }

      var rochade = {
        x: newKingX,
        y: y,
        movePiece: {
          piece: self.game.board[y][rookX],
          from: {
            x: rookX, y: y
          },
          to: {
            y: y, x: x + dir
          }
        }
      };

      moves.push(rochade);
    });
  }

  var validMoves = [];
  if (simulate) {
    validMoves = game.simulateAndFilter(moves, self);
  } else {
    validMoves = moves;
  }

  return validMoves;
};

Piece.king = function (x, y, color, game) {
  return new King(x, y, color, game);
};

exports.Piece = Piece;
exports.Pawn = Pawn;
exports.Rook = Rook;
exports.Knight = Knight;
exports.Bishop = Bishop;
exports.Queen = Queen;
exports.King = King;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _game = __webpack_require__(0);

var _game2 = _interopRequireDefault(_game);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ChessAI = function ChessAI(depth, gameState, isMaximisingPlayer) {
  // Clone the gameState to access all game associated methods.
  // This usually doesn't make sense, but sometimes you cannot post functions to a backend or a web-worker
  // and that's why we're touching the game methods from new game configuration intead from the passed argument.
  // So if you pass {board: [myBoard], turn:[myTurn],...} for the game argument it will actually work!
  // Already described here: https://github.com/RSG-Group/Chess/issues/8#issuecomment-381245794
  var game = _game2.default.prototype.initializeGame();

  for (var i = 0; i < 8; i++) {
    for (var j = 0; j < 8; j++) {
      if (gameState.board[i][j]) {
        var currentCell = gameState.board[i][j];
        game.piece(currentCell.type, j, i, currentCell.color);
      } else {
        game.board[i][j] = null;
      }
    }
  }

  game.turn = gameState.turn;
  game.threefold = gameState.threefold;
  game.FEN = gameState.FEN;
  game.FENboard = gameState.FENboard;

  // Start looping and simulating all valid moves
  var allMoves = game.allMoves();
  var bestValue = -9999;
  var bestMove;

  for (var i = 0; i < allMoves.length; i++) {
    var newGameMove = allMoves[i];
    var undo = game.simpleMove(newGameMove);
    var boradValue = minimax(depth - 1, game, -10000, 10000, !isMaximisingPlayer);
    undo();
    if (boradValue >= bestValue) {
      bestValue = boradValue;
      bestMove = newGameMove;
    }
  }
  return bestMove;
}; //
// RSG Chess
// Licensed under Apache 2.0 LICENSE

var minimax = function minimax(depth, game, alpha, beta, isMaximisingPlayer) {
  if (depth === 0) {
    return -evaluateBoard(game.board);
  }

  var allMoves = game.allMoves();
  if (isMaximisingPlayer) {
    var bestValue = -9999;
    for (var i = 0; i < allMoves.length; i++) {
      var undo = game.simpleMove(allMoves[i]);
      bestValue = Math.max(bestValue, minimax(depth - 1, game, alpha, beta, !isMaximisingPlayer));
      undo();
      alpha = Math.max(alpha, bestValue);
      if (beta <= alpha) {
        return bestValue;
      }
    }
    return bestValue;
  } else {
    var _bestValue = 9999;
    for (var _i = 0; _i < allMoves.length; _i++) {
      var _undo = game.simpleMove(allMoves[_i]);
      _bestValue = Math.min(_bestValue, minimax(depth - 1, game, alpha, beta, !isMaximisingPlayer));
      _undo();
      beta = Math.min(beta, _bestValue);
      if (beta <= alpha) {
        return _bestValue;
      }
    }
    return _bestValue;
  }
};

var evaluateBoard = function evaluateBoard(board) {
  var totalEvaluation = 0;
  for (var i = 0; i < 8; i++) {
    for (var j = 0; j < 8; j++) {
      // calculate the current evaluation
      totalEvaluation = totalEvaluation + getPieceValue(board[i][j]);
    }
  }
  // return the total evaluation
  return totalEvaluation;
};

var getPieceValue = function getPieceValue(piece) {
  if (piece === null) {
    return 0;
  }

  // get value for every piece on the board
  var getAbsoluteValue = function getAbsoluteValue(piece) {
    if (piece.type === 'pawn') {
      return 10;
    } else if (piece.type === 'rook') {
      return 50;
    } else if (piece.type === 'knight') {
      return 30;
    } else if (piece.type === 'bishop') {
      return 30;
    } else if (piece.type === 'queen') {
      return 90;
    } else if (piece.type === 'king') {
      return 900;
    }
  };

  // calculate the absolute value and return it
  var absoluteValue = getAbsoluteValue(piece, piece.color === 'W');
  return piece.color === 'W' ? absoluteValue : -absoluteValue;
};

// export the algorithm
exports.default = ChessAI;

// Written by Radi Cho
// RSG Chess - by RSG Group

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AI = exports.Pieces = exports.Game = undefined;

var _game = __webpack_require__(0);

var _game2 = _interopRequireDefault(_game);

var _pieces = __webpack_require__(1);

var Pieces = _interopRequireWildcard(_pieces);

var _AI = __webpack_require__(2);

var _AI2 = _interopRequireDefault(_AI);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// And export...
exports.Game = _game2.default;
exports.Pieces = Pieces;
exports.AI = _AI2.default; // Let's import...

/***/ })
/******/ ]);
});
//# sourceMappingURL=index.js.map

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgMWMzNTBiZDJiM2Q3ZDI5NWY3NTYiLCJ3ZWJwYWNrOi8vLy4vanMvd29ya2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yc2ctY2hlc3MvbGliL2luZGV4LmpzIl0sIm5hbWVzIjpbInNlbGYiLCJhZGRFdmVudExpc3RlbmVyIiwiZSIsImRhdGEiLCJnYW1lIiwiYmVzdE1vdmUiLCJjb25zb2xlIiwibG9nIiwiYm9hcmQiLCJwb3N0TWVzc2FnZSJdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7O0FDNURBOztBQUVBQSxLQUFLQyxnQkFBTCxDQUFzQixTQUF0QixFQUFpQyxVQUFVQyxDQUFWLEVBQWE7QUFDNUMsTUFBSUEsRUFBRUMsSUFBRixJQUFVRCxFQUFFQyxJQUFGLENBQU9DLElBQXJCLEVBQTJCO0FBQ3pCLFFBQUlDLFdBQVcsa0JBQUcsQ0FBSCxFQUFNSCxFQUFFQyxJQUFGLENBQU9DLElBQWIsRUFBbUIsSUFBbkIsQ0FBZjtBQUNBRSxZQUFRQyxHQUFSLENBQVlMLEVBQUVDLElBQUYsQ0FBT0MsSUFBUCxDQUFZSSxLQUFaLENBQWtCLENBQWxCLEVBQXFCLENBQXJCLENBQVosRUFBcUNILFFBQXJDO0FBQ0FMLFNBQUtTLFdBQUwsQ0FB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RUE7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLDZCQUE2QixZQUFZLEVBQUUsT0FBTyxpQkFBaUIsbUJBQW1CLHVCQUF1Qiw0RUFBNEUsRUFBRSxFQUFFLHNCQUFzQixlQUFlLEVBQUU7O0FBRTNRLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7O0FBRTFCLE9BQU87QUFDUDtBQUNBLENBQUM7QUFDRCxpQyIsImZpbGUiOiJ3b3JrZXIubWluLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgMWMzNTBiZDJiM2Q3ZDI5NWY3NTYiLCIvLyBzZWxmLmltcG9ydFNjcmlwdHMoXCJnYW1lLmpzXCIpO1xyXG5pbXBvcnQgeyBHYW1lLCBBSSB9IGZyb20gJ3JzZy1jaGVzcydcclxuXHJcbnNlbGYuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uIChlKSB7XHJcbiAgaWYgKGUuZGF0YSAmJiBlLmRhdGEuZ2FtZSkge1xyXG4gICAgdmFyIGJlc3RNb3ZlID0gQUkoNCwgZS5kYXRhLmdhbWUsIHRydWUpXHJcbiAgICBjb25zb2xlLmxvZyhlLmRhdGEuZ2FtZS5ib2FyZFs3XVs2XSwgYmVzdE1vdmUpXHJcbiAgICBzZWxmLnBvc3RNZXNzYWdlKGJlc3RNb3ZlKVxyXG4gIH1cclxufSlcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vanMvd29ya2VyLmpzIiwiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoXCJyc2ctY2hlc3NcIiwgW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wicnNnLWNoZXNzXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcInJzZy1jaGVzc1wiXSA9IGZhY3RvcnkoKTtcbn0pKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4vKioqKioqLyBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4vKioqKioqLyBcdFx0XHRcdGdldDogZ2V0dGVyXG4vKioqKioqLyBcdFx0XHR9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMyk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfcGllY2VzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIF9BSSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBfQUkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQUkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBHYW1lKHByb21vQ2FsbGJhY2spIHtcbiAgLy8gdGhlIGdhbWUgYm9hcmRcbiAgdGhpcy5ib2FyZCA9IFtdO1xuICAvLyBmaWxsIHRoZSBib2FyZFxuICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykge1xuICAgIHZhciBhcnJheUluID0gW107XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCA4OyBqKyspIHtcbiAgICAgIGFycmF5SW4ucHVzaChudWxsKTtcbiAgICB9XG4gICAgdGhpcy5ib2FyZC5wdXNoKGFycmF5SW4pO1xuICB9XG5cbiAgLy8gdGhlIGhpc3Rvcnkgb2YgYWxsIHR1cm5zXG4gIHRoaXMudHVybiA9IFtdO1xuICAvLyB0aGUgY3VycmVudCBGRU4gc3RhdHVzXG4gIHRoaXMuRkVOID0gW107XG4gIC8vIHRoZSBjdXJyZW50IGdhbWUgY29uZmlndXJhdGlvbiBhcyBGRU5cbiAgdGhpcy5GRU5ib2FyZCA9IFtdO1xuICAvLyB0aGUgaGlzdG9yeSBvZiBhbGwgZ2FtZSBjb25maWd1cmF0aW9ucyBkaXNwbGF5ZWQgdXNpbmcgRkVOXG4gIHRoaXMudGhyZWVmb2xkID0gW107XG59XG5cbkdhbWUucHJvdG90eXBlLnBpZWNlID0gZnVuY3Rpb24gKHR5cGUsIHgsIHksIGNvbG9yKSB7XG4gIHZhciBwaWVjZSA9IF9waWVjZXMuUGllY2VbdHlwZV0oeCwgeSwgY29sb3IsIHRoaXMpO1xuICB0aGlzLmJvYXJkW3ldW3hdID0gcGllY2U7XG5cbiAgdGhpcy5GRU4gPSB0aGlzLmdhbWVUb0ZFTigpO1xuICB0aGlzLkZFTmJvYXJkID0gdGhpcy5ib2FyZFRvRkVOKCk7XG59O1xuXG5HYW1lLnByb3RvdHlwZS5tb3ZlU2VsZWN0ZWQgPSBmdW5jdGlvbiAoc2VsZWN0ZWQsIHRvLCBwcm9tb3Rpb25DYWxsYmFjaywgY2hlY2ttYXRlQ2FsbGJhY2ssIHBsYXlBZ2FpbnN0QUksIGNvbWluZ0FJLCBzaW11bGF0ZSkge1xuICB2YXIgeCA9IHRvLng7XG4gIHZhciB5ID0gdG8ueTtcblxuICBpZiAoc2VsZWN0ZWQpIHtcbiAgICB2YXIgZnJvbSA9IHsgeDogc2VsZWN0ZWQueCwgeTogc2VsZWN0ZWQueSB9O1xuXG4gICAgaWYgKHRoaXMuYm9hcmRbeV1beF0gIT09IHNlbGVjdGVkKSB7XG4gICAgICB2YXIgdmFsaWRNb3ZlcyA9IHNlbGVjdGVkLmdldFZhbGlkTW92ZXMoIXNpbXVsYXRlKTtcbiAgICAgIHZhciB2YWxpZE1vdmUgPSBudWxsO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbGlkTW92ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHZtID0gdmFsaWRNb3Zlc1tpXTtcbiAgICAgICAgaWYgKHZtLnggPT09IHggJiYgdm0ueSA9PT0geSkge1xuICAgICAgICAgIHZhbGlkTW92ZSA9IHZtO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghdmFsaWRNb3ZlKSByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgbW92ZVBpZWNlID0gdmFsaWRNb3ZlLm1vdmVQaWVjZTtcbiAgICAgIHZhciB0YWtlLCBwYXN0ZSwgcm9vaztcbiAgICAgIGlmIChtb3ZlUGllY2UpIHtcbiAgICAgICAgdGFrZSA9IG1vdmVQaWVjZS5mcm9tO1xuICAgICAgICBwYXN0ZSA9IG1vdmVQaWVjZS50bztcbiAgICAgICAgaWYgKHBhc3RlID09PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5ib2FyZFt0YWtlLnldW3Rha2UueF0gPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJvb2sgPSB0aGlzLmJvYXJkW3Rha2UueV1bdGFrZS54XTtcbiAgICAgICAgICB0aGlzLmJvYXJkW3Bhc3RlLnldW3Bhc3RlLnhdID0gcm9vaztcbiAgICAgICAgICByb29rLnggPSBwYXN0ZS54O1xuICAgICAgICAgIHJvb2sueSA9IHBhc3RlLnk7XG4gICAgICAgICAgdGhpcy5ib2FyZFt0YWtlLnldW3Rha2UueF0gPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBwaWVjZSA9IHRoaXMuYm9hcmRbeV1beF0gPyB0aGlzLmJvYXJkW3ldW3hdIDogbnVsbDtcbiAgICAgIG1vdmVQaWVjZSA9IG1vdmVQaWVjZSA/IHZhbGlkTW92ZS5tb3ZlUGllY2UgOiBudWxsO1xuICAgICAgdGhpcy50dXJuLnB1c2goe1xuICAgICAgICBmcm9tOiBmcm9tLFxuICAgICAgICB0bzogdG8sXG4gICAgICAgIGNvbG9yOiBzZWxlY3RlZC5jb2xvcixcbiAgICAgICAgdHlwZTogc2VsZWN0ZWQudHlwZSxcbiAgICAgICAgcGllY2U6IHBpZWNlLFxuICAgICAgICBtb3ZlUGllY2U6IG1vdmVQaWVjZVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuYm9hcmRbeV1beF0gPSBzZWxlY3RlZDtcbiAgICAgIHRoaXMuYm9hcmRbc2VsZWN0ZWQueV1bc2VsZWN0ZWQueF0gPSBudWxsO1xuICAgICAgdGhpcy5ib2FyZFt5XVt4XS54ID0geDtcbiAgICAgIHRoaXMuYm9hcmRbeV1beF0ueSA9IHk7XG5cbiAgICAgIHRoaXMuRkVOID0gdGhpcy5nYW1lVG9GRU4oKTtcbiAgICAgIHRoaXMuRkVOYm9hcmQgPSB0aGlzLmJvYXJkVG9GRU4oKTtcbiAgICAgIC8vIGNoZWNrIGZvciB0aHJlZWZvbGQgcmVwZXRpdGlvblxuXG4gICAgICB0aGlzLnRocmVlZm9sZC5wdXNoKHRoaXMuRkVOYm9hcmQpO1xuICAgICAgaWYgKHNlbGVjdGVkLnR5cGUgPT09ICdwYXduJyB8fCBwaWVjZSkgdGhpcy50aHJlZWZvbGQgPSBbXTtcbiAgICAgIGlmICh0aGlzLnRocmVlZm9sZENoZWNrKCkpIGNoZWNrbWF0ZUNhbGxiYWNrKCdEJyk7XG5cbiAgICAgIC8vIGNoZWNrIGZvciB0aGUgZmlmdHktbW92ZSBydWxlXG4gICAgICBpZiAodGhpcy5oYWxmbW92ZUNsb2NrKCkgPj0gNTApIGNoZWNrbWF0ZUNhbGxiYWNrKCdEJyk7XG5cbiAgICAgIC8vIGNoZWNrIGZvciBwYXduIHByb21vdGlvblxuICAgICAgaWYgKHNlbGVjdGVkLnR5cGUgPT09ICdwYXduJykge1xuICAgICAgICBpZiAoc2VsZWN0ZWQuY29sb3IgPT09ICdXJyAmJiB5ID09PSAwIHx8IHNlbGVjdGVkLmNvbG9yID09PSAnQicgJiYgeSA9PT0gNykge1xuICAgICAgICAgIGlmIChwcm9tb3Rpb25DYWxsYmFjaykge1xuICAgICAgICAgICAgIXBsYXlBZ2FpbnN0QUkgJiYgY29taW5nQUkgJiYgc2VsZWN0ZWQuY29sb3IgPT09ICdCJyA/IHRoaXMucHJvbW90ZVBhd24oc2VsZWN0ZWQsIHgsIHksIHNlbGVjdGVkLmNvbG9yLCAncXVlZW4nKSA6IHByb21vdGlvbkNhbGxiYWNrKHNlbGVjdGVkLCB4LCB5LCBzZWxlY3RlZC5jb2xvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgY2hlY2ttYXRlQ29sb3IgPSBzZWxlY3RlZC5jb2xvciA9PT0gJ1cnID8gJ0InIDogJ1cnO1xuICAgICAgdmFyIGNoZWNrbWF0ZVZhbHVlID0gdGhpcy5jaGVja21hdGUoY2hlY2ttYXRlQ29sb3IpO1xuICAgICAgaWYgKGNoZWNrbWF0ZVZhbHVlKSBjaGVja21hdGVDYWxsYmFjayhjaGVja21hdGVWYWx1ZSk7XG5cbiAgICAgIC8vIFBsYXkgQUlcbiAgICAgIGlmIChwbGF5QWdhaW5zdEFJKSB7XG4gICAgICAgIHZhciBiZXN0TW92ZSA9ICgwLCBfQUkyLmRlZmF1bHQpKHBsYXlBZ2FpbnN0QUkuZGVwdGgsIHRoaXMsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5tb3ZlU2VsZWN0ZWQodGhpcy5ib2FyZFtiZXN0TW92ZS5mcm9tLnldW2Jlc3RNb3ZlLmZyb20ueF0sIGJlc3RNb3ZlLnRvLCBwcm9tb3Rpb25DYWxsYmFjaywgY2hlY2ttYXRlQ2FsbGJhY2ssIGZhbHNlLCB0cnVlLCBzaW11bGF0ZSk7XG4gICAgICB9XG4gICAgICAvLyBlbmRcbiAgICB9XG4gICAgc2VsZWN0ZWQgPSBudWxsO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5HYW1lLnByb3RvdHlwZS5wcm9tb3RlUGF3biA9IGZ1bmN0aW9uIChwYXduLCB4LCB5LCBjb2xvciwgdHlwZSkge1xuICB0aGlzLnBpZWNlKHR5cGUsIHgsIHksIGNvbG9yKTtcbn07XG5cbkdhbWUucHJvdG90eXBlLnNpbXVsYXRlQW5kRmlsdGVyID0gZnVuY3Rpb24gKG1vdmVzLCBwaWVjZSkge1xuICB2YXIgdmFsaWRNb3ZlcyA9IFtdO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBib2FyZCA9IHRoaXMuYm9hcmQ7XG5cbiAgbW92ZXMuZm9yRWFjaChmdW5jdGlvbiAobW92ZSwgaSkge1xuICAgIHZhciB5ID0gbW92ZS55O1xuICAgIHZhciB4ID0gbW92ZS54O1xuICAgIHZhciBmcm9tID0geyB4OiBwaWVjZS54LCB5OiBwaWVjZS55IH07XG4gICAgdmFyIG1vdmVQaWVjZSA9IGJvYXJkW3ldW3hdID8ge1xuICAgICAgcGllY2U6IGJvYXJkW3ldW3hdLFxuICAgICAgZnJvbTogeyB4OiB4LCB5OiB5IH0sXG4gICAgICB0bzogbnVsbFxuICAgIH0gOiBudWxsO1xuXG4gICAgaWYgKG1vdmUubW92ZVBpZWNlKSBtb3ZlUGllY2UgPSBtb3ZlLm1vdmVQaWVjZTtcbiAgICBpZiAobW92ZVBpZWNlKSBzZWxmLnNpbXBsZU1vdmVQaWVjZShtb3ZlUGllY2UucGllY2UsIG1vdmVQaWVjZS5mcm9tLCBtb3ZlUGllY2UudG8pO1xuXG4gICAgc2VsZi5zaW1wbGVNb3ZlUGllY2UocGllY2UsIGZyb20sIHsgeDogeCwgeTogeSB9KTtcbiAgICB2YXIgd2FybmluZyA9IHNlbGYud2FybmluZyhwaWVjZS5jb2xvcik7XG5cbiAgICAvLyBSZXR1cm4ga2luZ1xuICAgIHNlbGYuc2ltcGxlTW92ZVBpZWNlKHBpZWNlLCB7IHg6IHgsIHk6IHkgfSwgZnJvbSk7XG5cbiAgICAvLyByZXR1cm4gdGhlIG1vdmVQaWVjZSB3aXRoIHNpbXBsZU1vdmVQaWVjZSgpIG1ldGhvZFxuICAgIGlmIChtb3ZlUGllY2UpIHNlbGYuc2ltcGxlTW92ZVBpZWNlKG1vdmVQaWVjZS5waWVjZSwgbW92ZVBpZWNlLnRvLCBtb3ZlUGllY2UuZnJvbSk7XG5cbiAgICBpZiAoIXdhcm5pbmcpIHZhbGlkTW92ZXMucHVzaChtb3ZlKTtcbiAgfSk7XG4gIHJldHVybiB2YWxpZE1vdmVzO1xufTtcblxuR2FtZS5wcm90b3R5cGUuY2hlY2ttYXRlID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gIC8vIHVzaW5nIGxldCB3aWxsIGFsbG93IHVzIHRvIG1ha2UgdGhlIGNvZGUgYSBiaXQgc2ltcGxlclxuICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgODsgaisrKSB7XG4gICAgICBpZiAodGhpcy5ib2FyZFtpXVtqXSAmJiB0aGlzLmJvYXJkW2ldW2pdLmNvbG9yID09PSBjb2xvciAmJiB0aGlzLmJvYXJkW2ldW2pdLmdldFZhbGlkTW92ZXModHJ1ZSkubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmICh0aGlzLndhcm5pbmcoY29sb3IpKSByZXR1cm4gY29sb3I7XG4gIHJldHVybiAnRCc7XG59O1xuXG5HYW1lLnByb3RvdHlwZS5zaW1wbGVNb3ZlUGllY2UgPSBmdW5jdGlvbiAocGllY2UsIGZyb20sIHRvKSB7XG4gIHZhciBib2FyZCA9IHRoaXMuYm9hcmQ7XG4gIGlmICh0bykge1xuICAgIGJvYXJkW3RvLnldW3RvLnhdID0gcGllY2U7XG4gICAgcGllY2UueCA9IHRvLng7XG4gICAgcGllY2UueSA9IHRvLnk7XG4gIH1cbiAgaWYgKGZyb20pIGJvYXJkW2Zyb20ueV1bZnJvbS54XSA9IG51bGw7XG59O1xuXG5HYW1lLnByb3RvdHlwZS5zaW1wbGVNb3ZlID0gZnVuY3Rpb24gKG1vdmUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgYm9hcmQgPSBzZWxmLmJvYXJkO1xuICB2YXIgZnJvbSA9IG1vdmUuZnJvbTtcbiAgdmFyIHRvID0gbW92ZS50bztcbiAgdmFyIHBpZWNlID0gYm9hcmRbZnJvbS55XVtmcm9tLnhdO1xuICB2YXIgY2FwdHVyZWRQaWVjZSA9IHRoaXMuYm9hcmRbdG8ueV1bdG8ueF0gPyB0aGlzLmJvYXJkW3RvLnldW3RvLnhdIDogbnVsbDtcbiAgdmFyIG1vdmVQaWVjZSA9IGJvYXJkW3RvLnldW3RvLnhdID8ge1xuICAgIHBpZWNlOiBib2FyZFt0by55XVt0by54XSxcbiAgICBmcm9tOiB7IHg6IHRvLngsIHk6IHRvLnkgfSxcbiAgICB0bzogbnVsbFxuICB9IDogbnVsbDtcblxuICB0aGlzLnR1cm4ucHVzaCh7XG4gICAgZnJvbTogZnJvbSxcbiAgICB0bzogeyB4OiB0by54LCB5OiB0by55IH0sXG4gICAgY29sb3I6IG1vdmUuY29sb3IsXG4gICAgdHlwZTogcGllY2UudHlwZSxcbiAgICBwaWVjZTogY2FwdHVyZWRQaWVjZSxcbiAgICBtb3ZlUGllY2U6IG1vdmVQaWVjZVxuICB9KTtcblxuICBpZiAodG8ubW92ZVBpZWNlKSBtb3ZlUGllY2UgPSB0by5tb3ZlUGllY2U7XG4gIGlmIChtb3ZlUGllY2UpIHNlbGYuc2ltcGxlTW92ZVBpZWNlKG1vdmVQaWVjZS5waWVjZSwgbW92ZVBpZWNlLmZyb20sIG1vdmVQaWVjZS50byk7XG4gIHNlbGYuc2ltcGxlTW92ZVBpZWNlKHBpZWNlLCBmcm9tLCB7IHg6IHRvLngsIHk6IHRvLnkgfSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAvLyByZXR1cm4gdGhlIGN1cnJlbnQgbW92ZSAvZXYvXG4gICAgaWYgKG1vdmVQaWVjZSkgc2VsZi5zaW1wbGVNb3ZlUGllY2UobW92ZVBpZWNlLnBpZWNlLCBtb3ZlUGllY2UudG8sIG1vdmVQaWVjZS5mcm9tKTtcbiAgICBzZWxmLnNpbXBsZU1vdmVQaWVjZShwaWVjZSwgeyB4OiB0by54LCB5OiB0by55IH0sIGZyb20pO1xuICAgIGlmIChjYXB0dXJlZFBpZWNlKSBib2FyZFt0by55XVt0by54XSA9IGNhcHR1cmVkUGllY2U7XG4gICAgc2VsZi50dXJuLnBvcCgpO1xuICB9O1xufTtcblxuR2FtZS5wcm90b3R5cGUud2FybmluZyA9IGZ1bmN0aW9uIChjb2xvcikge1xuICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gIHZhciBraW5nO1xuXG4gIHRoaXMuYm9hcmQuZm9yRWFjaChmdW5jdGlvbiAoeXl5KSB7XG4gICAgeXl5LmZvckVhY2goZnVuY3Rpb24gKHh4eCkge1xuICAgICAgaWYgKHh4eCAmJiB4eHguY29sb3IgPT09IGNvbG9yICYmIHh4eC50eXBlID09PSAna2luZycpIHtcbiAgICAgICAga2luZyA9IHh4eDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgdGhpcy5ib2FyZC5mb3JFYWNoKGZ1bmN0aW9uICh5eXkpIHtcbiAgICB5eXkuZm9yRWFjaChmdW5jdGlvbiAoeHh4KSB7XG4gICAgICBpZiAoeHh4ICYmIHh4eC5jb2xvciAhPT0gY29sb3IpIHtcbiAgICAgICAgeHh4LmdldFZhbGlkTW92ZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChtbW0pIHtcbiAgICAgICAgICBpZiAobW1tLnggPT09IGtpbmcueCAmJiBtbW0ueSA9PT0ga2luZy55KSByZXN1bHQgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5HYW1lLnByb3RvdHlwZS50aHJlZWZvbGRDaGVjayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRocmVlZm9sZCA9IHRoaXMudGhyZWVmb2xkO1xuICB2YXIgbGVuZ3RoID0gdGhyZWVmb2xkLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgLy8gdXNpbmcgbGV0IHdpbGwgYWxsb3cgdXMgdG8gbWFrZSB0aGUgY29kZSBzaW1wbGVyXG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICBmb3IgKHZhciBqID0gaSArIDE7IGogPCBsZW5ndGg7IGorKykge1xuICAgICAgaWYgKHRocmVlZm9sZFtpXSA9PT0gdGhyZWVmb2xkW2pdKSBjb3VudCArPSAxO1xuICAgIH1cbiAgICBpZiAoY291bnQgPj0gMikgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5HYW1lLnByb3RvdHlwZS5waWVjZVRvQU4gPSBmdW5jdGlvbiAoeCwgeSkge1xuICB2YXIgeENoYXJzID0gJ2FiY2RlZmdoJztcbiAgcmV0dXJuIHhDaGFycy5jaGFyQXQoeCkgKyAoOCAtIHkpO1xufTtcblxuLy8gU3VwcG9ydCBGRU4gZnVuY3Rpb25zIGluIHRoZSBBUElcbkdhbWUucHJvdG90eXBlLmJvYXJkVG9GRU4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBib2FyZCA9IHRoaXMuYm9hcmQ7XG5cbiAgLy8gQ29udmVydCB0aGUgYm9hcmQgY29uZmlndXJhdGlvbiBpbnRvIEZFTlxuICB2YXIgRkVOYm9hcmQgPSAnJztcbiAgdmFyIG1pc3NpbmdQaWVjZXMgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgODsgaisrKSB7XG4gICAgICBpZiAoYm9hcmRbaV1bal0pIHtcbiAgICAgICAgaWYgKG1pc3NpbmdQaWVjZXMpIEZFTmJvYXJkICs9IG1pc3NpbmdQaWVjZXM7XG4gICAgICAgIG1pc3NpbmdQaWVjZXMgPSAwO1xuICAgICAgICBGRU5ib2FyZCArPSBib2FyZFtpXVtqXS5GRU5uYW1lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWlzc2luZ1BpZWNlcysrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobWlzc2luZ1BpZWNlcykgRkVOYm9hcmQgKz0gbWlzc2luZ1BpZWNlcztcbiAgICBtaXNzaW5nUGllY2VzID0gMDtcbiAgICBGRU5ib2FyZCArPSBpIDwgNyA/ICcvJyA6ICcnO1xuICB9XG5cbiAgcmV0dXJuIEZFTmJvYXJkO1xufTtcblxuR2FtZS5wcm90b3R5cGUuaGFsZm1vdmVDbG9jayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHR1cm4gPSB0aGlzLnR1cm47XG4gIHZhciBsZW5ndGggPSB0dXJuLmxlbmd0aDtcbiAgdmFyIGNvdW50ID0gMDtcbiAgaWYgKHR1cm4ubGVuZ3RoID09PSAwKSByZXR1cm4gY291bnQ7XG5cbiAgdmFyIGV2ID0gdHVybltsZW5ndGggLSAxIC0gY291bnRdO1xuICB3aGlsZSAoY291bnQgPD0gbGVuZ3RoIC0gMSAmJiBldi50eXBlICE9PSAncGF3bicgJiYgIWV2LnBpZWNlKSB7XG4gICAgY291bnQrKztcbiAgICBldiA9IHR1cm5bbGVuZ3RoIC0gMSAtIGNvdW50XTtcbiAgfVxuXG4gIHJldHVybiBjb3VudDtcbn07XG5cbkdhbWUucHJvdG90eXBlLmFjdGl2ZUNvbG91ciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHR1cm4gPSB0aGlzLnR1cm47XG4gIHZhciBhY3RpdmVDb2xvciA9IHR1cm4ubGVuZ3RoICYmIHR1cm5bdHVybi5sZW5ndGggLSAxXS5jb2xvciA9PT0gJ1cnID8gJ2InIDogJ3cnO1xuXG4gIHJldHVybiBhY3RpdmVDb2xvcjtcbn07XG5cbkdhbWUucHJvdG90eXBlLmNhc3RsaW5nVGFyZ2V0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYm9hcmQgPSB0aGlzLmJvYXJkO1xuICB2YXIgdHVybiA9IHRoaXMudHVybjtcbiAgdmFyIHBvc3NpYmxlQ2FzdGxpbmcgPSAnJztcblxuICB2YXIgd2hpdGVLaW5nTW92ZWQ7XG4gIHZhciBibGFja0tpbmdNb3ZlZDtcbiAgdHVybi5mb3JFYWNoKGZ1bmN0aW9uICh0dXJuKSB7XG4gICAgd2hpdGVLaW5nTW92ZWQgPSB0dXJuLnR5cGUgPT09ICdraW5nJyAmJiB0dXJuLmNvbG9yID09PSAnVyc7XG4gICAgYmxhY2tLaW5nTW92ZWQgPSB0dXJuLnR5cGUgPT09ICdraW5nJyAmJiB0dXJuLmNvbG9yID09PSAnQic7XG4gIH0pO1xuXG4gIFtbNywgMF0sIFswLCAwXSwgWzcsIDddLCBbMCwgN11dLmZvckVhY2goZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgdmFyIHJvb2tYID0gcHJvcHNbMF07XG4gICAgdmFyIHJvb2tZID0gcHJvcHNbMV07XG4gICAgdmFyIHJvb2sgPSBib2FyZFtyb29rWV1bcm9va1hdO1xuXG4gICAgaWYgKHJvb2tZID09PSA3ICYmIHdoaXRlS2luZ01vdmVkKSByZXR1cm47XG4gICAgaWYgKHJvb2tZID09PSAwICYmIGJsYWNrS2luZ01vdmVkKSByZXR1cm47XG5cbiAgICAvLyBDaGVjayByb29rIG9uIHBvc2l0aW9uXG4gICAgaWYgKCFyb29rIHx8ICFyb29rLnR5cGUgPT09ICdyb29rJykgcmV0dXJuO1xuXG4gICAgLy8gQ2hlY2sgcm9vayBoYXNuJ3QgbW92ZWRcbiAgICBpZiAodHVybi5zb21lKGZ1bmN0aW9uIChldikge1xuICAgICAgaWYgKGV2LnR5cGUgIT09ICdyb29rJykgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIGV2LmZyb20ueCA9PT0gcm9va1ggJiYgZXYuZnJvbS55ID09PSByb29rWTtcbiAgICB9KSkgcmV0dXJuO1xuXG4gICAgdmFyIGNhc3RsaW5nU2lkZSA9IHJvb2tYID09PSAwID8gJ3EnIDogJ2snO1xuICAgIHBvc3NpYmxlQ2FzdGxpbmcgKz0gcm9va1kgPT09IDAgPyBjYXN0bGluZ1NpZGUudG9VcHBlckNhc2UoKSA6IGNhc3RsaW5nU2lkZTtcbiAgfSk7XG5cbiAgaWYgKCFwb3NzaWJsZUNhc3RsaW5nKSBwb3NzaWJsZUNhc3RsaW5nID0gJy0nO1xuICByZXR1cm4gcG9zc2libGVDYXN0bGluZztcbn07XG5cbkdhbWUucHJvdG90eXBlLmVuUGFzc2FudFRhcmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHR1cm4gPSB0aGlzLnR1cm47XG4gIHZhciBlblBhc3NhbnRUYXJnZXQgPSAnJztcblxuICBpZiAodHVybi5sZW5ndGgpIHtcbiAgICB2YXIgZXYgPSB0dXJuW3R1cm4ubGVuZ3RoIC0gMV07XG4gICAgaWYgKGV2LmNvbG9yID09PSAnVycgJiYgZXYudG8ueSA9PT0gNCkge1xuICAgICAgZW5QYXNzYW50VGFyZ2V0ID0gdGhpcy5waWVjZVRvQU4oZXYudG8ueCwgZXYudG8ueSArIDEpO1xuICAgIH1cblxuICAgIGlmIChldi5jb2xvciA9PT0gJ0InICYmIGV2LnRvLnkgPT09IDMpIHtcbiAgICAgIGVuUGFzc2FudFRhcmdldCA9IHRoaXMucGllY2VUb0FOKGV2LnRvLngsIGV2LnRvLnkgLSAxKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWVuUGFzc2FudFRhcmdldCkgZW5QYXNzYW50VGFyZ2V0ID0gJy0nO1xuICByZXR1cm4gZW5QYXNzYW50VGFyZ2V0O1xufTtcblxuR2FtZS5wcm90b3R5cGUuZnVsbG1vdmVDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNvdW50ID0gMTtcbiAgdGhpcy50dXJuLmZvckVhY2goZnVuY3Rpb24gKGV2KSB7XG4gICAgaWYgKGV2LmNvbG9yID09PSAnQicpIGNvdW50ICs9IDE7XG4gIH0pO1xuXG4gIHJldHVybiBjb3VudDtcbn07XG5cbkdhbWUucHJvdG90eXBlLmdhbWVUb0ZFTiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIEZFTiA9ICcnO1xuXG4gIC8vIENoZWNrIHRoZSBib2FyZCBjb25maWd1cmF0aW9uXG4gIEZFTiArPSB0aGlzLmJvYXJkVG9GRU4oKTtcblxuICAvLyBGaW5kIHRoZSBhY3RpdmUgY29sb3VyXG4gIEZFTiArPSAnICcgKyB0aGlzLmFjdGl2ZUNvbG91cigpO1xuXG4gIC8vIENoZWNrIGNhc3RsaW5nIGF2YWlsYWJpbGl0eVxuICBGRU4gKz0gJyAnICsgdGhpcy5jYXN0bGluZ1RhcmdldCgpO1xuXG4gIC8vIENoZWNrIHRoZSBFbi1wYXNzYW50IHRhcmdldFxuICBGRU4gKz0gJyAnICsgdGhpcy5lblBhc3NhbnRUYXJnZXQoKTtcblxuICAvLyBBZGQgdGhlIGhhbGZtb3ZlIGNsb2NrXG4gIEZFTiArPSAnICcgKyB0aGlzLmhhbGZtb3ZlQ2xvY2soKTtcblxuICAvLyBBZGQgdGhlIGZ1bGxtb3ZlIG51bWJlclxuICBGRU4gKz0gJyAnICsgdGhpcy5mdWxsbW92ZUNvdW50KCk7XG5cbiAgLypcclxuICAgIE1vcmUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIEZFTiBub3RhdGlvbjpcclxuICAgIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ZvcnN5dGglRTIlODAlOTNFZHdhcmRzX05vdGF0aW9uXHJcbiAgICBodHRwczovL2NoZXNzcHJvZ3JhbW1pbmcud2lraXNwYWNlcy5jb20vRm9yc3l0aC1FZHdhcmRzK05vdGF0aW9uXHJcbiAgKi9cblxuICByZXR1cm4gRkVOO1xufTtcblxuLy8gU2V0IHVwIGRlZmF1bHQgZ2FtZSBjb25maWd1cmF0aW9uXG5HYW1lLnByb3RvdHlwZS5pbml0aWFsaXplR2FtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGRlZmF1bHRHYW1lID0gbmV3IEdhbWUoKTtcblxuICAvLyBQYXduczpcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHtcbiAgICBkZWZhdWx0R2FtZS5waWVjZSgncGF3bicsIGksIDYsICdXJyk7XG4gICAgZGVmYXVsdEdhbWUucGllY2UoJ3Bhd24nLCBpLCAxLCAnQicpO1xuICB9XG5cbiAgLy8gQmxhY2sgZmlnczpcbiAgZGVmYXVsdEdhbWUucGllY2UoJ3Jvb2snLCAwLCAwLCAnQicpO1xuICBkZWZhdWx0R2FtZS5waWVjZSgna25pZ2h0JywgMSwgMCwgJ0InKTtcbiAgZGVmYXVsdEdhbWUucGllY2UoJ2Jpc2hvcCcsIDIsIDAsICdCJyk7XG4gIGRlZmF1bHRHYW1lLnBpZWNlKCdxdWVlbicsIDMsIDAsICdCJyk7XG4gIGRlZmF1bHRHYW1lLnBpZWNlKCdraW5nJywgNCwgMCwgJ0InKTtcbiAgZGVmYXVsdEdhbWUucGllY2UoJ2Jpc2hvcCcsIDUsIDAsICdCJyk7XG4gIGRlZmF1bHRHYW1lLnBpZWNlKCdrbmlnaHQnLCA2LCAwLCAnQicpO1xuICBkZWZhdWx0R2FtZS5waWVjZSgncm9vaycsIDcsIDAsICdCJyk7XG5cbiAgLy8gV2hpdGUgZmlnczpcbiAgZGVmYXVsdEdhbWUucGllY2UoJ3Jvb2snLCAwLCA3LCAnVycpO1xuICBkZWZhdWx0R2FtZS5waWVjZSgna25pZ2h0JywgMSwgNywgJ1cnKTtcbiAgZGVmYXVsdEdhbWUucGllY2UoJ2Jpc2hvcCcsIDIsIDcsICdXJyk7XG4gIGRlZmF1bHRHYW1lLnBpZWNlKCdxdWVlbicsIDMsIDcsICdXJyk7XG4gIGRlZmF1bHRHYW1lLnBpZWNlKCdraW5nJywgNCwgNywgJ1cnKTtcbiAgZGVmYXVsdEdhbWUucGllY2UoJ2Jpc2hvcCcsIDUsIDcsICdXJyk7XG4gIGRlZmF1bHRHYW1lLnBpZWNlKCdrbmlnaHQnLCA2LCA3LCAnVycpO1xuICBkZWZhdWx0R2FtZS5waWVjZSgncm9vaycsIDcsIDcsICdXJyk7XG5cbiAgcmV0dXJuIGRlZmF1bHRHYW1lO1xufTtcblxuR2FtZS5wcm90b3R5cGUuYWxsTW92ZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBib2FyZCA9IHRoaXMuYm9hcmQ7XG4gIHZhciBhbGxNb3ZlcyA9IFtdO1xuICB2YXIgYWN0aXZlQ29sb3VyID0gdGhpcy5hY3RpdmVDb2xvdXIoKS50b1VwcGVyQ2FzZSgpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCA4OyBqKyspIHtcbiAgICAgIGlmIChib2FyZFtpXVtqXSAmJiBib2FyZFtpXVtqXS5jb2xvciA9PT0gYWN0aXZlQ29sb3VyKSB7XG4gICAgICAgIHZhciB2YWxpZE1vdmVzID0gYm9hcmRbaV1bal0uZ2V0VmFsaWRNb3Zlcyh0cnVlKTtcbiAgICAgICAgdmFsaWRNb3Zlcy5mb3JFYWNoKGZ1bmN0aW9uIChldikge1xuICAgICAgICAgIGFsbE1vdmVzLnB1c2goe1xuICAgICAgICAgICAgY29sb3I6IGJvYXJkW2ldW2pdLmNvbG9yLFxuICAgICAgICAgICAgZnJvbTogeyB4OiBqLCB5OiBpIH0sXG4gICAgICAgICAgICB0bzogZXYsXG4gICAgICAgICAgICBGRU5uYW1lOiBib2FyZFtpXVtqXS5GRU5uYW1lXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhbGxNb3Zlcztcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEdhbWU7XG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuLy9cbi8vIFJTRyBDaGVzc1xuLy8gTGljZW5zZWQgdW5kZXIgQXBhY2hlIDIuMCBMSUNFTlNFXG5cbnZhciBQSUVDRV9DSEFSUyA9IGV4cG9ydHMuUElFQ0VfQ0hBUlMgPSB7XG4gIHBhd246IHsgVzogJ+KZmScsIEI6ICfimZ8nIH0sXG4gIHJvb2s6IHsgVzogJ+KZlicsIEI6ICfimZwnIH0sXG4gIGtuaWdodDogeyBXOiAn4pmYJywgQjogJ+KZnicgfSxcbiAgYmlzaG9wOiB7IFc6ICfimZcnLCBCOiAn4pmdJyB9LFxuICBxdWVlbjogeyBXOiAn4pmVJywgQjogJ+KZmycgfSxcbiAga2luZzogeyBXOiAn4pmUJywgQjogJ+KZmicgfVxufTtcblxuZnVuY3Rpb24gUGllY2UoeCwgeSwgY2hhckJhc2UsIGNvbG9yLCBnYW1lLCB0eXBlKSB7XG4gIGlmIChjaGFyQmFzZSkgdGhpcy5jaGFyID0gY2hhckJhc2VbY29sb3JdO1xuICB0aGlzLmNvbG9yID0gY29sb3I7XG4gIHRoaXMueCA9IHg7XG4gIHRoaXMueSA9IHk7XG4gIHRoaXMuZ2FtZSA9IGdhbWU7XG4gIHRoaXMudHlwZSA9IHR5cGU7XG4gIGlmICh0eXBlKSB7XG4gICAgdmFyIEZFTm5hbWUgPSB0eXBlID09PSAna25pZ2h0JyA/ICduJyA6IHR5cGUuY2hhckF0KDApO1xuICAgIGlmICh0aGlzLmNvbG9yID09PSAnVycpIEZFTm5hbWUgPSBGRU5uYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgdGhpcy5GRU5uYW1lID0gRkVObmFtZTtcbiAgfVxufVxuXG5QaWVjZS5lbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBQaWVjZSgpO1xufTtcblxuUGllY2UucHJvdG90eXBlLmdldFZhbGlkTW92ZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBbeyB4OiAwLCB5OiAwIH0sIHsgeDogNywgeTogNyB9XTtcbn07XG5cbmZ1bmN0aW9uIFBhd24oeCwgeSwgY29sb3IsIGdhbWUpIHtcbiAgUGllY2UuY2FsbCh0aGlzLCB4LCB5LCBQSUVDRV9DSEFSUy5wYXduLCBjb2xvciwgZ2FtZSwgJ3Bhd24nKTtcbn1cblxuUGF3bi5wcm90b3R5cGUgPSBQaWVjZS5lbXB0eSgpO1xuUGF3bi5wcm90b3R5cGUuZ2V0VmFsaWRNb3ZlcyA9IGZ1bmN0aW9uIChzaW11bGF0ZSkge1xuICB2YXIgZ2FtZSA9IHRoaXMuZ2FtZTtcbiAgdmFyIG1vdmVzID0gW107XG4gIC8qIGVzbGludC1kaXNhYmxlICovXG4gIHZhciB5ID0gdGhpcy55LFxuICAgICAgeCA9IHRoaXMueDtcbiAgdmFyIGJvYXJkID0gZ2FtZS5ib2FyZCxcbiAgICAgIHR1cm4gPSBnYW1lLnR1cm4sXG4gICAgICBsZW5ndGggPSB0dXJuLmxlbmd0aDtcbiAgdmFyIGxhc3QsIHR1cm5UbywgdHVybkZyb20sIGZpZ1gsIHBhc3NhbnRMYXN0LCBwYXNzYW50RmlnO1xuICB2YXIgY29sb3JZID0gdGhpcy5jb2xvciA9PT0gJ1cnID8geSAtIDEgOiB5ICsgMTtcbiAgdmFyIGNvbG9yWTIgPSB0aGlzLmNvbG9yID09PSAnVycgPyB5IC0gMiA6IHkgKyAyO1xuICB2YXIgcGFzc2FudFkyID0gdGhpcy5jb2xvciA9PT0gJ1cnID8gMyA6IDQ7XG4gIHZhciBmaWdYQXJyYXkgPSBbeCAtIDEsIHggKyAxXTtcbiAgLyogZXNsaW50LWVuYWJsZSAqL1xuXG4gIGlmIChjb2xvclkgPCA4ICYmIGNvbG9yWSA+PSAwICYmICFib2FyZFtjb2xvclldW3hdKSB7XG4gICAgbW92ZXMucHVzaCh7IHg6IHgsIHk6IGNvbG9yWSB9KTtcbiAgICBpZiAoKHkgPT09IDEgfHwgeSA9PT0gNikgJiYgY29sb3JZMiA8IDggJiYgY29sb3JZMiA+PSAwICYmICFnYW1lLmJvYXJkW2NvbG9yWTJdW3hdKSB7XG4gICAgICBtb3Zlcy5wdXNoKHsgeDogeCwgeTogY29sb3JZMiB9KTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDI7IGkrKykge1xuICAgIGZpZ1ggPSBmaWdYQXJyYXlbaV07XG4gICAgaWYgKGNvbG9yWSA8IDggJiYgY29sb3JZID49IDAgJiYgYm9hcmRbY29sb3JZXVtmaWdYXSAmJiBib2FyZFtjb2xvclldW2ZpZ1hdLmNvbG9yICE9PSB0aGlzLmNvbG9yKSBtb3Zlcy5wdXNoKHsgeDogZmlnWCwgeTogY29sb3JZIH0pO1xuICB9XG5cbiAgLy8gQ2hlY2sgZm9yIGVuLXBhc3NhbnRcbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IDI7IF9pKyspIHtcbiAgICBmaWdYID0gZmlnWEFycmF5W19pXTtcbiAgICBsYXN0ID0gdHVybltsZW5ndGggLSAxXTtcblxuICAgIGlmIChsYXN0ICYmIGxhc3QudHlwZSA9PT0gJ3Bhd24nICYmIGxhc3QudG8ueCA9PT0gZmlnWCAmJiBsYXN0LnRvLnkgPT09IHkgJiYgbGFzdC5jb2xvciAhPT0gdGhpcy5jb2xvciAmJiAobGFzdC5mcm9tLnkgPT09IDEgfHwgbGFzdC5mcm9tLnkgPT09IDYpICYmICh5ID09PSAzIHx8IHkgPT09IDQpKSB7XG4gICAgICBtb3Zlcy5wdXNoKHtcbiAgICAgICAgeDogZmlnWCxcbiAgICAgICAgeTogY29sb3JZLFxuICAgICAgICBtb3ZlUGllY2U6IHtcbiAgICAgICAgICBwaWVjZTogZ2FtZS5ib2FyZFt5XVtmaWdYXSxcbiAgICAgICAgICBmcm9tOiB7XG4gICAgICAgICAgICB4OiBmaWdYLFxuICAgICAgICAgICAgeTogeVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdG86IG51bGxcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHZhbGlkTW92ZXMgPSBbXTtcbiAgaWYgKHNpbXVsYXRlKSB7XG4gICAgdmFsaWRNb3ZlcyA9IGdhbWUuc2ltdWxhdGVBbmRGaWx0ZXIobW92ZXMsIHRoaXMpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkTW92ZXMgPSBtb3ZlcztcbiAgfVxuXG4gIHJldHVybiB2YWxpZE1vdmVzO1xufTtcblxuUGllY2UucGF3biA9IGZ1bmN0aW9uICh4LCB5LCBjb2xvciwgZ2FtZSkge1xuICByZXR1cm4gbmV3IFBhd24oeCwgeSwgY29sb3IsIGdhbWUpO1xufTtcblxuLy8gLy9cblxuZnVuY3Rpb24gUm9vayh4LCB5LCBjb2xvciwgZ2FtZSkge1xuICBQaWVjZS5jYWxsKHRoaXMsIHgsIHksIFBJRUNFX0NIQVJTLnJvb2ssIGNvbG9yLCBnYW1lLCAncm9vaycpO1xufVxuXG5Sb29rLnByb3RvdHlwZSA9IFBpZWNlLmVtcHR5KCk7XG5Sb29rLnByb3RvdHlwZS5nZXRWYWxpZE1vdmVzID0gZnVuY3Rpb24gKHNpbXVsYXRlKSB7XG4gIHZhciBnYW1lID0gdGhpcy5nYW1lO1xuICB2YXIgbW92ZXMgPSBbXTtcblxuICBbWy0xLCAwXSwgWzEsIDBdLCBbMCwgMV0sIFswLCAtMV1dLmZvckVhY2goZnVuY3Rpb24gKGNvZWYpIHtcbiAgICB2YXIgaW5kZXgsIHgsIHksIHBpZWNlO1xuICAgIGZvciAoaW5kZXggPSAxOzsgaW5kZXgrKykge1xuICAgICAgeCA9IHRoaXMueCArIGNvZWZbMF0gKiBpbmRleDtcbiAgICAgIHkgPSB0aGlzLnkgKyBjb2VmWzFdICogaW5kZXg7XG4gICAgICBpZiAoeSA8IDAgfHwgeSA+IDcgfHwgeCA8IDAgfHwgeCA+IDcpIGJyZWFrO1xuXG4gICAgICBwaWVjZSA9IGdhbWUuYm9hcmRbeV1beF07XG4gICAgICBpZiAocGllY2UgJiYgcGllY2UuY29sb3IgPT09IHRoaXMuY29sb3IpIGJyZWFrO1xuXG4gICAgICBtb3Zlcy5wdXNoKHsgeDogeCwgeTogeSB9KTtcbiAgICAgIGlmIChwaWVjZSkgYnJlYWs7XG4gICAgfVxuICB9LCB0aGlzKTtcblxuICB2YXIgdmFsaWRNb3ZlcyA9IFtdO1xuICBpZiAoc2ltdWxhdGUpIHtcbiAgICB2YWxpZE1vdmVzID0gZ2FtZS5zaW11bGF0ZUFuZEZpbHRlcihtb3ZlcywgdGhpcyk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWRNb3ZlcyA9IG1vdmVzO1xuICB9XG5cbiAgcmV0dXJuIHZhbGlkTW92ZXM7XG59O1xuXG5QaWVjZS5yb29rID0gZnVuY3Rpb24gKHgsIHksIGNvbG9yLCBnYW1lKSB7XG4gIHJldHVybiBuZXcgUm9vayh4LCB5LCBjb2xvciwgZ2FtZSk7XG59O1xuXG4vLyAvL1xuXG5mdW5jdGlvbiBLbmlnaHQoeCwgeSwgY29sb3IsIGdhbWUpIHtcbiAgUGllY2UuY2FsbCh0aGlzLCB4LCB5LCBQSUVDRV9DSEFSUy5rbmlnaHQsIGNvbG9yLCBnYW1lLCAna25pZ2h0Jyk7XG59XG5cbktuaWdodC5wcm90b3R5cGUgPSBQaWVjZS5lbXB0eSgpO1xuS25pZ2h0LnByb3RvdHlwZS5nZXRWYWxpZE1vdmVzID0gZnVuY3Rpb24gKHNpbXVsYXRlKSB7XG4gIHZhciBnYW1lID0gdGhpcy5nYW1lO1xuICB2YXIgbW92ZXMgPSBbXTtcblxuICB2YXIgY29vcmRpbmF0ZXMgPSBbWzIsIDFdLCBbLTIsIDFdLCBbMSwgMl0sIFstMSwgMl0sIFsyLCAtMV0sIFstMiwgLTFdLCBbMSwgLTJdLCBbLTEsIC0yXV07XG5cbiAgdmFyIG9uZSwgdHdvO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGhlbHAgPSBmYWxzZTtcbiAgICB2YXIgYm9hcmRQaWVjZTtcbiAgICBvbmUgPSBjb29yZGluYXRlc1tpXVswXTtcbiAgICB0d28gPSBjb29yZGluYXRlc1tpXVsxXTtcblxuICAgIGlmICh0aGlzLnggKyBvbmUgPCA4ICYmIHRoaXMueCArIG9uZSA+PSAwICYmIHRoaXMueSArIHR3byA8IDggJiYgdGhpcy55ICsgdHdvID49IDApIHtcbiAgICAgIGJvYXJkUGllY2UgPSBnYW1lLmJvYXJkW3RoaXMueSArIHR3b11bdGhpcy54ICsgb25lXTtcbiAgICAgIGhlbHAgPSBib2FyZFBpZWNlID8gYm9hcmRQaWVjZS5jb2xvciAhPT0gdGhpcy5jb2xvciA6IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGhlbHApIHtcbiAgICAgIG1vdmVzLnB1c2goeyB4OiB0aGlzLnggKyBvbmUsIHk6IHRoaXMueSArIHR3byB9KTtcbiAgICB9XG4gIH1cblxuICB2YXIgdmFsaWRNb3ZlcyA9IFtdO1xuICBpZiAoc2ltdWxhdGUpIHtcbiAgICB2YWxpZE1vdmVzID0gZ2FtZS5zaW11bGF0ZUFuZEZpbHRlcihtb3ZlcywgdGhpcyk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWRNb3ZlcyA9IG1vdmVzO1xuICB9XG5cbiAgcmV0dXJuIHZhbGlkTW92ZXM7XG59O1xuXG5QaWVjZS5rbmlnaHQgPSBmdW5jdGlvbiAoeCwgeSwgY29sb3IsIGdhbWUpIHtcbiAgcmV0dXJuIG5ldyBLbmlnaHQoeCwgeSwgY29sb3IsIGdhbWUpO1xufTtcblxuLy8gLy9cblxuZnVuY3Rpb24gQmlzaG9wKHgsIHksIGNvbG9yLCBnYW1lKSB7XG4gIFBpZWNlLmNhbGwodGhpcywgeCwgeSwgUElFQ0VfQ0hBUlMuYmlzaG9wLCBjb2xvciwgZ2FtZSwgJ2Jpc2hvcCcpO1xufVxuXG5CaXNob3AucHJvdG90eXBlID0gUGllY2UuZW1wdHkoKTtcbkJpc2hvcC5wcm90b3R5cGUuZ2V0VmFsaWRNb3ZlcyA9IGZ1bmN0aW9uIChzaW11bGF0ZSkge1xuICB2YXIgZ2FtZSA9IHRoaXMuZ2FtZTtcbiAgdmFyIG1vdmVzID0gW107XG5cbiAgW1stMSwgLTFdLCBbMSwgMV0sIFstMSwgMV0sIFsxLCAtMV1dLmZvckVhY2goZnVuY3Rpb24gKGNvZWYpIHtcbiAgICB2YXIgaW5kZXgsIHgsIHksIHBpZWNlO1xuICAgIGZvciAoaW5kZXggPSAxOzsgaW5kZXgrKykge1xuICAgICAgeCA9IHRoaXMueCArIGNvZWZbMF0gKiBpbmRleDtcbiAgICAgIHkgPSB0aGlzLnkgKyBjb2VmWzFdICogaW5kZXg7XG4gICAgICBpZiAoeSA8IDAgfHwgeSA+IDcgfHwgeCA8IDAgfHwgeCA+IDcpIGJyZWFrO1xuXG4gICAgICBwaWVjZSA9IGdhbWUuYm9hcmRbeV1beF07XG4gICAgICBpZiAocGllY2UgJiYgcGllY2UuY29sb3IgPT09IHRoaXMuY29sb3IpIGJyZWFrO1xuXG4gICAgICBtb3Zlcy5wdXNoKHsgeDogeCwgeTogeSB9KTtcbiAgICAgIGlmIChwaWVjZSkgYnJlYWs7XG4gICAgfVxuICB9LCB0aGlzKTtcblxuICB2YXIgdmFsaWRNb3ZlcyA9IFtdO1xuICBpZiAoc2ltdWxhdGUpIHtcbiAgICB2YWxpZE1vdmVzID0gZ2FtZS5zaW11bGF0ZUFuZEZpbHRlcihtb3ZlcywgdGhpcyk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWRNb3ZlcyA9IG1vdmVzO1xuICB9XG5cbiAgcmV0dXJuIHZhbGlkTW92ZXM7XG59O1xuXG5QaWVjZS5iaXNob3AgPSBmdW5jdGlvbiAoeCwgeSwgY29sb3IsIGdhbWUpIHtcbiAgcmV0dXJuIG5ldyBCaXNob3AoeCwgeSwgY29sb3IsIGdhbWUpO1xufTtcblxuLy8gLy9cblxuZnVuY3Rpb24gUXVlZW4oeCwgeSwgY29sb3IsIGdhbWUpIHtcbiAgUGllY2UuY2FsbCh0aGlzLCB4LCB5LCBQSUVDRV9DSEFSUy5xdWVlbiwgY29sb3IsIGdhbWUsICdxdWVlbicpO1xufVxuXG5RdWVlbi5wcm90b3R5cGUgPSBQaWVjZS5lbXB0eSgpO1xuUXVlZW4ucHJvdG90eXBlLmdldFZhbGlkTW92ZXMgPSBmdW5jdGlvbiAoc2ltdWxhdGUpIHtcbiAgdmFyIGdhbWUgPSB0aGlzLmdhbWU7XG4gIHZhciByb29rTW92ZXMgPSBSb29rLnByb3RvdHlwZS5nZXRWYWxpZE1vdmVzLmNhbGwodGhpcyk7XG4gIHZhciBiaXNob3BNb3ZlcyA9IEJpc2hvcC5wcm90b3R5cGUuZ2V0VmFsaWRNb3Zlcy5jYWxsKHRoaXMpO1xuICB2YXIgbW92ZXMgPSByb29rTW92ZXMuY29uY2F0KGJpc2hvcE1vdmVzKTtcblxuICB2YXIgdmFsaWRNb3ZlcyA9IFtdO1xuICBpZiAoc2ltdWxhdGUpIHtcbiAgICB2YWxpZE1vdmVzID0gZ2FtZS5zaW11bGF0ZUFuZEZpbHRlcihtb3ZlcywgdGhpcyk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWRNb3ZlcyA9IG1vdmVzO1xuICB9XG5cbiAgcmV0dXJuIHZhbGlkTW92ZXM7XG59O1xuXG5QaWVjZS5xdWVlbiA9IGZ1bmN0aW9uICh4LCB5LCBjb2xvciwgZ2FtZSkge1xuICByZXR1cm4gbmV3IFF1ZWVuKHgsIHksIGNvbG9yLCBnYW1lKTtcbn07XG5cbi8vIC8vXG5cbmZ1bmN0aW9uIEtpbmcoeCwgeSwgY29sb3IsIGdhbWUpIHtcbiAgUGllY2UuY2FsbCh0aGlzLCB4LCB5LCBQSUVDRV9DSEFSUy5raW5nLCBjb2xvciwgZ2FtZSwgJ2tpbmcnKTtcbn1cblxuS2luZy5wcm90b3R5cGUgPSBQaWVjZS5lbXB0eSgpO1xuS2luZy5wcm90b3R5cGUuZ2V0VmFsaWRNb3ZlcyA9IGZ1bmN0aW9uIChzaW11bGF0ZSkge1xuICB2YXIgbW92ZXMgPSBbXTtcbiAgdmFyIGNvb3JkaW5hdGVzID0gW1swLCAxXSwgWzAsIC0xXSwgWzEsIDFdLCBbLTEsIC0xXSwgWzEsIC0xXSwgWy0xLCAxXSwgWy0xLCAwXSwgWzEsIDBdXTtcbiAgdmFyIHggPSB0aGlzLng7XG4gIHZhciB5ID0gdGhpcy55O1xuICB2YXIgZ2FtZSA9IHRoaXMuZ2FtZTtcbiAgdmFyIHR1cm4gPSBnYW1lLnR1cm47XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBjb29yZGluYXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChjb29yZCkge1xuICAgIHZhciBwaWVjZTtcbiAgICB2YXIgeHggPSB4ICsgY29vcmRbMF07XG4gICAgdmFyIHl5ID0geSArIGNvb3JkWzFdO1xuXG4gICAgaWYgKHh4IDwgOCAmJiB4eCA+PSAwICYmIHl5IDwgOCAmJiB5eSA+PSAwKSB7XG4gICAgICBwaWVjZSA9IGdhbWUuYm9hcmRbeXldW3h4XTtcbiAgICAgIGlmICghcGllY2UgfHwgcGllY2UuY29sb3IgIT09IHNlbGYuY29sb3IpIHtcbiAgICAgICAgbW92ZXMucHVzaCh7IHg6IHh4LCB5OiB5eSB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIC8vIENoZWNrIGtpbmcgaGFzbid0IG1vdmVkXG4gIHZhciBraW5nTW92ZWQgPSB0dXJuLnNvbWUoZnVuY3Rpb24gKHR1cm4pIHtcbiAgICByZXR1cm4gdHVybi50eXBlID09PSAna2luZycgJiYgdHVybi5jb2xvciA9PT0gc2VsZi5jb2xvcjtcbiAgfSk7XG5cbiAgaWYgKCFraW5nTW92ZWQpIHtcbiAgICBbWzAsIDIsIC0xXSwgWzcsIDYsICsxXV0uZm9yRWFjaChmdW5jdGlvbiAocHJvcHMpIHtcbiAgICAgIHZhciByb29rWCA9IHByb3BzWzBdO1xuICAgICAgdmFyIG5ld0tpbmdYID0gcHJvcHNbMV07XG4gICAgICB2YXIgZGlyID0gcHJvcHNbMl07XG4gICAgICB2YXIgcm9vayA9IGdhbWUuYm9hcmRbeV1bcm9va1hdO1xuXG4gICAgICAvLyBDaGVjayByb29rIG9uIHBvc2l0aW9uXG4gICAgICBpZiAoIXJvb2sgfHwgIXJvb2sudHlwZSA9PT0gJ3Jvb2snKSByZXR1cm47XG5cbiAgICAgIC8vIENoZWNrIHJvb2sgaGFzbid0IG1vdmVkXG4gICAgICBpZiAodHVybi5zb21lKGZ1bmN0aW9uIChldikge1xuICAgICAgICByZXR1cm4gZXYuZnJvbS54ID09PSByb29rWCAmJiBldi5mcm9tLnkgPT09IHk7XG4gICAgICB9KSkgcmV0dXJuO1xuXG4gICAgICAvLyBDaGVjayBzcXVhcmVzIGVtcHR5IGFuZCBzYWZlXG4gICAgICBmb3IgKHZhciB4eCA9IHggKyBkaXI7IHh4ICE9PSByb29rWDsgeHggKz0gZGlyKSB7XG4gICAgICAgIGlmIChnYW1lLmJvYXJkW3ldW3h4XSkgcmV0dXJuO1xuICAgICAgICB2YXIgc2FmZSA9IHRydWU7XG4gICAgICAgIGdhbWUuYm9hcmQuZm9yRWFjaChmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICBldi5mb3JFYWNoKGZ1bmN0aW9uIChldnYpIHtcbiAgICAgICAgICAgIGlmIChldnYgJiYgZXZ2LnR5cGUgIT09ICdraW5nJyAmJiBldnYuY29sb3IgIT09IHNlbGYuY29sb3IpIHtcbiAgICAgICAgICAgICAgZXZ2LmdldFZhbGlkTW92ZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChldk1vdmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZNb3ZlICYmIGV2TW92ZS55ID09PSB5ICYmIGV2TW92ZS54ID09PSB4eCkgc2FmZSA9IGZhbHNlO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghc2FmZSkgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcm9jaGFkZSA9IHtcbiAgICAgICAgeDogbmV3S2luZ1gsXG4gICAgICAgIHk6IHksXG4gICAgICAgIG1vdmVQaWVjZToge1xuICAgICAgICAgIHBpZWNlOiBzZWxmLmdhbWUuYm9hcmRbeV1bcm9va1hdLFxuICAgICAgICAgIGZyb206IHtcbiAgICAgICAgICAgIHg6IHJvb2tYLCB5OiB5XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0bzoge1xuICAgICAgICAgICAgeTogeSwgeDogeCArIGRpclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgbW92ZXMucHVzaChyb2NoYWRlKTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciB2YWxpZE1vdmVzID0gW107XG4gIGlmIChzaW11bGF0ZSkge1xuICAgIHZhbGlkTW92ZXMgPSBnYW1lLnNpbXVsYXRlQW5kRmlsdGVyKG1vdmVzLCBzZWxmKTtcbiAgfSBlbHNlIHtcbiAgICB2YWxpZE1vdmVzID0gbW92ZXM7XG4gIH1cblxuICByZXR1cm4gdmFsaWRNb3Zlcztcbn07XG5cblBpZWNlLmtpbmcgPSBmdW5jdGlvbiAoeCwgeSwgY29sb3IsIGdhbWUpIHtcbiAgcmV0dXJuIG5ldyBLaW5nKHgsIHksIGNvbG9yLCBnYW1lKTtcbn07XG5cbmV4cG9ydHMuUGllY2UgPSBQaWVjZTtcbmV4cG9ydHMuUGF3biA9IFBhd247XG5leHBvcnRzLlJvb2sgPSBSb29rO1xuZXhwb3J0cy5LbmlnaHQgPSBLbmlnaHQ7XG5leHBvcnRzLkJpc2hvcCA9IEJpc2hvcDtcbmV4cG9ydHMuUXVlZW4gPSBRdWVlbjtcbmV4cG9ydHMuS2luZyA9IEtpbmc7XG5cbi8qKiovIH0pLFxuLyogMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2dhbWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX2dhbWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2FtZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBDaGVzc0FJID0gZnVuY3Rpb24gQ2hlc3NBSShkZXB0aCwgZ2FtZVN0YXRlLCBpc01heGltaXNpbmdQbGF5ZXIpIHtcbiAgLy8gQ2xvbmUgdGhlIGdhbWVTdGF0ZSB0byBhY2Nlc3MgYWxsIGdhbWUgYXNzb2NpYXRlZCBtZXRob2RzLlxuICAvLyBUaGlzIHVzdWFsbHkgZG9lc24ndCBtYWtlIHNlbnNlLCBidXQgc29tZXRpbWVzIHlvdSBjYW5ub3QgcG9zdCBmdW5jdGlvbnMgdG8gYSBiYWNrZW5kIG9yIGEgd2ViLXdvcmtlclxuICAvLyBhbmQgdGhhdCdzIHdoeSB3ZSdyZSB0b3VjaGluZyB0aGUgZ2FtZSBtZXRob2RzIGZyb20gbmV3IGdhbWUgY29uZmlndXJhdGlvbiBpbnRlYWQgZnJvbSB0aGUgcGFzc2VkIGFyZ3VtZW50LlxuICAvLyBTbyBpZiB5b3UgcGFzcyB7Ym9hcmQ6IFtteUJvYXJkXSwgdHVybjpbbXlUdXJuXSwuLi59IGZvciB0aGUgZ2FtZSBhcmd1bWVudCBpdCB3aWxsIGFjdHVhbGx5IHdvcmshXG4gIC8vIEFscmVhZHkgZGVzY3JpYmVkIGhlcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9SU0ctR3JvdXAvQ2hlc3MvaXNzdWVzLzgjaXNzdWVjb21tZW50LTM4MTI0NTc5NFxuICB2YXIgZ2FtZSA9IF9nYW1lMi5kZWZhdWx0LnByb3RvdHlwZS5pbml0aWFsaXplR2FtZSgpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCA4OyBqKyspIHtcbiAgICAgIGlmIChnYW1lU3RhdGUuYm9hcmRbaV1bal0pIHtcbiAgICAgICAgdmFyIGN1cnJlbnRDZWxsID0gZ2FtZVN0YXRlLmJvYXJkW2ldW2pdO1xuICAgICAgICBnYW1lLnBpZWNlKGN1cnJlbnRDZWxsLnR5cGUsIGosIGksIGN1cnJlbnRDZWxsLmNvbG9yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdhbWUuYm9hcmRbaV1bal0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGdhbWUudHVybiA9IGdhbWVTdGF0ZS50dXJuO1xuICBnYW1lLnRocmVlZm9sZCA9IGdhbWVTdGF0ZS50aHJlZWZvbGQ7XG4gIGdhbWUuRkVOID0gZ2FtZVN0YXRlLkZFTjtcbiAgZ2FtZS5GRU5ib2FyZCA9IGdhbWVTdGF0ZS5GRU5ib2FyZDtcblxuICAvLyBTdGFydCBsb29waW5nIGFuZCBzaW11bGF0aW5nIGFsbCB2YWxpZCBtb3Zlc1xuICB2YXIgYWxsTW92ZXMgPSBnYW1lLmFsbE1vdmVzKCk7XG4gIHZhciBiZXN0VmFsdWUgPSAtOTk5OTtcbiAgdmFyIGJlc3RNb3ZlO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsTW92ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbmV3R2FtZU1vdmUgPSBhbGxNb3Zlc1tpXTtcbiAgICB2YXIgdW5kbyA9IGdhbWUuc2ltcGxlTW92ZShuZXdHYW1lTW92ZSk7XG4gICAgdmFyIGJvcmFkVmFsdWUgPSBtaW5pbWF4KGRlcHRoIC0gMSwgZ2FtZSwgLTEwMDAwLCAxMDAwMCwgIWlzTWF4aW1pc2luZ1BsYXllcik7XG4gICAgdW5kbygpO1xuICAgIGlmIChib3JhZFZhbHVlID49IGJlc3RWYWx1ZSkge1xuICAgICAgYmVzdFZhbHVlID0gYm9yYWRWYWx1ZTtcbiAgICAgIGJlc3RNb3ZlID0gbmV3R2FtZU1vdmU7XG4gICAgfVxuICB9XG4gIHJldHVybiBiZXN0TW92ZTtcbn07IC8vXG4vLyBSU0cgQ2hlc3Ncbi8vIExpY2Vuc2VkIHVuZGVyIEFwYWNoZSAyLjAgTElDRU5TRVxuXG52YXIgbWluaW1heCA9IGZ1bmN0aW9uIG1pbmltYXgoZGVwdGgsIGdhbWUsIGFscGhhLCBiZXRhLCBpc01heGltaXNpbmdQbGF5ZXIpIHtcbiAgaWYgKGRlcHRoID09PSAwKSB7XG4gICAgcmV0dXJuIC1ldmFsdWF0ZUJvYXJkKGdhbWUuYm9hcmQpO1xuICB9XG5cbiAgdmFyIGFsbE1vdmVzID0gZ2FtZS5hbGxNb3ZlcygpO1xuICBpZiAoaXNNYXhpbWlzaW5nUGxheWVyKSB7XG4gICAgdmFyIGJlc3RWYWx1ZSA9IC05OTk5O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsTW92ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB1bmRvID0gZ2FtZS5zaW1wbGVNb3ZlKGFsbE1vdmVzW2ldKTtcbiAgICAgIGJlc3RWYWx1ZSA9IE1hdGgubWF4KGJlc3RWYWx1ZSwgbWluaW1heChkZXB0aCAtIDEsIGdhbWUsIGFscGhhLCBiZXRhLCAhaXNNYXhpbWlzaW5nUGxheWVyKSk7XG4gICAgICB1bmRvKCk7XG4gICAgICBhbHBoYSA9IE1hdGgubWF4KGFscGhhLCBiZXN0VmFsdWUpO1xuICAgICAgaWYgKGJldGEgPD0gYWxwaGEpIHtcbiAgICAgICAgcmV0dXJuIGJlc3RWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJlc3RWYWx1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgX2Jlc3RWYWx1ZSA9IDk5OTk7XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFsbE1vdmVzLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF91bmRvID0gZ2FtZS5zaW1wbGVNb3ZlKGFsbE1vdmVzW19pXSk7XG4gICAgICBfYmVzdFZhbHVlID0gTWF0aC5taW4oX2Jlc3RWYWx1ZSwgbWluaW1heChkZXB0aCAtIDEsIGdhbWUsIGFscGhhLCBiZXRhLCAhaXNNYXhpbWlzaW5nUGxheWVyKSk7XG4gICAgICBfdW5kbygpO1xuICAgICAgYmV0YSA9IE1hdGgubWluKGJldGEsIF9iZXN0VmFsdWUpO1xuICAgICAgaWYgKGJldGEgPD0gYWxwaGEpIHtcbiAgICAgICAgcmV0dXJuIF9iZXN0VmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBfYmVzdFZhbHVlO1xuICB9XG59O1xuXG52YXIgZXZhbHVhdGVCb2FyZCA9IGZ1bmN0aW9uIGV2YWx1YXRlQm9hcmQoYm9hcmQpIHtcbiAgdmFyIHRvdGFsRXZhbHVhdGlvbiA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCA4OyBqKyspIHtcbiAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgY3VycmVudCBldmFsdWF0aW9uXG4gICAgICB0b3RhbEV2YWx1YXRpb24gPSB0b3RhbEV2YWx1YXRpb24gKyBnZXRQaWVjZVZhbHVlKGJvYXJkW2ldW2pdKTtcbiAgICB9XG4gIH1cbiAgLy8gcmV0dXJuIHRoZSB0b3RhbCBldmFsdWF0aW9uXG4gIHJldHVybiB0b3RhbEV2YWx1YXRpb247XG59O1xuXG52YXIgZ2V0UGllY2VWYWx1ZSA9IGZ1bmN0aW9uIGdldFBpZWNlVmFsdWUocGllY2UpIHtcbiAgaWYgKHBpZWNlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvLyBnZXQgdmFsdWUgZm9yIGV2ZXJ5IHBpZWNlIG9uIHRoZSBib2FyZFxuICB2YXIgZ2V0QWJzb2x1dGVWYWx1ZSA9IGZ1bmN0aW9uIGdldEFic29sdXRlVmFsdWUocGllY2UpIHtcbiAgICBpZiAocGllY2UudHlwZSA9PT0gJ3Bhd24nKSB7XG4gICAgICByZXR1cm4gMTA7XG4gICAgfSBlbHNlIGlmIChwaWVjZS50eXBlID09PSAncm9vaycpIHtcbiAgICAgIHJldHVybiA1MDtcbiAgICB9IGVsc2UgaWYgKHBpZWNlLnR5cGUgPT09ICdrbmlnaHQnKSB7XG4gICAgICByZXR1cm4gMzA7XG4gICAgfSBlbHNlIGlmIChwaWVjZS50eXBlID09PSAnYmlzaG9wJykge1xuICAgICAgcmV0dXJuIDMwO1xuICAgIH0gZWxzZSBpZiAocGllY2UudHlwZSA9PT0gJ3F1ZWVuJykge1xuICAgICAgcmV0dXJuIDkwO1xuICAgIH0gZWxzZSBpZiAocGllY2UudHlwZSA9PT0gJ2tpbmcnKSB7XG4gICAgICByZXR1cm4gOTAwO1xuICAgIH1cbiAgfTtcblxuICAvLyBjYWxjdWxhdGUgdGhlIGFic29sdXRlIHZhbHVlIGFuZCByZXR1cm4gaXRcbiAgdmFyIGFic29sdXRlVmFsdWUgPSBnZXRBYnNvbHV0ZVZhbHVlKHBpZWNlLCBwaWVjZS5jb2xvciA9PT0gJ1cnKTtcbiAgcmV0dXJuIHBpZWNlLmNvbG9yID09PSAnVycgPyBhYnNvbHV0ZVZhbHVlIDogLWFic29sdXRlVmFsdWU7XG59O1xuXG4vLyBleHBvcnQgdGhlIGFsZ29yaXRobVxuZXhwb3J0cy5kZWZhdWx0ID0gQ2hlc3NBSTtcblxuLy8gV3JpdHRlbiBieSBSYWRpIENob1xuLy8gUlNHIENoZXNzIC0gYnkgUlNHIEdyb3VwXG5cbi8qKiovIH0pLFxuLyogMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5BSSA9IGV4cG9ydHMuUGllY2VzID0gZXhwb3J0cy5HYW1lID0gdW5kZWZpbmVkO1xuXG52YXIgX2dhbWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX2dhbWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2FtZSk7XG5cbnZhciBfcGllY2VzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIFBpZWNlcyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9waWVjZXMpO1xuXG52YXIgX0FJID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIF9BSTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BSSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8vIEFuZCBleHBvcnQuLi5cbmV4cG9ydHMuR2FtZSA9IF9nYW1lMi5kZWZhdWx0O1xuZXhwb3J0cy5QaWVjZXMgPSBQaWVjZXM7XG5leHBvcnRzLkFJID0gX0FJMi5kZWZhdWx0OyAvLyBMZXQncyBpbXBvcnQuLi5cblxuLyoqKi8gfSlcbi8qKioqKiovIF0pO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yc2ctY2hlc3MvbGliL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=