/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _rsgChess = __webpack_require__(1);

self.addEventListener('message', function (e) {
  if (e.data && e.data.game && e.data.playAgainstAI) {
    var bestMove = (0, _rsgChess.AI)(e.data.playAgainstAI.depth, e.data.game, true);
    self.postMessage(bestMove);
  }
}); // self.importScripts("game.js");

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("rsg-chess", [], factory);
	else if(typeof exports === 'object')
		exports["rsg-chess"] = factory();
	else
		root["rsg-chess"] = factory();
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 2);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _pieces = __webpack_require__(1);

function Game(promoCallback) {
  // the game board
  this.board = [];
  // fill the board
  for (var i = 0; i < 8; i++) {
    var arrayIn = [];
    for (var j = 0; j < 8; j++) {
      arrayIn.push(null);
    }
    this.board.push(arrayIn);
  }

  // the history of all turns
  this.turn = [];
  // the current FEN status
  this.FEN = [];
  // the current game configuration as FEN
  this.FENboard = [];
  // the history of all game configurations displayed using FEN
  this.threefold = [];
}

Game.prototype.piece = function (type, x, y, color) {
  var piece = _pieces.Piece[type](x, y, color, this);
  this.board[y][x] = piece;

  this.FEN = this.gameToFEN();
  this.FENboard = this.boardToFEN();
};

Game.prototype.moveSelected = function (selected, to, promotionCallback, checkmateCallback, simulate) {
  var x = to.x;
  var y = to.y;

  if (selected) {
    var from = { x: selected.x, y: selected.y };

    if (this.board[y][x] !== selected) {
      var validMoves = selected.getValidMoves(!simulate);
      var validMove = null;

      for (var i = 0; i < validMoves.length; i++) {
        var vm = validMoves[i];
        if (vm.x === x && vm.y === y) {
          validMove = vm;
          break;
        }
      }

      if (!validMove) return false;
      var movePiece = validMove.movePiece;
      var take, paste, rook;
      if (movePiece) {
        take = movePiece.from;
        paste = movePiece.to;
        if (paste === null) {
          this.board[take.y][take.x] = null;
        } else {
          rook = this.board[take.y][take.x];
          this.board[paste.y][paste.x] = rook;
          rook.x = paste.x;
          rook.y = paste.y;
          this.board[take.y][take.x] = null;
        }
      }

      var piece = this.board[y][x] ? this.board[y][x] : null;
      movePiece = movePiece ? validMove.movePiece : null;
      this.turn.push({
        from: from,
        to: to,
        color: selected.color,
        type: selected.type,
        piece: piece,
        movePiece: movePiece
      });

      this.board[y][x] = selected;
      this.board[selected.y][selected.x] = null;
      this.board[y][x].x = x;
      this.board[y][x].y = y;

      this.FEN = this.gameToFEN();
      this.FENboard = this.boardToFEN();
      // check for threefold repetition

      this.threefold.push(this.FENboard);
      if (selected.type === 'pawn' || piece) this.threefold = [];
      if (this.threefoldCheck()) checkmateCallback('D');

      // check for the fifty-move rule
      if (this.halfmoveClock() >= 50) checkmateCallback('D');

      // check for pawn promotion
      if (selected.type === 'pawn' && y !== selected.y) {
        if (selected.color === 'W' && y === 0 || selected.color === 'B' && y === 7) {
          if (promotionCallback) promotionCallback(selected, x, y, selected.color);
        }
      };

      var checkmateColor = selected.color === 'W' ? 'B' : 'W';
      var checkmateValue = this.checkmate(checkmateColor);
      if (checkmateValue) checkmateCallback(checkmateValue);

      // // Play AI
      // We decided to remove the AI movements from game.js, because this slows down your app
      // and makes really hard to implement external chess sources like: web workers, backends, cloud functions, ect.
    }
    selected = null;
    return true;
    // end
  }
};

Game.prototype.promotePawn = function (pawn, x, y, color, type) {
  this.piece(type, x, y, color);
};

Game.prototype.simulateAndFilter = function (moves, piece) {
  var validMoves = [];
  var self = this;
  var board = this.board;

  moves.forEach(function (move, i) {
    var y = move.y;
    var x = move.x;
    var from = { x: piece.x, y: piece.y };
    var movePiece = board[y][x] ? {
      piece: board[y][x],
      from: { x: x, y: y },
      to: null
    } : null;

    if (move.movePiece) movePiece = move.movePiece;
    if (movePiece) self.simpleMovePiece(movePiece.piece, movePiece.from, movePiece.to);

    self.simpleMovePiece(piece, from, { x: x, y: y });
    var warning = self.warning(piece.color);

    // Return king
    self.simpleMovePiece(piece, { x: x, y: y }, from);

    // return the movePiece with simpleMovePiece() method
    if (movePiece) self.simpleMovePiece(movePiece.piece, movePiece.to, movePiece.from);

    if (!warning) validMoves.push(move);
  });
  return validMoves;
};

Game.prototype.checkmate = function (color) {
  // using let will allow us to make the code a bit simpler
  for (var i = 0; i < 8; i++) {
    for (var j = 0; j < 8; j++) {
      if (this.board[i][j] && this.board[i][j].color === color && this.board[i][j].getValidMoves(true).length) return false;
    }
  }
  if (this.warning(color)) return color;
  return 'D';
};

Game.prototype.simpleMovePiece = function (piece, from, to) {
  var board = this.board;
  if (to) {
    board[to.y][to.x] = piece;
    piece.x = to.x;
    piece.y = to.y;
  }
  if (from) board[from.y][from.x] = null;
};

Game.prototype.simpleMove = function (move) {
  var self = this;
  var board = self.board;
  var from = move.from;
  var to = move.to;
  var piece = board[from.y][from.x];
  var capturedPiece = this.board[to.y][to.x] ? this.board[to.y][to.x] : null;
  var movePiece = board[to.y][to.x] ? {
    piece: board[to.y][to.x],
    from: { x: to.x, y: to.y },
    to: null
  } : null;

  this.turn.push({
    from: from,
    to: { x: to.x, y: to.y },
    color: move.color,
    type: piece.type,
    piece: capturedPiece,
    movePiece: movePiece
  });

  if (to.movePiece) movePiece = to.movePiece;
  if (movePiece) self.simpleMovePiece(movePiece.piece, movePiece.from, movePiece.to);
  self.simpleMovePiece(piece, from, { x: to.x, y: to.y });

  return function () {
    // return the current move /ev/
    if (movePiece) self.simpleMovePiece(movePiece.piece, movePiece.to, movePiece.from);
    self.simpleMovePiece(piece, { x: to.x, y: to.y }, from);
    if (capturedPiece) board[to.y][to.x] = capturedPiece;
    self.turn.pop();
  };
};

Game.prototype.warning = function (color) {
  var result = false;
  var king;

  this.board.forEach(function (yyy) {
    yyy.forEach(function (xxx) {
      if (xxx && xxx.color === color && xxx.type === 'king') {
        king = xxx;
      }
    });
  });

  this.board.forEach(function (yyy) {
    yyy.forEach(function (xxx) {
      if (xxx && xxx.color !== color) {
        xxx.getValidMoves().forEach(function (mmm) {
          if (mmm.x === king.x && mmm.y === king.y) result = true;
        });
      }
    });
  });
  return result;
};

Game.prototype.threefoldCheck = function () {
  var threefold = this.threefold;
  var length = threefold.length;

  for (var i = 0; i < length; i++) {
    // using let will allow us to make the code simpler
    var count = 0;
    for (var j = i + 1; j < length; j++) {
      if (threefold[i] === threefold[j]) count += 1;
    }
    if (count >= 2) return true;
  }

  return false;
};

Game.prototype.pieceToAN = function (x, y) {
  var xChars = 'abcdefgh';
  return xChars.charAt(x) + (8 - y);
};

// Support FEN functions in the API
Game.prototype.boardToFEN = function () {
  var board = this.board;

  // Convert the board configuration into FEN
  var FENboard = '';
  var missingPieces = 0;
  for (var i = 0; i < 8; i++) {
    for (var j = 0; j < 8; j++) {
      if (board[i][j]) {
        if (missingPieces) FENboard += missingPieces;
        missingPieces = 0;
        FENboard += board[i][j].FENname;
      } else {
        missingPieces++;
      }
    }
    if (missingPieces) FENboard += missingPieces;
    missingPieces = 0;
    FENboard += i < 7 ? '/' : '';
  }

  return FENboard;
};

Game.prototype.halfmoveClock = function () {
  var turn = this.turn;
  var length = turn.length;
  var count = 0;
  if (turn.length === 0) return count;

  var ev = turn[length - 1 - count];
  while (count <= length - 1 && ev.type !== 'pawn' && !ev.piece) {
    count++;
    ev = turn[length - 1 - count];
  }

  return count;
};

Game.prototype.activeColour = function () {
  var turn = this.turn;
  var activeColor = turn.length && turn[turn.length - 1].color === 'W' ? 'b' : 'w';

  return activeColor;
};

Game.prototype.castlingTarget = function () {
  var board = this.board;
  var turn = this.turn;
  var possibleCastling = '';

  var whiteKingMoved;
  var blackKingMoved;
  turn.forEach(function (turn) {
    whiteKingMoved = turn.type === 'king' && turn.color === 'W';
    blackKingMoved = turn.type === 'king' && turn.color === 'B';
  });

  [[7, 0], [0, 0], [7, 7], [0, 7]].forEach(function (props) {
    var rookX = props[0];
    var rookY = props[1];
    var rook = board[rookY][rookX];

    if (rookY === 7 && whiteKingMoved) return;
    if (rookY === 0 && blackKingMoved) return;

    // Check rook on position
    if (!rook || !rook.type === 'rook') return;

    // Check rook hasn't moved
    if (turn.some(function (ev) {
      if (ev.type !== 'rook') return false;
      return ev.from.x === rookX && ev.from.y === rookY;
    })) return;

    var castlingSide = rookX === 0 ? 'q' : 'k';
    possibleCastling += rookY === 0 ? castlingSide.toUpperCase() : castlingSide;
  });

  if (!possibleCastling) possibleCastling = '-';
  return possibleCastling;
};

Game.prototype.enPassantTarget = function () {
  var turn = this.turn;
  var enPassantTarget = '';

  if (turn.length) {
    var ev = turn[turn.length - 1];
    if (ev.color === 'W' && ev.to.y === 4) {
      enPassantTarget = this.pieceToAN(ev.to.x, ev.to.y + 1);
    }

    if (ev.color === 'B' && ev.to.y === 3) {
      enPassantTarget = this.pieceToAN(ev.to.x, ev.to.y - 1);
    }
  }

  if (!enPassantTarget) enPassantTarget = '-';
  return enPassantTarget;
};

Game.prototype.fullmoveCount = function () {
  var count = 1;
  this.turn.forEach(function (ev) {
    if (ev.color === 'B') count += 1;
  });

  return count;
};

Game.prototype.gameToFEN = function () {
  var FEN = '';

  // Check the board configuration
  FEN += this.boardToFEN();

  // Find the active colour
  FEN += ' ' + this.activeColour();

  // Check castling availability
  FEN += ' ' + this.castlingTarget();

  // Check the En-passant target
  FEN += ' ' + this.enPassantTarget();

  // Add the halfmove clock
  FEN += ' ' + this.halfmoveClock();

  // Add the fullmove number
  FEN += ' ' + this.fullmoveCount();

  /*
    More information about the FEN notation:
    https://en.wikipedia.org/wiki/Forsyth%E2%80%93Edwards_Notation
    https://chessprogramming.wikispaces.com/Forsyth-Edwards+Notation
  */

  return FEN;
};

// Set up default game configuration
Game.prototype.initializeGame = function () {
  var defaultGame = new Game();

  // Pawns:
  for (var i = 0; i < 8; i++) {
    defaultGame.piece('pawn', i, 6, 'W');
    defaultGame.piece('pawn', i, 1, 'B');
  }

  // Black figs:
  defaultGame.piece('rook', 0, 0, 'B');
  defaultGame.piece('knight', 1, 0, 'B');
  defaultGame.piece('bishop', 2, 0, 'B');
  defaultGame.piece('queen', 3, 0, 'B');
  defaultGame.piece('king', 4, 0, 'B');
  defaultGame.piece('bishop', 5, 0, 'B');
  defaultGame.piece('knight', 6, 0, 'B');
  defaultGame.piece('rook', 7, 0, 'B');

  // White figs:
  defaultGame.piece('rook', 0, 7, 'W');
  defaultGame.piece('knight', 1, 7, 'W');
  defaultGame.piece('bishop', 2, 7, 'W');
  defaultGame.piece('queen', 3, 7, 'W');
  defaultGame.piece('king', 4, 7, 'W');
  defaultGame.piece('bishop', 5, 7, 'W');
  defaultGame.piece('knight', 6, 7, 'W');
  defaultGame.piece('rook', 7, 7, 'W');

  return defaultGame;
};

Game.prototype.allMoves = function () {
  var board = this.board;
  var allMoves = [];
  var activeColour = this.activeColour().toUpperCase();

  for (var i = 0; i < 8; i++) {
    for (var j = 0; j < 8; j++) {
      if (board[i][j] && board[i][j].color === activeColour) {
        var validMoves = board[i][j].getValidMoves(true);
        validMoves.forEach(function (ev) {
          allMoves.push({
            color: board[i][j].color,
            from: { x: j, y: i },
            to: ev,
            FENname: board[i][j].FENname
          });
        });
      }
    }
  }

  return allMoves;
};

exports.default = Game;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
//
// RSG Chess
// Licensed under Apache 2.0 LICENSE

var PIECE_CHARS = exports.PIECE_CHARS = {
  pawn: { W: '♙', B: '♟' },
  rook: { W: '♖', B: '♜' },
  knight: { W: '♘', B: '♞' },
  bishop: { W: '♗', B: '♝' },
  queen: { W: '♕', B: '♛' },
  king: { W: '♔', B: '♚' }
};

function Piece(x, y, charBase, color, game, type) {
  if (charBase) this.char = charBase[color];
  this.color = color;
  this.x = x;
  this.y = y;
  this.game = game;
  this.type = type;
  if (type) {
    var FENname = type === 'knight' ? 'n' : type.charAt(0);
    if (this.color === 'W') FENname = FENname.toUpperCase();
    this.FENname = FENname;
  }
}

Piece.empty = function () {
  return new Piece();
};

Piece.prototype.getValidMoves = function () {
  return [{ x: 0, y: 0 }, { x: 7, y: 7 }];
};

function Pawn(x, y, color, game) {
  Piece.call(this, x, y, PIECE_CHARS.pawn, color, game, 'pawn');
}

Pawn.prototype = Piece.empty();
Pawn.prototype.getValidMoves = function (simulate) {
  var game = this.game;
  var moves = [];
  /* eslint-disable */
  var y = this.y,
      x = this.x;
  var board = game.board,
      turn = game.turn,
      length = turn.length;
  var last, turnTo, turnFrom, figX, passantLast, passantFig;
  var colorY = this.color === 'W' ? y - 1 : y + 1;
  var colorY2 = this.color === 'W' ? y - 2 : y + 2;
  var passantY2 = this.color === 'W' ? 3 : 4;
  var figXArray = [x - 1, x + 1];
  /* eslint-enable */

  if (colorY < 8 && colorY >= 0 && !board[colorY][x]) {
    moves.push({ x: x, y: colorY });
    if ((y === 1 || y === 6) && colorY2 < 8 && colorY2 >= 0 && !game.board[colorY2][x]) {
      moves.push({ x: x, y: colorY2 });
    }
  }

  for (var i = 0; i < 2; i++) {
    figX = figXArray[i];
    if (colorY < 8 && colorY >= 0 && board[colorY][figX] && board[colorY][figX].color !== this.color) moves.push({ x: figX, y: colorY });
  }

  // Check for en-passant
  for (var _i = 0; _i < 2; _i++) {
    figX = figXArray[_i];
    last = turn[length - 1];

    if (last && last.type === 'pawn' && last.to.x === figX && last.to.y === y && last.color !== this.color && (last.from.y === 1 || last.from.y === 6) && (y === 3 || y === 4)) {
      moves.push({
        x: figX,
        y: colorY,
        movePiece: {
          piece: game.board[y][figX],
          from: {
            x: figX,
            y: y
          },
          to: null
        }
      });
    }
  }

  var validMoves = [];
  if (simulate) {
    validMoves = game.simulateAndFilter(moves, this);
  } else {
    validMoves = moves;
  }

  return validMoves;
};

Piece.pawn = function (x, y, color, game) {
  return new Pawn(x, y, color, game);
};

// //

function Rook(x, y, color, game) {
  Piece.call(this, x, y, PIECE_CHARS.rook, color, game, 'rook');
}

Rook.prototype = Piece.empty();
Rook.prototype.getValidMoves = function (simulate) {
  var game = this.game;
  var moves = [];

  [[-1, 0], [1, 0], [0, 1], [0, -1]].forEach(function (coef) {
    var index, x, y, piece;
    for (index = 1;; index++) {
      x = this.x + coef[0] * index;
      y = this.y + coef[1] * index;
      if (y < 0 || y > 7 || x < 0 || x > 7) break;

      piece = game.board[y][x];
      if (piece && piece.color === this.color) break;

      moves.push({ x: x, y: y });
      if (piece) break;
    }
  }, this);

  var validMoves = [];
  if (simulate) {
    validMoves = game.simulateAndFilter(moves, this);
  } else {
    validMoves = moves;
  }

  return validMoves;
};

Piece.rook = function (x, y, color, game) {
  return new Rook(x, y, color, game);
};

// //

function Knight(x, y, color, game) {
  Piece.call(this, x, y, PIECE_CHARS.knight, color, game, 'knight');
}

Knight.prototype = Piece.empty();
Knight.prototype.getValidMoves = function (simulate) {
  var game = this.game;
  var moves = [];

  var coordinates = [[2, 1], [-2, 1], [1, 2], [-1, 2], [2, -1], [-2, -1], [1, -2], [-1, -2]];

  var one, two;
  for (var i = 0; i < coordinates.length; i++) {
    var help = false;
    var boardPiece;
    one = coordinates[i][0];
    two = coordinates[i][1];

    if (this.x + one < 8 && this.x + one >= 0 && this.y + two < 8 && this.y + two >= 0) {
      boardPiece = game.board[this.y + two][this.x + one];
      help = boardPiece ? boardPiece.color !== this.color : true;
    }

    if (help) {
      moves.push({ x: this.x + one, y: this.y + two });
    }
  }

  var validMoves = [];
  if (simulate) {
    validMoves = game.simulateAndFilter(moves, this);
  } else {
    validMoves = moves;
  }

  return validMoves;
};

Piece.knight = function (x, y, color, game) {
  return new Knight(x, y, color, game);
};

// //

function Bishop(x, y, color, game) {
  Piece.call(this, x, y, PIECE_CHARS.bishop, color, game, 'bishop');
}

Bishop.prototype = Piece.empty();
Bishop.prototype.getValidMoves = function (simulate) {
  var game = this.game;
  var moves = [];

  [[-1, -1], [1, 1], [-1, 1], [1, -1]].forEach(function (coef) {
    var index, x, y, piece;
    for (index = 1;; index++) {
      x = this.x + coef[0] * index;
      y = this.y + coef[1] * index;
      if (y < 0 || y > 7 || x < 0 || x > 7) break;

      piece = game.board[y][x];
      if (piece && piece.color === this.color) break;

      moves.push({ x: x, y: y });
      if (piece) break;
    }
  }, this);

  var validMoves = [];
  if (simulate) {
    validMoves = game.simulateAndFilter(moves, this);
  } else {
    validMoves = moves;
  }

  return validMoves;
};

Piece.bishop = function (x, y, color, game) {
  return new Bishop(x, y, color, game);
};

// //

function Queen(x, y, color, game) {
  Piece.call(this, x, y, PIECE_CHARS.queen, color, game, 'queen');
}

Queen.prototype = Piece.empty();
Queen.prototype.getValidMoves = function (simulate) {
  var game = this.game;
  var rookMoves = Rook.prototype.getValidMoves.call(this);
  var bishopMoves = Bishop.prototype.getValidMoves.call(this);
  var moves = rookMoves.concat(bishopMoves);

  var validMoves = [];
  if (simulate) {
    validMoves = game.simulateAndFilter(moves, this);
  } else {
    validMoves = moves;
  }

  return validMoves;
};

Piece.queen = function (x, y, color, game) {
  return new Queen(x, y, color, game);
};

// //

function King(x, y, color, game) {
  Piece.call(this, x, y, PIECE_CHARS.king, color, game, 'king');
}

King.prototype = Piece.empty();
King.prototype.getValidMoves = function (simulate) {
  var moves = [];
  var coordinates = [[0, 1], [0, -1], [1, 1], [-1, -1], [1, -1], [-1, 1], [-1, 0], [1, 0]];
  var x = this.x;
  var y = this.y;
  var game = this.game;
  var turn = game.turn;
  var self = this;

  coordinates.forEach(function (coord) {
    var piece;
    var xx = x + coord[0];
    var yy = y + coord[1];

    if (xx < 8 && xx >= 0 && yy < 8 && yy >= 0) {
      piece = game.board[yy][xx];
      if (!piece || piece.color !== self.color) {
        moves.push({ x: xx, y: yy });
      }
    }
  });

  // Check king hasn't moved
  var kingMoved = turn.some(function (turn) {
    return turn.type === 'king' && turn.color === self.color;
  });

  if (!kingMoved) {
    [[0, 2, -1], [7, 6, +1]].forEach(function (props) {
      var rookX = props[0];
      var newKingX = props[1];
      var dir = props[2];
      var rook = game.board[y][rookX];

      // Check rook on position
      if (!rook || !rook.type === 'rook') return;

      // Check rook hasn't moved
      if (turn.some(function (ev) {
        return ev.from.x === rookX && ev.from.y === y;
      })) return;

      // Check squares empty and safe
      for (var xx = x + dir; xx !== rookX; xx += dir) {
        if (game.board[y][xx]) return;
        var safe = true;
        game.board.forEach(function (ev) {
          ev.forEach(function (evv) {
            if (evv && evv.type !== 'king' && evv.color !== self.color) {
              evv.getValidMoves().forEach(function (evMove) {
                if (evMove && evMove.y === y && evMove.x === xx) safe = false;
              });
            }
          });
        });
        if (!safe) return;
      }

      var rochade = {
        x: newKingX,
        y: y,
        movePiece: {
          piece: self.game.board[y][rookX],
          from: {
            x: rookX, y: y
          },
          to: {
            y: y, x: x + dir
          }
        }
      };

      moves.push(rochade);
    });
  }

  var validMoves = [];
  if (simulate) {
    validMoves = game.simulateAndFilter(moves, self);
  } else {
    validMoves = moves;
  }

  return validMoves;
};

Piece.king = function (x, y, color, game) {
  return new King(x, y, color, game);
};

exports.Piece = Piece;
exports.Pawn = Pawn;
exports.Rook = Rook;
exports.Knight = Knight;
exports.Bishop = Bishop;
exports.Queen = Queen;
exports.King = King;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AI = exports.Pieces = exports.Game = undefined;

var _game = __webpack_require__(0);

var _game2 = _interopRequireDefault(_game);

var _pieces = __webpack_require__(1);

var Pieces = _interopRequireWildcard(_pieces);

var _AI = __webpack_require__(3);

var _AI2 = _interopRequireDefault(_AI);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// And export...
exports.Game = _game2.default;
exports.Pieces = Pieces;
exports.AI = _AI2.default; // Let's import...

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _game = __webpack_require__(0);

var _game2 = _interopRequireDefault(_game);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ChessAI = function ChessAI(depth, gameState, isMaximisingPlayer) {
  // Clone the gameState to access all game associated methods.
  // This usually doesn't make sense, but sometimes you cannot post functions to a backend or a web-worker
  // and that's why we're touching the game methods from new game configuration intead from the passed argument.
  // So if you pass {board: [myBoard], turn:[myTurn],...} for the game argument it will actually work!
  // Already described here: https://github.com/RSG-Group/Chess/issues/8#issuecomment-381245794
  var game = _game2.default.prototype.initializeGame();

  for (var i = 0; i < 8; i++) {
    for (var j = 0; j < 8; j++) {
      if (gameState.board[i][j]) {
        var currentCell = gameState.board[i][j];
        game.piece(currentCell.type, j, i, currentCell.color);
      } else {
        game.board[i][j] = null;
      }
    }
  }

  game.turn = gameState.turn;
  game.threefold = gameState.threefold;
  game.FEN = gameState.FEN;
  game.FENboard = gameState.FENboard;

  // Start looping and simulating all valid moves
  var allMoves = game.allMoves();
  var bestValue = -9999;
  var bestMove;

  for (var i = 0; i < allMoves.length; i++) {
    var newGameMove = allMoves[i];
    var undo = game.simpleMove(newGameMove);
    var boradValue = minimax(depth - 1, game, -10000, 10000, !isMaximisingPlayer);
    undo();
    if (boradValue >= bestValue) {
      bestValue = boradValue;
      bestMove = newGameMove;
    }
  }
  return bestMove;
}; //
// RSG Chess
// Licensed under Apache 2.0 LICENSE

var minimax = function minimax(depth, game, alpha, beta, isMaximisingPlayer) {
  if (depth === 0) {
    return -evaluateBoard(game.board);
  }

  var allMoves = game.allMoves();
  if (isMaximisingPlayer) {
    var bestValue = -9999;
    for (var i = 0; i < allMoves.length; i++) {
      var undo = game.simpleMove(allMoves[i]);
      bestValue = Math.max(bestValue, minimax(depth - 1, game, alpha, beta, !isMaximisingPlayer));
      undo();
      alpha = Math.max(alpha, bestValue);
      if (beta <= alpha) {
        return bestValue;
      }
    }
    return bestValue;
  } else {
    var _bestValue = 9999;
    for (var _i = 0; _i < allMoves.length; _i++) {
      var _undo = game.simpleMove(allMoves[_i]);
      _bestValue = Math.min(_bestValue, minimax(depth - 1, game, alpha, beta, !isMaximisingPlayer));
      _undo();
      beta = Math.min(beta, _bestValue);
      if (beta <= alpha) {
        return _bestValue;
      }
    }
    return _bestValue;
  }
};

var evaluateBoard = function evaluateBoard(board) {
  var totalEvaluation = 0;
  for (var i = 0; i < 8; i++) {
    for (var j = 0; j < 8; j++) {
      // calculate the current evaluation
      totalEvaluation = totalEvaluation + getPieceValue(board[i][j]);
    }
  }
  // return the total evaluation
  return totalEvaluation;
};

var getPieceValue = function getPieceValue(piece) {
  if (piece === null) {
    return 0;
  }

  // get value for every piece on the board
  var getAbsoluteValue = function getAbsoluteValue(piece) {
    if (piece.type === 'pawn') {
      return 10;
    } else if (piece.type === 'rook') {
      return 50;
    } else if (piece.type === 'knight') {
      return 30;
    } else if (piece.type === 'bishop') {
      return 30;
    } else if (piece.type === 'queen') {
      return 90;
    } else if (piece.type === 'king') {
      return 900;
    }
  };

  // calculate the absolute value and return it
  var absoluteValue = getAbsoluteValue(piece, piece.color === 'W');
  return piece.color === 'W' ? absoluteValue : -absoluteValue;
};

// export the algorithm
exports.default = ChessAI;

// Written by Radi Cho
// RSG Chess - by RSG Group

/***/ })
/******/ ]);
});
//# sourceMappingURL=index.js.map

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgNzEwNDAyYzBkZDQwNjBjNmEwZGQiLCJ3ZWJwYWNrOi8vLy4vanMvd29ya2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yc2ctY2hlc3MvbGliL2luZGV4LmpzIl0sIm5hbWVzIjpbInNlbGYiLCJhZGRFdmVudExpc3RlbmVyIiwiZSIsImRhdGEiLCJnYW1lIiwicGxheUFnYWluc3RBSSIsImJlc3RNb3ZlIiwiZGVwdGgiLCJwb3N0TWVzc2FnZSJdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7O0FDNURBOztBQUVBQSxLQUFLQyxnQkFBTCxDQUFzQixTQUF0QixFQUFpQyxVQUFVQyxDQUFWLEVBQWE7QUFDNUMsTUFBSUEsRUFBRUMsSUFBRixJQUFVRCxFQUFFQyxJQUFGLENBQU9DLElBQWpCLElBQXlCRixFQUFFQyxJQUFGLENBQU9FLGFBQXBDLEVBQW1EO0FBQ2pELFFBQUlDLFdBQVcsa0JBQUdKLEVBQUVDLElBQUYsQ0FBT0UsYUFBUCxDQUFxQkUsS0FBeEIsRUFBK0JMLEVBQUVDLElBQUYsQ0FBT0MsSUFBdEMsRUFBNEMsSUFBNUMsQ0FBZjtBQUNBSixTQUFLUSxXQUFMLENBQWlCRixRQUFqQjtBQUNEO0FBQ0YsQ0FMRCxFLENBSEEsaUM7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QXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEIsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQSxDQUFDO0FBQ0QsaUMiLCJmaWxlIjoid29ya2VyLm1pbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDApO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIDcxMDQwMmMwZGQ0MDYwYzZhMGRkIiwiLy8gc2VsZi5pbXBvcnRTY3JpcHRzKFwiZ2FtZS5qc1wiKTtcclxuaW1wb3J0IHsgQUkgfSBmcm9tICdyc2ctY2hlc3MnXHJcblxyXG5zZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAoZSkge1xyXG4gIGlmIChlLmRhdGEgJiYgZS5kYXRhLmdhbWUgJiYgZS5kYXRhLnBsYXlBZ2FpbnN0QUkpIHtcclxuICAgIHZhciBiZXN0TW92ZSA9IEFJKGUuZGF0YS5wbGF5QWdhaW5zdEFJLmRlcHRoLCBlLmRhdGEuZ2FtZSwgdHJ1ZSlcclxuICAgIHNlbGYucG9zdE1lc3NhZ2UoYmVzdE1vdmUpXHJcbiAgfVxyXG59KVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9qcy93b3JrZXIuanMiLCIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShcInJzZy1jaGVzc1wiLCBbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJyc2ctY2hlc3NcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wicnNnLWNoZXNzXCJdID0gZmFjdG9yeSgpO1xufSkodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbi8qKioqKiovIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbi8qKioqKiovIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbi8qKioqKiovIFx0XHRcdH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAyKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9waWVjZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG5mdW5jdGlvbiBHYW1lKHByb21vQ2FsbGJhY2spIHtcbiAgLy8gdGhlIGdhbWUgYm9hcmRcbiAgdGhpcy5ib2FyZCA9IFtdO1xuICAvLyBmaWxsIHRoZSBib2FyZFxuICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykge1xuICAgIHZhciBhcnJheUluID0gW107XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCA4OyBqKyspIHtcbiAgICAgIGFycmF5SW4ucHVzaChudWxsKTtcbiAgICB9XG4gICAgdGhpcy5ib2FyZC5wdXNoKGFycmF5SW4pO1xuICB9XG5cbiAgLy8gdGhlIGhpc3Rvcnkgb2YgYWxsIHR1cm5zXG4gIHRoaXMudHVybiA9IFtdO1xuICAvLyB0aGUgY3VycmVudCBGRU4gc3RhdHVzXG4gIHRoaXMuRkVOID0gW107XG4gIC8vIHRoZSBjdXJyZW50IGdhbWUgY29uZmlndXJhdGlvbiBhcyBGRU5cbiAgdGhpcy5GRU5ib2FyZCA9IFtdO1xuICAvLyB0aGUgaGlzdG9yeSBvZiBhbGwgZ2FtZSBjb25maWd1cmF0aW9ucyBkaXNwbGF5ZWQgdXNpbmcgRkVOXG4gIHRoaXMudGhyZWVmb2xkID0gW107XG59XG5cbkdhbWUucHJvdG90eXBlLnBpZWNlID0gZnVuY3Rpb24gKHR5cGUsIHgsIHksIGNvbG9yKSB7XG4gIHZhciBwaWVjZSA9IF9waWVjZXMuUGllY2VbdHlwZV0oeCwgeSwgY29sb3IsIHRoaXMpO1xuICB0aGlzLmJvYXJkW3ldW3hdID0gcGllY2U7XG5cbiAgdGhpcy5GRU4gPSB0aGlzLmdhbWVUb0ZFTigpO1xuICB0aGlzLkZFTmJvYXJkID0gdGhpcy5ib2FyZFRvRkVOKCk7XG59O1xuXG5HYW1lLnByb3RvdHlwZS5tb3ZlU2VsZWN0ZWQgPSBmdW5jdGlvbiAoc2VsZWN0ZWQsIHRvLCBwcm9tb3Rpb25DYWxsYmFjaywgY2hlY2ttYXRlQ2FsbGJhY2ssIHNpbXVsYXRlKSB7XG4gIHZhciB4ID0gdG8ueDtcbiAgdmFyIHkgPSB0by55O1xuXG4gIGlmIChzZWxlY3RlZCkge1xuICAgIHZhciBmcm9tID0geyB4OiBzZWxlY3RlZC54LCB5OiBzZWxlY3RlZC55IH07XG5cbiAgICBpZiAodGhpcy5ib2FyZFt5XVt4XSAhPT0gc2VsZWN0ZWQpIHtcbiAgICAgIHZhciB2YWxpZE1vdmVzID0gc2VsZWN0ZWQuZ2V0VmFsaWRNb3Zlcyghc2ltdWxhdGUpO1xuICAgICAgdmFyIHZhbGlkTW92ZSA9IG51bGw7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsaWRNb3Zlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdm0gPSB2YWxpZE1vdmVzW2ldO1xuICAgICAgICBpZiAodm0ueCA9PT0geCAmJiB2bS55ID09PSB5KSB7XG4gICAgICAgICAgdmFsaWRNb3ZlID0gdm07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCF2YWxpZE1vdmUpIHJldHVybiBmYWxzZTtcbiAgICAgIHZhciBtb3ZlUGllY2UgPSB2YWxpZE1vdmUubW92ZVBpZWNlO1xuICAgICAgdmFyIHRha2UsIHBhc3RlLCByb29rO1xuICAgICAgaWYgKG1vdmVQaWVjZSkge1xuICAgICAgICB0YWtlID0gbW92ZVBpZWNlLmZyb207XG4gICAgICAgIHBhc3RlID0gbW92ZVBpZWNlLnRvO1xuICAgICAgICBpZiAocGFzdGUgPT09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLmJvYXJkW3Rha2UueV1bdGFrZS54XSA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcm9vayA9IHRoaXMuYm9hcmRbdGFrZS55XVt0YWtlLnhdO1xuICAgICAgICAgIHRoaXMuYm9hcmRbcGFzdGUueV1bcGFzdGUueF0gPSByb29rO1xuICAgICAgICAgIHJvb2sueCA9IHBhc3RlLng7XG4gICAgICAgICAgcm9vay55ID0gcGFzdGUueTtcbiAgICAgICAgICB0aGlzLmJvYXJkW3Rha2UueV1bdGFrZS54XSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHBpZWNlID0gdGhpcy5ib2FyZFt5XVt4XSA/IHRoaXMuYm9hcmRbeV1beF0gOiBudWxsO1xuICAgICAgbW92ZVBpZWNlID0gbW92ZVBpZWNlID8gdmFsaWRNb3ZlLm1vdmVQaWVjZSA6IG51bGw7XG4gICAgICB0aGlzLnR1cm4ucHVzaCh7XG4gICAgICAgIGZyb206IGZyb20sXG4gICAgICAgIHRvOiB0byxcbiAgICAgICAgY29sb3I6IHNlbGVjdGVkLmNvbG9yLFxuICAgICAgICB0eXBlOiBzZWxlY3RlZC50eXBlLFxuICAgICAgICBwaWVjZTogcGllY2UsXG4gICAgICAgIG1vdmVQaWVjZTogbW92ZVBpZWNlXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5ib2FyZFt5XVt4XSA9IHNlbGVjdGVkO1xuICAgICAgdGhpcy5ib2FyZFtzZWxlY3RlZC55XVtzZWxlY3RlZC54XSA9IG51bGw7XG4gICAgICB0aGlzLmJvYXJkW3ldW3hdLnggPSB4O1xuICAgICAgdGhpcy5ib2FyZFt5XVt4XS55ID0geTtcblxuICAgICAgdGhpcy5GRU4gPSB0aGlzLmdhbWVUb0ZFTigpO1xuICAgICAgdGhpcy5GRU5ib2FyZCA9IHRoaXMuYm9hcmRUb0ZFTigpO1xuICAgICAgLy8gY2hlY2sgZm9yIHRocmVlZm9sZCByZXBldGl0aW9uXG5cbiAgICAgIHRoaXMudGhyZWVmb2xkLnB1c2godGhpcy5GRU5ib2FyZCk7XG4gICAgICBpZiAoc2VsZWN0ZWQudHlwZSA9PT0gJ3Bhd24nIHx8IHBpZWNlKSB0aGlzLnRocmVlZm9sZCA9IFtdO1xuICAgICAgaWYgKHRoaXMudGhyZWVmb2xkQ2hlY2soKSkgY2hlY2ttYXRlQ2FsbGJhY2soJ0QnKTtcblxuICAgICAgLy8gY2hlY2sgZm9yIHRoZSBmaWZ0eS1tb3ZlIHJ1bGVcbiAgICAgIGlmICh0aGlzLmhhbGZtb3ZlQ2xvY2soKSA+PSA1MCkgY2hlY2ttYXRlQ2FsbGJhY2soJ0QnKTtcblxuICAgICAgLy8gY2hlY2sgZm9yIHBhd24gcHJvbW90aW9uXG4gICAgICBpZiAoc2VsZWN0ZWQudHlwZSA9PT0gJ3Bhd24nICYmIHkgIT09IHNlbGVjdGVkLnkpIHtcbiAgICAgICAgaWYgKHNlbGVjdGVkLmNvbG9yID09PSAnVycgJiYgeSA9PT0gMCB8fCBzZWxlY3RlZC5jb2xvciA9PT0gJ0InICYmIHkgPT09IDcpIHtcbiAgICAgICAgICBpZiAocHJvbW90aW9uQ2FsbGJhY2spIHByb21vdGlvbkNhbGxiYWNrKHNlbGVjdGVkLCB4LCB5LCBzZWxlY3RlZC5jb2xvcik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBjaGVja21hdGVDb2xvciA9IHNlbGVjdGVkLmNvbG9yID09PSAnVycgPyAnQicgOiAnVyc7XG4gICAgICB2YXIgY2hlY2ttYXRlVmFsdWUgPSB0aGlzLmNoZWNrbWF0ZShjaGVja21hdGVDb2xvcik7XG4gICAgICBpZiAoY2hlY2ttYXRlVmFsdWUpIGNoZWNrbWF0ZUNhbGxiYWNrKGNoZWNrbWF0ZVZhbHVlKTtcblxuICAgICAgLy8gLy8gUGxheSBBSVxuICAgICAgLy8gV2UgZGVjaWRlZCB0byByZW1vdmUgdGhlIEFJIG1vdmVtZW50cyBmcm9tIGdhbWUuanMsIGJlY2F1c2UgdGhpcyBzbG93cyBkb3duIHlvdXIgYXBwXG4gICAgICAvLyBhbmQgbWFrZXMgcmVhbGx5IGhhcmQgdG8gaW1wbGVtZW50IGV4dGVybmFsIGNoZXNzIHNvdXJjZXMgbGlrZTogd2ViIHdvcmtlcnMsIGJhY2tlbmRzLCBjbG91ZCBmdW5jdGlvbnMsIGVjdC5cbiAgICB9XG4gICAgc2VsZWN0ZWQgPSBudWxsO1xuICAgIHJldHVybiB0cnVlO1xuICAgIC8vIGVuZFxuICB9XG59O1xuXG5HYW1lLnByb3RvdHlwZS5wcm9tb3RlUGF3biA9IGZ1bmN0aW9uIChwYXduLCB4LCB5LCBjb2xvciwgdHlwZSkge1xuICB0aGlzLnBpZWNlKHR5cGUsIHgsIHksIGNvbG9yKTtcbn07XG5cbkdhbWUucHJvdG90eXBlLnNpbXVsYXRlQW5kRmlsdGVyID0gZnVuY3Rpb24gKG1vdmVzLCBwaWVjZSkge1xuICB2YXIgdmFsaWRNb3ZlcyA9IFtdO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBib2FyZCA9IHRoaXMuYm9hcmQ7XG5cbiAgbW92ZXMuZm9yRWFjaChmdW5jdGlvbiAobW92ZSwgaSkge1xuICAgIHZhciB5ID0gbW92ZS55O1xuICAgIHZhciB4ID0gbW92ZS54O1xuICAgIHZhciBmcm9tID0geyB4OiBwaWVjZS54LCB5OiBwaWVjZS55IH07XG4gICAgdmFyIG1vdmVQaWVjZSA9IGJvYXJkW3ldW3hdID8ge1xuICAgICAgcGllY2U6IGJvYXJkW3ldW3hdLFxuICAgICAgZnJvbTogeyB4OiB4LCB5OiB5IH0sXG4gICAgICB0bzogbnVsbFxuICAgIH0gOiBudWxsO1xuXG4gICAgaWYgKG1vdmUubW92ZVBpZWNlKSBtb3ZlUGllY2UgPSBtb3ZlLm1vdmVQaWVjZTtcbiAgICBpZiAobW92ZVBpZWNlKSBzZWxmLnNpbXBsZU1vdmVQaWVjZShtb3ZlUGllY2UucGllY2UsIG1vdmVQaWVjZS5mcm9tLCBtb3ZlUGllY2UudG8pO1xuXG4gICAgc2VsZi5zaW1wbGVNb3ZlUGllY2UocGllY2UsIGZyb20sIHsgeDogeCwgeTogeSB9KTtcbiAgICB2YXIgd2FybmluZyA9IHNlbGYud2FybmluZyhwaWVjZS5jb2xvcik7XG5cbiAgICAvLyBSZXR1cm4ga2luZ1xuICAgIHNlbGYuc2ltcGxlTW92ZVBpZWNlKHBpZWNlLCB7IHg6IHgsIHk6IHkgfSwgZnJvbSk7XG5cbiAgICAvLyByZXR1cm4gdGhlIG1vdmVQaWVjZSB3aXRoIHNpbXBsZU1vdmVQaWVjZSgpIG1ldGhvZFxuICAgIGlmIChtb3ZlUGllY2UpIHNlbGYuc2ltcGxlTW92ZVBpZWNlKG1vdmVQaWVjZS5waWVjZSwgbW92ZVBpZWNlLnRvLCBtb3ZlUGllY2UuZnJvbSk7XG5cbiAgICBpZiAoIXdhcm5pbmcpIHZhbGlkTW92ZXMucHVzaChtb3ZlKTtcbiAgfSk7XG4gIHJldHVybiB2YWxpZE1vdmVzO1xufTtcblxuR2FtZS5wcm90b3R5cGUuY2hlY2ttYXRlID0gZnVuY3Rpb24gKGNvbG9yKSB7XG4gIC8vIHVzaW5nIGxldCB3aWxsIGFsbG93IHVzIHRvIG1ha2UgdGhlIGNvZGUgYSBiaXQgc2ltcGxlclxuICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgODsgaisrKSB7XG4gICAgICBpZiAodGhpcy5ib2FyZFtpXVtqXSAmJiB0aGlzLmJvYXJkW2ldW2pdLmNvbG9yID09PSBjb2xvciAmJiB0aGlzLmJvYXJkW2ldW2pdLmdldFZhbGlkTW92ZXModHJ1ZSkubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmICh0aGlzLndhcm5pbmcoY29sb3IpKSByZXR1cm4gY29sb3I7XG4gIHJldHVybiAnRCc7XG59O1xuXG5HYW1lLnByb3RvdHlwZS5zaW1wbGVNb3ZlUGllY2UgPSBmdW5jdGlvbiAocGllY2UsIGZyb20sIHRvKSB7XG4gIHZhciBib2FyZCA9IHRoaXMuYm9hcmQ7XG4gIGlmICh0bykge1xuICAgIGJvYXJkW3RvLnldW3RvLnhdID0gcGllY2U7XG4gICAgcGllY2UueCA9IHRvLng7XG4gICAgcGllY2UueSA9IHRvLnk7XG4gIH1cbiAgaWYgKGZyb20pIGJvYXJkW2Zyb20ueV1bZnJvbS54XSA9IG51bGw7XG59O1xuXG5HYW1lLnByb3RvdHlwZS5zaW1wbGVNb3ZlID0gZnVuY3Rpb24gKG1vdmUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgYm9hcmQgPSBzZWxmLmJvYXJkO1xuICB2YXIgZnJvbSA9IG1vdmUuZnJvbTtcbiAgdmFyIHRvID0gbW92ZS50bztcbiAgdmFyIHBpZWNlID0gYm9hcmRbZnJvbS55XVtmcm9tLnhdO1xuICB2YXIgY2FwdHVyZWRQaWVjZSA9IHRoaXMuYm9hcmRbdG8ueV1bdG8ueF0gPyB0aGlzLmJvYXJkW3RvLnldW3RvLnhdIDogbnVsbDtcbiAgdmFyIG1vdmVQaWVjZSA9IGJvYXJkW3RvLnldW3RvLnhdID8ge1xuICAgIHBpZWNlOiBib2FyZFt0by55XVt0by54XSxcbiAgICBmcm9tOiB7IHg6IHRvLngsIHk6IHRvLnkgfSxcbiAgICB0bzogbnVsbFxuICB9IDogbnVsbDtcblxuICB0aGlzLnR1cm4ucHVzaCh7XG4gICAgZnJvbTogZnJvbSxcbiAgICB0bzogeyB4OiB0by54LCB5OiB0by55IH0sXG4gICAgY29sb3I6IG1vdmUuY29sb3IsXG4gICAgdHlwZTogcGllY2UudHlwZSxcbiAgICBwaWVjZTogY2FwdHVyZWRQaWVjZSxcbiAgICBtb3ZlUGllY2U6IG1vdmVQaWVjZVxuICB9KTtcblxuICBpZiAodG8ubW92ZVBpZWNlKSBtb3ZlUGllY2UgPSB0by5tb3ZlUGllY2U7XG4gIGlmIChtb3ZlUGllY2UpIHNlbGYuc2ltcGxlTW92ZVBpZWNlKG1vdmVQaWVjZS5waWVjZSwgbW92ZVBpZWNlLmZyb20sIG1vdmVQaWVjZS50byk7XG4gIHNlbGYuc2ltcGxlTW92ZVBpZWNlKHBpZWNlLCBmcm9tLCB7IHg6IHRvLngsIHk6IHRvLnkgfSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAvLyByZXR1cm4gdGhlIGN1cnJlbnQgbW92ZSAvZXYvXG4gICAgaWYgKG1vdmVQaWVjZSkgc2VsZi5zaW1wbGVNb3ZlUGllY2UobW92ZVBpZWNlLnBpZWNlLCBtb3ZlUGllY2UudG8sIG1vdmVQaWVjZS5mcm9tKTtcbiAgICBzZWxmLnNpbXBsZU1vdmVQaWVjZShwaWVjZSwgeyB4OiB0by54LCB5OiB0by55IH0sIGZyb20pO1xuICAgIGlmIChjYXB0dXJlZFBpZWNlKSBib2FyZFt0by55XVt0by54XSA9IGNhcHR1cmVkUGllY2U7XG4gICAgc2VsZi50dXJuLnBvcCgpO1xuICB9O1xufTtcblxuR2FtZS5wcm90b3R5cGUud2FybmluZyA9IGZ1bmN0aW9uIChjb2xvcikge1xuICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gIHZhciBraW5nO1xuXG4gIHRoaXMuYm9hcmQuZm9yRWFjaChmdW5jdGlvbiAoeXl5KSB7XG4gICAgeXl5LmZvckVhY2goZnVuY3Rpb24gKHh4eCkge1xuICAgICAgaWYgKHh4eCAmJiB4eHguY29sb3IgPT09IGNvbG9yICYmIHh4eC50eXBlID09PSAna2luZycpIHtcbiAgICAgICAga2luZyA9IHh4eDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgdGhpcy5ib2FyZC5mb3JFYWNoKGZ1bmN0aW9uICh5eXkpIHtcbiAgICB5eXkuZm9yRWFjaChmdW5jdGlvbiAoeHh4KSB7XG4gICAgICBpZiAoeHh4ICYmIHh4eC5jb2xvciAhPT0gY29sb3IpIHtcbiAgICAgICAgeHh4LmdldFZhbGlkTW92ZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChtbW0pIHtcbiAgICAgICAgICBpZiAobW1tLnggPT09IGtpbmcueCAmJiBtbW0ueSA9PT0ga2luZy55KSByZXN1bHQgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5HYW1lLnByb3RvdHlwZS50aHJlZWZvbGRDaGVjayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRocmVlZm9sZCA9IHRoaXMudGhyZWVmb2xkO1xuICB2YXIgbGVuZ3RoID0gdGhyZWVmb2xkLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgLy8gdXNpbmcgbGV0IHdpbGwgYWxsb3cgdXMgdG8gbWFrZSB0aGUgY29kZSBzaW1wbGVyXG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICBmb3IgKHZhciBqID0gaSArIDE7IGogPCBsZW5ndGg7IGorKykge1xuICAgICAgaWYgKHRocmVlZm9sZFtpXSA9PT0gdGhyZWVmb2xkW2pdKSBjb3VudCArPSAxO1xuICAgIH1cbiAgICBpZiAoY291bnQgPj0gMikgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5HYW1lLnByb3RvdHlwZS5waWVjZVRvQU4gPSBmdW5jdGlvbiAoeCwgeSkge1xuICB2YXIgeENoYXJzID0gJ2FiY2RlZmdoJztcbiAgcmV0dXJuIHhDaGFycy5jaGFyQXQoeCkgKyAoOCAtIHkpO1xufTtcblxuLy8gU3VwcG9ydCBGRU4gZnVuY3Rpb25zIGluIHRoZSBBUElcbkdhbWUucHJvdG90eXBlLmJvYXJkVG9GRU4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBib2FyZCA9IHRoaXMuYm9hcmQ7XG5cbiAgLy8gQ29udmVydCB0aGUgYm9hcmQgY29uZmlndXJhdGlvbiBpbnRvIEZFTlxuICB2YXIgRkVOYm9hcmQgPSAnJztcbiAgdmFyIG1pc3NpbmdQaWVjZXMgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgODsgaisrKSB7XG4gICAgICBpZiAoYm9hcmRbaV1bal0pIHtcbiAgICAgICAgaWYgKG1pc3NpbmdQaWVjZXMpIEZFTmJvYXJkICs9IG1pc3NpbmdQaWVjZXM7XG4gICAgICAgIG1pc3NpbmdQaWVjZXMgPSAwO1xuICAgICAgICBGRU5ib2FyZCArPSBib2FyZFtpXVtqXS5GRU5uYW1lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWlzc2luZ1BpZWNlcysrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobWlzc2luZ1BpZWNlcykgRkVOYm9hcmQgKz0gbWlzc2luZ1BpZWNlcztcbiAgICBtaXNzaW5nUGllY2VzID0gMDtcbiAgICBGRU5ib2FyZCArPSBpIDwgNyA/ICcvJyA6ICcnO1xuICB9XG5cbiAgcmV0dXJuIEZFTmJvYXJkO1xufTtcblxuR2FtZS5wcm90b3R5cGUuaGFsZm1vdmVDbG9jayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHR1cm4gPSB0aGlzLnR1cm47XG4gIHZhciBsZW5ndGggPSB0dXJuLmxlbmd0aDtcbiAgdmFyIGNvdW50ID0gMDtcbiAgaWYgKHR1cm4ubGVuZ3RoID09PSAwKSByZXR1cm4gY291bnQ7XG5cbiAgdmFyIGV2ID0gdHVybltsZW5ndGggLSAxIC0gY291bnRdO1xuICB3aGlsZSAoY291bnQgPD0gbGVuZ3RoIC0gMSAmJiBldi50eXBlICE9PSAncGF3bicgJiYgIWV2LnBpZWNlKSB7XG4gICAgY291bnQrKztcbiAgICBldiA9IHR1cm5bbGVuZ3RoIC0gMSAtIGNvdW50XTtcbiAgfVxuXG4gIHJldHVybiBjb3VudDtcbn07XG5cbkdhbWUucHJvdG90eXBlLmFjdGl2ZUNvbG91ciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHR1cm4gPSB0aGlzLnR1cm47XG4gIHZhciBhY3RpdmVDb2xvciA9IHR1cm4ubGVuZ3RoICYmIHR1cm5bdHVybi5sZW5ndGggLSAxXS5jb2xvciA9PT0gJ1cnID8gJ2InIDogJ3cnO1xuXG4gIHJldHVybiBhY3RpdmVDb2xvcjtcbn07XG5cbkdhbWUucHJvdG90eXBlLmNhc3RsaW5nVGFyZ2V0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYm9hcmQgPSB0aGlzLmJvYXJkO1xuICB2YXIgdHVybiA9IHRoaXMudHVybjtcbiAgdmFyIHBvc3NpYmxlQ2FzdGxpbmcgPSAnJztcblxuICB2YXIgd2hpdGVLaW5nTW92ZWQ7XG4gIHZhciBibGFja0tpbmdNb3ZlZDtcbiAgdHVybi5mb3JFYWNoKGZ1bmN0aW9uICh0dXJuKSB7XG4gICAgd2hpdGVLaW5nTW92ZWQgPSB0dXJuLnR5cGUgPT09ICdraW5nJyAmJiB0dXJuLmNvbG9yID09PSAnVyc7XG4gICAgYmxhY2tLaW5nTW92ZWQgPSB0dXJuLnR5cGUgPT09ICdraW5nJyAmJiB0dXJuLmNvbG9yID09PSAnQic7XG4gIH0pO1xuXG4gIFtbNywgMF0sIFswLCAwXSwgWzcsIDddLCBbMCwgN11dLmZvckVhY2goZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgdmFyIHJvb2tYID0gcHJvcHNbMF07XG4gICAgdmFyIHJvb2tZID0gcHJvcHNbMV07XG4gICAgdmFyIHJvb2sgPSBib2FyZFtyb29rWV1bcm9va1hdO1xuXG4gICAgaWYgKHJvb2tZID09PSA3ICYmIHdoaXRlS2luZ01vdmVkKSByZXR1cm47XG4gICAgaWYgKHJvb2tZID09PSAwICYmIGJsYWNrS2luZ01vdmVkKSByZXR1cm47XG5cbiAgICAvLyBDaGVjayByb29rIG9uIHBvc2l0aW9uXG4gICAgaWYgKCFyb29rIHx8ICFyb29rLnR5cGUgPT09ICdyb29rJykgcmV0dXJuO1xuXG4gICAgLy8gQ2hlY2sgcm9vayBoYXNuJ3QgbW92ZWRcbiAgICBpZiAodHVybi5zb21lKGZ1bmN0aW9uIChldikge1xuICAgICAgaWYgKGV2LnR5cGUgIT09ICdyb29rJykgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIGV2LmZyb20ueCA9PT0gcm9va1ggJiYgZXYuZnJvbS55ID09PSByb29rWTtcbiAgICB9KSkgcmV0dXJuO1xuXG4gICAgdmFyIGNhc3RsaW5nU2lkZSA9IHJvb2tYID09PSAwID8gJ3EnIDogJ2snO1xuICAgIHBvc3NpYmxlQ2FzdGxpbmcgKz0gcm9va1kgPT09IDAgPyBjYXN0bGluZ1NpZGUudG9VcHBlckNhc2UoKSA6IGNhc3RsaW5nU2lkZTtcbiAgfSk7XG5cbiAgaWYgKCFwb3NzaWJsZUNhc3RsaW5nKSBwb3NzaWJsZUNhc3RsaW5nID0gJy0nO1xuICByZXR1cm4gcG9zc2libGVDYXN0bGluZztcbn07XG5cbkdhbWUucHJvdG90eXBlLmVuUGFzc2FudFRhcmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHR1cm4gPSB0aGlzLnR1cm47XG4gIHZhciBlblBhc3NhbnRUYXJnZXQgPSAnJztcblxuICBpZiAodHVybi5sZW5ndGgpIHtcbiAgICB2YXIgZXYgPSB0dXJuW3R1cm4ubGVuZ3RoIC0gMV07XG4gICAgaWYgKGV2LmNvbG9yID09PSAnVycgJiYgZXYudG8ueSA9PT0gNCkge1xuICAgICAgZW5QYXNzYW50VGFyZ2V0ID0gdGhpcy5waWVjZVRvQU4oZXYudG8ueCwgZXYudG8ueSArIDEpO1xuICAgIH1cblxuICAgIGlmIChldi5jb2xvciA9PT0gJ0InICYmIGV2LnRvLnkgPT09IDMpIHtcbiAgICAgIGVuUGFzc2FudFRhcmdldCA9IHRoaXMucGllY2VUb0FOKGV2LnRvLngsIGV2LnRvLnkgLSAxKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWVuUGFzc2FudFRhcmdldCkgZW5QYXNzYW50VGFyZ2V0ID0gJy0nO1xuICByZXR1cm4gZW5QYXNzYW50VGFyZ2V0O1xufTtcblxuR2FtZS5wcm90b3R5cGUuZnVsbG1vdmVDb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNvdW50ID0gMTtcbiAgdGhpcy50dXJuLmZvckVhY2goZnVuY3Rpb24gKGV2KSB7XG4gICAgaWYgKGV2LmNvbG9yID09PSAnQicpIGNvdW50ICs9IDE7XG4gIH0pO1xuXG4gIHJldHVybiBjb3VudDtcbn07XG5cbkdhbWUucHJvdG90eXBlLmdhbWVUb0ZFTiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIEZFTiA9ICcnO1xuXG4gIC8vIENoZWNrIHRoZSBib2FyZCBjb25maWd1cmF0aW9uXG4gIEZFTiArPSB0aGlzLmJvYXJkVG9GRU4oKTtcblxuICAvLyBGaW5kIHRoZSBhY3RpdmUgY29sb3VyXG4gIEZFTiArPSAnICcgKyB0aGlzLmFjdGl2ZUNvbG91cigpO1xuXG4gIC8vIENoZWNrIGNhc3RsaW5nIGF2YWlsYWJpbGl0eVxuICBGRU4gKz0gJyAnICsgdGhpcy5jYXN0bGluZ1RhcmdldCgpO1xuXG4gIC8vIENoZWNrIHRoZSBFbi1wYXNzYW50IHRhcmdldFxuICBGRU4gKz0gJyAnICsgdGhpcy5lblBhc3NhbnRUYXJnZXQoKTtcblxuICAvLyBBZGQgdGhlIGhhbGZtb3ZlIGNsb2NrXG4gIEZFTiArPSAnICcgKyB0aGlzLmhhbGZtb3ZlQ2xvY2soKTtcblxuICAvLyBBZGQgdGhlIGZ1bGxtb3ZlIG51bWJlclxuICBGRU4gKz0gJyAnICsgdGhpcy5mdWxsbW92ZUNvdW50KCk7XG5cbiAgLypcclxuICAgIE1vcmUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIEZFTiBub3RhdGlvbjpcclxuICAgIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ZvcnN5dGglRTIlODAlOTNFZHdhcmRzX05vdGF0aW9uXHJcbiAgICBodHRwczovL2NoZXNzcHJvZ3JhbW1pbmcud2lraXNwYWNlcy5jb20vRm9yc3l0aC1FZHdhcmRzK05vdGF0aW9uXHJcbiAgKi9cblxuICByZXR1cm4gRkVOO1xufTtcblxuLy8gU2V0IHVwIGRlZmF1bHQgZ2FtZSBjb25maWd1cmF0aW9uXG5HYW1lLnByb3RvdHlwZS5pbml0aWFsaXplR2FtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGRlZmF1bHRHYW1lID0gbmV3IEdhbWUoKTtcblxuICAvLyBQYXduczpcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHtcbiAgICBkZWZhdWx0R2FtZS5waWVjZSgncGF3bicsIGksIDYsICdXJyk7XG4gICAgZGVmYXVsdEdhbWUucGllY2UoJ3Bhd24nLCBpLCAxLCAnQicpO1xuICB9XG5cbiAgLy8gQmxhY2sgZmlnczpcbiAgZGVmYXVsdEdhbWUucGllY2UoJ3Jvb2snLCAwLCAwLCAnQicpO1xuICBkZWZhdWx0R2FtZS5waWVjZSgna25pZ2h0JywgMSwgMCwgJ0InKTtcbiAgZGVmYXVsdEdhbWUucGllY2UoJ2Jpc2hvcCcsIDIsIDAsICdCJyk7XG4gIGRlZmF1bHRHYW1lLnBpZWNlKCdxdWVlbicsIDMsIDAsICdCJyk7XG4gIGRlZmF1bHRHYW1lLnBpZWNlKCdraW5nJywgNCwgMCwgJ0InKTtcbiAgZGVmYXVsdEdhbWUucGllY2UoJ2Jpc2hvcCcsIDUsIDAsICdCJyk7XG4gIGRlZmF1bHRHYW1lLnBpZWNlKCdrbmlnaHQnLCA2LCAwLCAnQicpO1xuICBkZWZhdWx0R2FtZS5waWVjZSgncm9vaycsIDcsIDAsICdCJyk7XG5cbiAgLy8gV2hpdGUgZmlnczpcbiAgZGVmYXVsdEdhbWUucGllY2UoJ3Jvb2snLCAwLCA3LCAnVycpO1xuICBkZWZhdWx0R2FtZS5waWVjZSgna25pZ2h0JywgMSwgNywgJ1cnKTtcbiAgZGVmYXVsdEdhbWUucGllY2UoJ2Jpc2hvcCcsIDIsIDcsICdXJyk7XG4gIGRlZmF1bHRHYW1lLnBpZWNlKCdxdWVlbicsIDMsIDcsICdXJyk7XG4gIGRlZmF1bHRHYW1lLnBpZWNlKCdraW5nJywgNCwgNywgJ1cnKTtcbiAgZGVmYXVsdEdhbWUucGllY2UoJ2Jpc2hvcCcsIDUsIDcsICdXJyk7XG4gIGRlZmF1bHRHYW1lLnBpZWNlKCdrbmlnaHQnLCA2LCA3LCAnVycpO1xuICBkZWZhdWx0R2FtZS5waWVjZSgncm9vaycsIDcsIDcsICdXJyk7XG5cbiAgcmV0dXJuIGRlZmF1bHRHYW1lO1xufTtcblxuR2FtZS5wcm90b3R5cGUuYWxsTW92ZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBib2FyZCA9IHRoaXMuYm9hcmQ7XG4gIHZhciBhbGxNb3ZlcyA9IFtdO1xuICB2YXIgYWN0aXZlQ29sb3VyID0gdGhpcy5hY3RpdmVDb2xvdXIoKS50b1VwcGVyQ2FzZSgpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCA4OyBqKyspIHtcbiAgICAgIGlmIChib2FyZFtpXVtqXSAmJiBib2FyZFtpXVtqXS5jb2xvciA9PT0gYWN0aXZlQ29sb3VyKSB7XG4gICAgICAgIHZhciB2YWxpZE1vdmVzID0gYm9hcmRbaV1bal0uZ2V0VmFsaWRNb3Zlcyh0cnVlKTtcbiAgICAgICAgdmFsaWRNb3Zlcy5mb3JFYWNoKGZ1bmN0aW9uIChldikge1xuICAgICAgICAgIGFsbE1vdmVzLnB1c2goe1xuICAgICAgICAgICAgY29sb3I6IGJvYXJkW2ldW2pdLmNvbG9yLFxuICAgICAgICAgICAgZnJvbTogeyB4OiBqLCB5OiBpIH0sXG4gICAgICAgICAgICB0bzogZXYsXG4gICAgICAgICAgICBGRU5uYW1lOiBib2FyZFtpXVtqXS5GRU5uYW1lXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhbGxNb3Zlcztcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEdhbWU7XG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuLy9cbi8vIFJTRyBDaGVzc1xuLy8gTGljZW5zZWQgdW5kZXIgQXBhY2hlIDIuMCBMSUNFTlNFXG5cbnZhciBQSUVDRV9DSEFSUyA9IGV4cG9ydHMuUElFQ0VfQ0hBUlMgPSB7XG4gIHBhd246IHsgVzogJ+KZmScsIEI6ICfimZ8nIH0sXG4gIHJvb2s6IHsgVzogJ+KZlicsIEI6ICfimZwnIH0sXG4gIGtuaWdodDogeyBXOiAn4pmYJywgQjogJ+KZnicgfSxcbiAgYmlzaG9wOiB7IFc6ICfimZcnLCBCOiAn4pmdJyB9LFxuICBxdWVlbjogeyBXOiAn4pmVJywgQjogJ+KZmycgfSxcbiAga2luZzogeyBXOiAn4pmUJywgQjogJ+KZmicgfVxufTtcblxuZnVuY3Rpb24gUGllY2UoeCwgeSwgY2hhckJhc2UsIGNvbG9yLCBnYW1lLCB0eXBlKSB7XG4gIGlmIChjaGFyQmFzZSkgdGhpcy5jaGFyID0gY2hhckJhc2VbY29sb3JdO1xuICB0aGlzLmNvbG9yID0gY29sb3I7XG4gIHRoaXMueCA9IHg7XG4gIHRoaXMueSA9IHk7XG4gIHRoaXMuZ2FtZSA9IGdhbWU7XG4gIHRoaXMudHlwZSA9IHR5cGU7XG4gIGlmICh0eXBlKSB7XG4gICAgdmFyIEZFTm5hbWUgPSB0eXBlID09PSAna25pZ2h0JyA/ICduJyA6IHR5cGUuY2hhckF0KDApO1xuICAgIGlmICh0aGlzLmNvbG9yID09PSAnVycpIEZFTm5hbWUgPSBGRU5uYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgdGhpcy5GRU5uYW1lID0gRkVObmFtZTtcbiAgfVxufVxuXG5QaWVjZS5lbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBQaWVjZSgpO1xufTtcblxuUGllY2UucHJvdG90eXBlLmdldFZhbGlkTW92ZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBbeyB4OiAwLCB5OiAwIH0sIHsgeDogNywgeTogNyB9XTtcbn07XG5cbmZ1bmN0aW9uIFBhd24oeCwgeSwgY29sb3IsIGdhbWUpIHtcbiAgUGllY2UuY2FsbCh0aGlzLCB4LCB5LCBQSUVDRV9DSEFSUy5wYXduLCBjb2xvciwgZ2FtZSwgJ3Bhd24nKTtcbn1cblxuUGF3bi5wcm90b3R5cGUgPSBQaWVjZS5lbXB0eSgpO1xuUGF3bi5wcm90b3R5cGUuZ2V0VmFsaWRNb3ZlcyA9IGZ1bmN0aW9uIChzaW11bGF0ZSkge1xuICB2YXIgZ2FtZSA9IHRoaXMuZ2FtZTtcbiAgdmFyIG1vdmVzID0gW107XG4gIC8qIGVzbGludC1kaXNhYmxlICovXG4gIHZhciB5ID0gdGhpcy55LFxuICAgICAgeCA9IHRoaXMueDtcbiAgdmFyIGJvYXJkID0gZ2FtZS5ib2FyZCxcbiAgICAgIHR1cm4gPSBnYW1lLnR1cm4sXG4gICAgICBsZW5ndGggPSB0dXJuLmxlbmd0aDtcbiAgdmFyIGxhc3QsIHR1cm5UbywgdHVybkZyb20sIGZpZ1gsIHBhc3NhbnRMYXN0LCBwYXNzYW50RmlnO1xuICB2YXIgY29sb3JZID0gdGhpcy5jb2xvciA9PT0gJ1cnID8geSAtIDEgOiB5ICsgMTtcbiAgdmFyIGNvbG9yWTIgPSB0aGlzLmNvbG9yID09PSAnVycgPyB5IC0gMiA6IHkgKyAyO1xuICB2YXIgcGFzc2FudFkyID0gdGhpcy5jb2xvciA9PT0gJ1cnID8gMyA6IDQ7XG4gIHZhciBmaWdYQXJyYXkgPSBbeCAtIDEsIHggKyAxXTtcbiAgLyogZXNsaW50LWVuYWJsZSAqL1xuXG4gIGlmIChjb2xvclkgPCA4ICYmIGNvbG9yWSA+PSAwICYmICFib2FyZFtjb2xvclldW3hdKSB7XG4gICAgbW92ZXMucHVzaCh7IHg6IHgsIHk6IGNvbG9yWSB9KTtcbiAgICBpZiAoKHkgPT09IDEgfHwgeSA9PT0gNikgJiYgY29sb3JZMiA8IDggJiYgY29sb3JZMiA+PSAwICYmICFnYW1lLmJvYXJkW2NvbG9yWTJdW3hdKSB7XG4gICAgICBtb3Zlcy5wdXNoKHsgeDogeCwgeTogY29sb3JZMiB9KTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDI7IGkrKykge1xuICAgIGZpZ1ggPSBmaWdYQXJyYXlbaV07XG4gICAgaWYgKGNvbG9yWSA8IDggJiYgY29sb3JZID49IDAgJiYgYm9hcmRbY29sb3JZXVtmaWdYXSAmJiBib2FyZFtjb2xvclldW2ZpZ1hdLmNvbG9yICE9PSB0aGlzLmNvbG9yKSBtb3Zlcy5wdXNoKHsgeDogZmlnWCwgeTogY29sb3JZIH0pO1xuICB9XG5cbiAgLy8gQ2hlY2sgZm9yIGVuLXBhc3NhbnRcbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IDI7IF9pKyspIHtcbiAgICBmaWdYID0gZmlnWEFycmF5W19pXTtcbiAgICBsYXN0ID0gdHVybltsZW5ndGggLSAxXTtcblxuICAgIGlmIChsYXN0ICYmIGxhc3QudHlwZSA9PT0gJ3Bhd24nICYmIGxhc3QudG8ueCA9PT0gZmlnWCAmJiBsYXN0LnRvLnkgPT09IHkgJiYgbGFzdC5jb2xvciAhPT0gdGhpcy5jb2xvciAmJiAobGFzdC5mcm9tLnkgPT09IDEgfHwgbGFzdC5mcm9tLnkgPT09IDYpICYmICh5ID09PSAzIHx8IHkgPT09IDQpKSB7XG4gICAgICBtb3Zlcy5wdXNoKHtcbiAgICAgICAgeDogZmlnWCxcbiAgICAgICAgeTogY29sb3JZLFxuICAgICAgICBtb3ZlUGllY2U6IHtcbiAgICAgICAgICBwaWVjZTogZ2FtZS5ib2FyZFt5XVtmaWdYXSxcbiAgICAgICAgICBmcm9tOiB7XG4gICAgICAgICAgICB4OiBmaWdYLFxuICAgICAgICAgICAgeTogeVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdG86IG51bGxcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHZhbGlkTW92ZXMgPSBbXTtcbiAgaWYgKHNpbXVsYXRlKSB7XG4gICAgdmFsaWRNb3ZlcyA9IGdhbWUuc2ltdWxhdGVBbmRGaWx0ZXIobW92ZXMsIHRoaXMpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkTW92ZXMgPSBtb3ZlcztcbiAgfVxuXG4gIHJldHVybiB2YWxpZE1vdmVzO1xufTtcblxuUGllY2UucGF3biA9IGZ1bmN0aW9uICh4LCB5LCBjb2xvciwgZ2FtZSkge1xuICByZXR1cm4gbmV3IFBhd24oeCwgeSwgY29sb3IsIGdhbWUpO1xufTtcblxuLy8gLy9cblxuZnVuY3Rpb24gUm9vayh4LCB5LCBjb2xvciwgZ2FtZSkge1xuICBQaWVjZS5jYWxsKHRoaXMsIHgsIHksIFBJRUNFX0NIQVJTLnJvb2ssIGNvbG9yLCBnYW1lLCAncm9vaycpO1xufVxuXG5Sb29rLnByb3RvdHlwZSA9IFBpZWNlLmVtcHR5KCk7XG5Sb29rLnByb3RvdHlwZS5nZXRWYWxpZE1vdmVzID0gZnVuY3Rpb24gKHNpbXVsYXRlKSB7XG4gIHZhciBnYW1lID0gdGhpcy5nYW1lO1xuICB2YXIgbW92ZXMgPSBbXTtcblxuICBbWy0xLCAwXSwgWzEsIDBdLCBbMCwgMV0sIFswLCAtMV1dLmZvckVhY2goZnVuY3Rpb24gKGNvZWYpIHtcbiAgICB2YXIgaW5kZXgsIHgsIHksIHBpZWNlO1xuICAgIGZvciAoaW5kZXggPSAxOzsgaW5kZXgrKykge1xuICAgICAgeCA9IHRoaXMueCArIGNvZWZbMF0gKiBpbmRleDtcbiAgICAgIHkgPSB0aGlzLnkgKyBjb2VmWzFdICogaW5kZXg7XG4gICAgICBpZiAoeSA8IDAgfHwgeSA+IDcgfHwgeCA8IDAgfHwgeCA+IDcpIGJyZWFrO1xuXG4gICAgICBwaWVjZSA9IGdhbWUuYm9hcmRbeV1beF07XG4gICAgICBpZiAocGllY2UgJiYgcGllY2UuY29sb3IgPT09IHRoaXMuY29sb3IpIGJyZWFrO1xuXG4gICAgICBtb3Zlcy5wdXNoKHsgeDogeCwgeTogeSB9KTtcbiAgICAgIGlmIChwaWVjZSkgYnJlYWs7XG4gICAgfVxuICB9LCB0aGlzKTtcblxuICB2YXIgdmFsaWRNb3ZlcyA9IFtdO1xuICBpZiAoc2ltdWxhdGUpIHtcbiAgICB2YWxpZE1vdmVzID0gZ2FtZS5zaW11bGF0ZUFuZEZpbHRlcihtb3ZlcywgdGhpcyk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWRNb3ZlcyA9IG1vdmVzO1xuICB9XG5cbiAgcmV0dXJuIHZhbGlkTW92ZXM7XG59O1xuXG5QaWVjZS5yb29rID0gZnVuY3Rpb24gKHgsIHksIGNvbG9yLCBnYW1lKSB7XG4gIHJldHVybiBuZXcgUm9vayh4LCB5LCBjb2xvciwgZ2FtZSk7XG59O1xuXG4vLyAvL1xuXG5mdW5jdGlvbiBLbmlnaHQoeCwgeSwgY29sb3IsIGdhbWUpIHtcbiAgUGllY2UuY2FsbCh0aGlzLCB4LCB5LCBQSUVDRV9DSEFSUy5rbmlnaHQsIGNvbG9yLCBnYW1lLCAna25pZ2h0Jyk7XG59XG5cbktuaWdodC5wcm90b3R5cGUgPSBQaWVjZS5lbXB0eSgpO1xuS25pZ2h0LnByb3RvdHlwZS5nZXRWYWxpZE1vdmVzID0gZnVuY3Rpb24gKHNpbXVsYXRlKSB7XG4gIHZhciBnYW1lID0gdGhpcy5nYW1lO1xuICB2YXIgbW92ZXMgPSBbXTtcblxuICB2YXIgY29vcmRpbmF0ZXMgPSBbWzIsIDFdLCBbLTIsIDFdLCBbMSwgMl0sIFstMSwgMl0sIFsyLCAtMV0sIFstMiwgLTFdLCBbMSwgLTJdLCBbLTEsIC0yXV07XG5cbiAgdmFyIG9uZSwgdHdvO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGhlbHAgPSBmYWxzZTtcbiAgICB2YXIgYm9hcmRQaWVjZTtcbiAgICBvbmUgPSBjb29yZGluYXRlc1tpXVswXTtcbiAgICB0d28gPSBjb29yZGluYXRlc1tpXVsxXTtcblxuICAgIGlmICh0aGlzLnggKyBvbmUgPCA4ICYmIHRoaXMueCArIG9uZSA+PSAwICYmIHRoaXMueSArIHR3byA8IDggJiYgdGhpcy55ICsgdHdvID49IDApIHtcbiAgICAgIGJvYXJkUGllY2UgPSBnYW1lLmJvYXJkW3RoaXMueSArIHR3b11bdGhpcy54ICsgb25lXTtcbiAgICAgIGhlbHAgPSBib2FyZFBpZWNlID8gYm9hcmRQaWVjZS5jb2xvciAhPT0gdGhpcy5jb2xvciA6IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGhlbHApIHtcbiAgICAgIG1vdmVzLnB1c2goeyB4OiB0aGlzLnggKyBvbmUsIHk6IHRoaXMueSArIHR3byB9KTtcbiAgICB9XG4gIH1cblxuICB2YXIgdmFsaWRNb3ZlcyA9IFtdO1xuICBpZiAoc2ltdWxhdGUpIHtcbiAgICB2YWxpZE1vdmVzID0gZ2FtZS5zaW11bGF0ZUFuZEZpbHRlcihtb3ZlcywgdGhpcyk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWRNb3ZlcyA9IG1vdmVzO1xuICB9XG5cbiAgcmV0dXJuIHZhbGlkTW92ZXM7XG59O1xuXG5QaWVjZS5rbmlnaHQgPSBmdW5jdGlvbiAoeCwgeSwgY29sb3IsIGdhbWUpIHtcbiAgcmV0dXJuIG5ldyBLbmlnaHQoeCwgeSwgY29sb3IsIGdhbWUpO1xufTtcblxuLy8gLy9cblxuZnVuY3Rpb24gQmlzaG9wKHgsIHksIGNvbG9yLCBnYW1lKSB7XG4gIFBpZWNlLmNhbGwodGhpcywgeCwgeSwgUElFQ0VfQ0hBUlMuYmlzaG9wLCBjb2xvciwgZ2FtZSwgJ2Jpc2hvcCcpO1xufVxuXG5CaXNob3AucHJvdG90eXBlID0gUGllY2UuZW1wdHkoKTtcbkJpc2hvcC5wcm90b3R5cGUuZ2V0VmFsaWRNb3ZlcyA9IGZ1bmN0aW9uIChzaW11bGF0ZSkge1xuICB2YXIgZ2FtZSA9IHRoaXMuZ2FtZTtcbiAgdmFyIG1vdmVzID0gW107XG5cbiAgW1stMSwgLTFdLCBbMSwgMV0sIFstMSwgMV0sIFsxLCAtMV1dLmZvckVhY2goZnVuY3Rpb24gKGNvZWYpIHtcbiAgICB2YXIgaW5kZXgsIHgsIHksIHBpZWNlO1xuICAgIGZvciAoaW5kZXggPSAxOzsgaW5kZXgrKykge1xuICAgICAgeCA9IHRoaXMueCArIGNvZWZbMF0gKiBpbmRleDtcbiAgICAgIHkgPSB0aGlzLnkgKyBjb2VmWzFdICogaW5kZXg7XG4gICAgICBpZiAoeSA8IDAgfHwgeSA+IDcgfHwgeCA8IDAgfHwgeCA+IDcpIGJyZWFrO1xuXG4gICAgICBwaWVjZSA9IGdhbWUuYm9hcmRbeV1beF07XG4gICAgICBpZiAocGllY2UgJiYgcGllY2UuY29sb3IgPT09IHRoaXMuY29sb3IpIGJyZWFrO1xuXG4gICAgICBtb3Zlcy5wdXNoKHsgeDogeCwgeTogeSB9KTtcbiAgICAgIGlmIChwaWVjZSkgYnJlYWs7XG4gICAgfVxuICB9LCB0aGlzKTtcblxuICB2YXIgdmFsaWRNb3ZlcyA9IFtdO1xuICBpZiAoc2ltdWxhdGUpIHtcbiAgICB2YWxpZE1vdmVzID0gZ2FtZS5zaW11bGF0ZUFuZEZpbHRlcihtb3ZlcywgdGhpcyk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWRNb3ZlcyA9IG1vdmVzO1xuICB9XG5cbiAgcmV0dXJuIHZhbGlkTW92ZXM7XG59O1xuXG5QaWVjZS5iaXNob3AgPSBmdW5jdGlvbiAoeCwgeSwgY29sb3IsIGdhbWUpIHtcbiAgcmV0dXJuIG5ldyBCaXNob3AoeCwgeSwgY29sb3IsIGdhbWUpO1xufTtcblxuLy8gLy9cblxuZnVuY3Rpb24gUXVlZW4oeCwgeSwgY29sb3IsIGdhbWUpIHtcbiAgUGllY2UuY2FsbCh0aGlzLCB4LCB5LCBQSUVDRV9DSEFSUy5xdWVlbiwgY29sb3IsIGdhbWUsICdxdWVlbicpO1xufVxuXG5RdWVlbi5wcm90b3R5cGUgPSBQaWVjZS5lbXB0eSgpO1xuUXVlZW4ucHJvdG90eXBlLmdldFZhbGlkTW92ZXMgPSBmdW5jdGlvbiAoc2ltdWxhdGUpIHtcbiAgdmFyIGdhbWUgPSB0aGlzLmdhbWU7XG4gIHZhciByb29rTW92ZXMgPSBSb29rLnByb3RvdHlwZS5nZXRWYWxpZE1vdmVzLmNhbGwodGhpcyk7XG4gIHZhciBiaXNob3BNb3ZlcyA9IEJpc2hvcC5wcm90b3R5cGUuZ2V0VmFsaWRNb3Zlcy5jYWxsKHRoaXMpO1xuICB2YXIgbW92ZXMgPSByb29rTW92ZXMuY29uY2F0KGJpc2hvcE1vdmVzKTtcblxuICB2YXIgdmFsaWRNb3ZlcyA9IFtdO1xuICBpZiAoc2ltdWxhdGUpIHtcbiAgICB2YWxpZE1vdmVzID0gZ2FtZS5zaW11bGF0ZUFuZEZpbHRlcihtb3ZlcywgdGhpcyk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWRNb3ZlcyA9IG1vdmVzO1xuICB9XG5cbiAgcmV0dXJuIHZhbGlkTW92ZXM7XG59O1xuXG5QaWVjZS5xdWVlbiA9IGZ1bmN0aW9uICh4LCB5LCBjb2xvciwgZ2FtZSkge1xuICByZXR1cm4gbmV3IFF1ZWVuKHgsIHksIGNvbG9yLCBnYW1lKTtcbn07XG5cbi8vIC8vXG5cbmZ1bmN0aW9uIEtpbmcoeCwgeSwgY29sb3IsIGdhbWUpIHtcbiAgUGllY2UuY2FsbCh0aGlzLCB4LCB5LCBQSUVDRV9DSEFSUy5raW5nLCBjb2xvciwgZ2FtZSwgJ2tpbmcnKTtcbn1cblxuS2luZy5wcm90b3R5cGUgPSBQaWVjZS5lbXB0eSgpO1xuS2luZy5wcm90b3R5cGUuZ2V0VmFsaWRNb3ZlcyA9IGZ1bmN0aW9uIChzaW11bGF0ZSkge1xuICB2YXIgbW92ZXMgPSBbXTtcbiAgdmFyIGNvb3JkaW5hdGVzID0gW1swLCAxXSwgWzAsIC0xXSwgWzEsIDFdLCBbLTEsIC0xXSwgWzEsIC0xXSwgWy0xLCAxXSwgWy0xLCAwXSwgWzEsIDBdXTtcbiAgdmFyIHggPSB0aGlzLng7XG4gIHZhciB5ID0gdGhpcy55O1xuICB2YXIgZ2FtZSA9IHRoaXMuZ2FtZTtcbiAgdmFyIHR1cm4gPSBnYW1lLnR1cm47XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBjb29yZGluYXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChjb29yZCkge1xuICAgIHZhciBwaWVjZTtcbiAgICB2YXIgeHggPSB4ICsgY29vcmRbMF07XG4gICAgdmFyIHl5ID0geSArIGNvb3JkWzFdO1xuXG4gICAgaWYgKHh4IDwgOCAmJiB4eCA+PSAwICYmIHl5IDwgOCAmJiB5eSA+PSAwKSB7XG4gICAgICBwaWVjZSA9IGdhbWUuYm9hcmRbeXldW3h4XTtcbiAgICAgIGlmICghcGllY2UgfHwgcGllY2UuY29sb3IgIT09IHNlbGYuY29sb3IpIHtcbiAgICAgICAgbW92ZXMucHVzaCh7IHg6IHh4LCB5OiB5eSB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIC8vIENoZWNrIGtpbmcgaGFzbid0IG1vdmVkXG4gIHZhciBraW5nTW92ZWQgPSB0dXJuLnNvbWUoZnVuY3Rpb24gKHR1cm4pIHtcbiAgICByZXR1cm4gdHVybi50eXBlID09PSAna2luZycgJiYgdHVybi5jb2xvciA9PT0gc2VsZi5jb2xvcjtcbiAgfSk7XG5cbiAgaWYgKCFraW5nTW92ZWQpIHtcbiAgICBbWzAsIDIsIC0xXSwgWzcsIDYsICsxXV0uZm9yRWFjaChmdW5jdGlvbiAocHJvcHMpIHtcbiAgICAgIHZhciByb29rWCA9IHByb3BzWzBdO1xuICAgICAgdmFyIG5ld0tpbmdYID0gcHJvcHNbMV07XG4gICAgICB2YXIgZGlyID0gcHJvcHNbMl07XG4gICAgICB2YXIgcm9vayA9IGdhbWUuYm9hcmRbeV1bcm9va1hdO1xuXG4gICAgICAvLyBDaGVjayByb29rIG9uIHBvc2l0aW9uXG4gICAgICBpZiAoIXJvb2sgfHwgIXJvb2sudHlwZSA9PT0gJ3Jvb2snKSByZXR1cm47XG5cbiAgICAgIC8vIENoZWNrIHJvb2sgaGFzbid0IG1vdmVkXG4gICAgICBpZiAodHVybi5zb21lKGZ1bmN0aW9uIChldikge1xuICAgICAgICByZXR1cm4gZXYuZnJvbS54ID09PSByb29rWCAmJiBldi5mcm9tLnkgPT09IHk7XG4gICAgICB9KSkgcmV0dXJuO1xuXG4gICAgICAvLyBDaGVjayBzcXVhcmVzIGVtcHR5IGFuZCBzYWZlXG4gICAgICBmb3IgKHZhciB4eCA9IHggKyBkaXI7IHh4ICE9PSByb29rWDsgeHggKz0gZGlyKSB7XG4gICAgICAgIGlmIChnYW1lLmJvYXJkW3ldW3h4XSkgcmV0dXJuO1xuICAgICAgICB2YXIgc2FmZSA9IHRydWU7XG4gICAgICAgIGdhbWUuYm9hcmQuZm9yRWFjaChmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICBldi5mb3JFYWNoKGZ1bmN0aW9uIChldnYpIHtcbiAgICAgICAgICAgIGlmIChldnYgJiYgZXZ2LnR5cGUgIT09ICdraW5nJyAmJiBldnYuY29sb3IgIT09IHNlbGYuY29sb3IpIHtcbiAgICAgICAgICAgICAgZXZ2LmdldFZhbGlkTW92ZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChldk1vdmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZNb3ZlICYmIGV2TW92ZS55ID09PSB5ICYmIGV2TW92ZS54ID09PSB4eCkgc2FmZSA9IGZhbHNlO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghc2FmZSkgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcm9jaGFkZSA9IHtcbiAgICAgICAgeDogbmV3S2luZ1gsXG4gICAgICAgIHk6IHksXG4gICAgICAgIG1vdmVQaWVjZToge1xuICAgICAgICAgIHBpZWNlOiBzZWxmLmdhbWUuYm9hcmRbeV1bcm9va1hdLFxuICAgICAgICAgIGZyb206IHtcbiAgICAgICAgICAgIHg6IHJvb2tYLCB5OiB5XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0bzoge1xuICAgICAgICAgICAgeTogeSwgeDogeCArIGRpclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgbW92ZXMucHVzaChyb2NoYWRlKTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciB2YWxpZE1vdmVzID0gW107XG4gIGlmIChzaW11bGF0ZSkge1xuICAgIHZhbGlkTW92ZXMgPSBnYW1lLnNpbXVsYXRlQW5kRmlsdGVyKG1vdmVzLCBzZWxmKTtcbiAgfSBlbHNlIHtcbiAgICB2YWxpZE1vdmVzID0gbW92ZXM7XG4gIH1cblxuICByZXR1cm4gdmFsaWRNb3Zlcztcbn07XG5cblBpZWNlLmtpbmcgPSBmdW5jdGlvbiAoeCwgeSwgY29sb3IsIGdhbWUpIHtcbiAgcmV0dXJuIG5ldyBLaW5nKHgsIHksIGNvbG9yLCBnYW1lKTtcbn07XG5cbmV4cG9ydHMuUGllY2UgPSBQaWVjZTtcbmV4cG9ydHMuUGF3biA9IFBhd247XG5leHBvcnRzLlJvb2sgPSBSb29rO1xuZXhwb3J0cy5LbmlnaHQgPSBLbmlnaHQ7XG5leHBvcnRzLkJpc2hvcCA9IEJpc2hvcDtcbmV4cG9ydHMuUXVlZW4gPSBRdWVlbjtcbmV4cG9ydHMuS2luZyA9IEtpbmc7XG5cbi8qKiovIH0pLFxuLyogMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5BSSA9IGV4cG9ydHMuUGllY2VzID0gZXhwb3J0cy5HYW1lID0gdW5kZWZpbmVkO1xuXG52YXIgX2dhbWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX2dhbWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2FtZSk7XG5cbnZhciBfcGllY2VzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIFBpZWNlcyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9waWVjZXMpO1xuXG52YXIgX0FJID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIF9BSTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9BSSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8vIEFuZCBleHBvcnQuLi5cbmV4cG9ydHMuR2FtZSA9IF9nYW1lMi5kZWZhdWx0O1xuZXhwb3J0cy5QaWVjZXMgPSBQaWVjZXM7XG5leHBvcnRzLkFJID0gX0FJMi5kZWZhdWx0OyAvLyBMZXQncyBpbXBvcnQuLi5cblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZ2FtZSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfZ2FtZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nYW1lKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIENoZXNzQUkgPSBmdW5jdGlvbiBDaGVzc0FJKGRlcHRoLCBnYW1lU3RhdGUsIGlzTWF4aW1pc2luZ1BsYXllcikge1xuICAvLyBDbG9uZSB0aGUgZ2FtZVN0YXRlIHRvIGFjY2VzcyBhbGwgZ2FtZSBhc3NvY2lhdGVkIG1ldGhvZHMuXG4gIC8vIFRoaXMgdXN1YWxseSBkb2Vzbid0IG1ha2Ugc2Vuc2UsIGJ1dCBzb21ldGltZXMgeW91IGNhbm5vdCBwb3N0IGZ1bmN0aW9ucyB0byBhIGJhY2tlbmQgb3IgYSB3ZWItd29ya2VyXG4gIC8vIGFuZCB0aGF0J3Mgd2h5IHdlJ3JlIHRvdWNoaW5nIHRoZSBnYW1lIG1ldGhvZHMgZnJvbSBuZXcgZ2FtZSBjb25maWd1cmF0aW9uIGludGVhZCBmcm9tIHRoZSBwYXNzZWQgYXJndW1lbnQuXG4gIC8vIFNvIGlmIHlvdSBwYXNzIHtib2FyZDogW215Qm9hcmRdLCB0dXJuOltteVR1cm5dLC4uLn0gZm9yIHRoZSBnYW1lIGFyZ3VtZW50IGl0IHdpbGwgYWN0dWFsbHkgd29yayFcbiAgLy8gQWxyZWFkeSBkZXNjcmliZWQgaGVyZTogaHR0cHM6Ly9naXRodWIuY29tL1JTRy1Hcm91cC9DaGVzcy9pc3N1ZXMvOCNpc3N1ZWNvbW1lbnQtMzgxMjQ1Nzk0XG4gIHZhciBnYW1lID0gX2dhbWUyLmRlZmF1bHQucHJvdG90eXBlLmluaXRpYWxpemVHYW1lKCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykge1xuICAgICAgaWYgKGdhbWVTdGF0ZS5ib2FyZFtpXVtqXSkge1xuICAgICAgICB2YXIgY3VycmVudENlbGwgPSBnYW1lU3RhdGUuYm9hcmRbaV1bal07XG4gICAgICAgIGdhbWUucGllY2UoY3VycmVudENlbGwudHlwZSwgaiwgaSwgY3VycmVudENlbGwuY29sb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2FtZS5ib2FyZFtpXVtqXSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZ2FtZS50dXJuID0gZ2FtZVN0YXRlLnR1cm47XG4gIGdhbWUudGhyZWVmb2xkID0gZ2FtZVN0YXRlLnRocmVlZm9sZDtcbiAgZ2FtZS5GRU4gPSBnYW1lU3RhdGUuRkVOO1xuICBnYW1lLkZFTmJvYXJkID0gZ2FtZVN0YXRlLkZFTmJvYXJkO1xuXG4gIC8vIFN0YXJ0IGxvb3BpbmcgYW5kIHNpbXVsYXRpbmcgYWxsIHZhbGlkIG1vdmVzXG4gIHZhciBhbGxNb3ZlcyA9IGdhbWUuYWxsTW92ZXMoKTtcbiAgdmFyIGJlc3RWYWx1ZSA9IC05OTk5O1xuICB2YXIgYmVzdE1vdmU7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxNb3Zlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBuZXdHYW1lTW92ZSA9IGFsbE1vdmVzW2ldO1xuICAgIHZhciB1bmRvID0gZ2FtZS5zaW1wbGVNb3ZlKG5ld0dhbWVNb3ZlKTtcbiAgICB2YXIgYm9yYWRWYWx1ZSA9IG1pbmltYXgoZGVwdGggLSAxLCBnYW1lLCAtMTAwMDAsIDEwMDAwLCAhaXNNYXhpbWlzaW5nUGxheWVyKTtcbiAgICB1bmRvKCk7XG4gICAgaWYgKGJvcmFkVmFsdWUgPj0gYmVzdFZhbHVlKSB7XG4gICAgICBiZXN0VmFsdWUgPSBib3JhZFZhbHVlO1xuICAgICAgYmVzdE1vdmUgPSBuZXdHYW1lTW92ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJlc3RNb3ZlO1xufTsgLy9cbi8vIFJTRyBDaGVzc1xuLy8gTGljZW5zZWQgdW5kZXIgQXBhY2hlIDIuMCBMSUNFTlNFXG5cbnZhciBtaW5pbWF4ID0gZnVuY3Rpb24gbWluaW1heChkZXB0aCwgZ2FtZSwgYWxwaGEsIGJldGEsIGlzTWF4aW1pc2luZ1BsYXllcikge1xuICBpZiAoZGVwdGggPT09IDApIHtcbiAgICByZXR1cm4gLWV2YWx1YXRlQm9hcmQoZ2FtZS5ib2FyZCk7XG4gIH1cblxuICB2YXIgYWxsTW92ZXMgPSBnYW1lLmFsbE1vdmVzKCk7XG4gIGlmIChpc01heGltaXNpbmdQbGF5ZXIpIHtcbiAgICB2YXIgYmVzdFZhbHVlID0gLTk5OTk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxNb3Zlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHVuZG8gPSBnYW1lLnNpbXBsZU1vdmUoYWxsTW92ZXNbaV0pO1xuICAgICAgYmVzdFZhbHVlID0gTWF0aC5tYXgoYmVzdFZhbHVlLCBtaW5pbWF4KGRlcHRoIC0gMSwgZ2FtZSwgYWxwaGEsIGJldGEsICFpc01heGltaXNpbmdQbGF5ZXIpKTtcbiAgICAgIHVuZG8oKTtcbiAgICAgIGFscGhhID0gTWF0aC5tYXgoYWxwaGEsIGJlc3RWYWx1ZSk7XG4gICAgICBpZiAoYmV0YSA8PSBhbHBoYSkge1xuICAgICAgICByZXR1cm4gYmVzdFZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYmVzdFZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHZhciBfYmVzdFZhbHVlID0gOTk5OTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYWxsTW92ZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX3VuZG8gPSBnYW1lLnNpbXBsZU1vdmUoYWxsTW92ZXNbX2ldKTtcbiAgICAgIF9iZXN0VmFsdWUgPSBNYXRoLm1pbihfYmVzdFZhbHVlLCBtaW5pbWF4KGRlcHRoIC0gMSwgZ2FtZSwgYWxwaGEsIGJldGEsICFpc01heGltaXNpbmdQbGF5ZXIpKTtcbiAgICAgIF91bmRvKCk7XG4gICAgICBiZXRhID0gTWF0aC5taW4oYmV0YSwgX2Jlc3RWYWx1ZSk7XG4gICAgICBpZiAoYmV0YSA8PSBhbHBoYSkge1xuICAgICAgICByZXR1cm4gX2Jlc3RWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIF9iZXN0VmFsdWU7XG4gIH1cbn07XG5cbnZhciBldmFsdWF0ZUJvYXJkID0gZnVuY3Rpb24gZXZhbHVhdGVCb2FyZChib2FyZCkge1xuICB2YXIgdG90YWxFdmFsdWF0aW9uID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykge1xuICAgICAgLy8gY2FsY3VsYXRlIHRoZSBjdXJyZW50IGV2YWx1YXRpb25cbiAgICAgIHRvdGFsRXZhbHVhdGlvbiA9IHRvdGFsRXZhbHVhdGlvbiArIGdldFBpZWNlVmFsdWUoYm9hcmRbaV1bal0pO1xuICAgIH1cbiAgfVxuICAvLyByZXR1cm4gdGhlIHRvdGFsIGV2YWx1YXRpb25cbiAgcmV0dXJuIHRvdGFsRXZhbHVhdGlvbjtcbn07XG5cbnZhciBnZXRQaWVjZVZhbHVlID0gZnVuY3Rpb24gZ2V0UGllY2VWYWx1ZShwaWVjZSkge1xuICBpZiAocGllY2UgPT09IG51bGwpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIC8vIGdldCB2YWx1ZSBmb3IgZXZlcnkgcGllY2Ugb24gdGhlIGJvYXJkXG4gIHZhciBnZXRBYnNvbHV0ZVZhbHVlID0gZnVuY3Rpb24gZ2V0QWJzb2x1dGVWYWx1ZShwaWVjZSkge1xuICAgIGlmIChwaWVjZS50eXBlID09PSAncGF3bicpIHtcbiAgICAgIHJldHVybiAxMDtcbiAgICB9IGVsc2UgaWYgKHBpZWNlLnR5cGUgPT09ICdyb29rJykge1xuICAgICAgcmV0dXJuIDUwO1xuICAgIH0gZWxzZSBpZiAocGllY2UudHlwZSA9PT0gJ2tuaWdodCcpIHtcbiAgICAgIHJldHVybiAzMDtcbiAgICB9IGVsc2UgaWYgKHBpZWNlLnR5cGUgPT09ICdiaXNob3AnKSB7XG4gICAgICByZXR1cm4gMzA7XG4gICAgfSBlbHNlIGlmIChwaWVjZS50eXBlID09PSAncXVlZW4nKSB7XG4gICAgICByZXR1cm4gOTA7XG4gICAgfSBlbHNlIGlmIChwaWVjZS50eXBlID09PSAna2luZycpIHtcbiAgICAgIHJldHVybiA5MDA7XG4gICAgfVxuICB9O1xuXG4gIC8vIGNhbGN1bGF0ZSB0aGUgYWJzb2x1dGUgdmFsdWUgYW5kIHJldHVybiBpdFxuICB2YXIgYWJzb2x1dGVWYWx1ZSA9IGdldEFic29sdXRlVmFsdWUocGllY2UsIHBpZWNlLmNvbG9yID09PSAnVycpO1xuICByZXR1cm4gcGllY2UuY29sb3IgPT09ICdXJyA/IGFic29sdXRlVmFsdWUgOiAtYWJzb2x1dGVWYWx1ZTtcbn07XG5cbi8vIGV4cG9ydCB0aGUgYWxnb3JpdGhtXG5leHBvcnRzLmRlZmF1bHQgPSBDaGVzc0FJO1xuXG4vLyBXcml0dGVuIGJ5IFJhZGkgQ2hvXG4vLyBSU0cgQ2hlc3MgLSBieSBSU0cgR3JvdXBcblxuLyoqKi8gfSlcbi8qKioqKiovIF0pO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9yc2ctY2hlc3MvbGliL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=