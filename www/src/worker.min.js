/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _rsgChess = __webpack_require__(1);

self.addEventListener('message', function (e) {
  if (e.data && e.data.game && e.data.playAgainstAI) {
    var bestMove = (0, _rsgChess.AI)(e.data.playAgainstAI.depth, e.data.game, true);
    self.postMessage(bestMove);
  }
}); // self.importScripts("game.js");

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("rsg-chess", [], factory);
	else if(typeof exports === 'object')
		exports["rsg-chess"] = factory();
	else
		root["rsg-chess"] = factory();
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 3);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _pieces = __webpack_require__(1);

var _AI = __webpack_require__(2);

var _AI2 = _interopRequireDefault(_AI);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function Game(promoCallback) {
  // the game board
  this.board = [];
  // fill the board
  for (var i = 0; i < 8; i++) {
    var arrayIn = [];
    for (var j = 0; j < 8; j++) {
      arrayIn.push(null);
    }
    this.board.push(arrayIn);
  }

  // the history of all turns
  this.turn = [];
  // the current FEN status
  this.FEN = [];
  // the current game configuration as FEN
  this.FENboard = [];
  // the history of all game configurations displayed using FEN
  this.threefold = [];
}

Game.prototype.piece = function (type, x, y, color) {
  var piece = _pieces.Piece[type](x, y, color, this);
  this.board[y][x] = piece;

  this.FEN = this.gameToFEN();
  this.FENboard = this.boardToFEN();
};

Game.prototype.moveSelected = function (selected, to, promotionCallback, checkmateCallback, playAgainstAI, simulate) {
  var x = to.x;
  var y = to.y;

  if (selected) {
    var from = { x: selected.x, y: selected.y };

    if (this.board[y][x] !== selected) {
      var validMoves = selected.getValidMoves(!simulate);
      var validMove = null;

      for (var i = 0; i < validMoves.length; i++) {
        var vm = validMoves[i];
        if (vm.x === x && vm.y === y) {
          validMove = vm;
          break;
        }
      }

      if (!validMove) return false;
      var movePiece = validMove.movePiece;
      var take, paste, rook;
      if (movePiece) {
        take = movePiece.from;
        paste = movePiece.to;
        if (paste === null) {
          this.board[take.y][take.x] = null;
        } else {
          rook = this.board[take.y][take.x];
          this.board[paste.y][paste.x] = rook;
          rook.x = paste.x;
          rook.y = paste.y;
          this.board[take.y][take.x] = null;
        }
      }

      var piece = this.board[y][x] ? this.board[y][x] : null;
      movePiece = movePiece ? validMove.movePiece : null;
      this.turn.push({
        from: from,
        to: to,
        color: selected.color,
        type: selected.type,
        piece: piece,
        movePiece: movePiece
      });

      this.board[y][x] = selected;
      this.board[selected.y][selected.x] = null;
      this.board[y][x].x = x;
      this.board[y][x].y = y;

      this.FEN = this.gameToFEN();
      this.FENboard = this.boardToFEN();
      // check for threefold repetition

      this.threefold.push(this.FENboard);
      if (selected.type === 'pawn' || piece) this.threefold = [];
      if (this.threefoldCheck()) checkmateCallback('D');

      // check for the fifty-move rule
      if (this.halfmoveClock() >= 50) checkmateCallback('D');

      // check for pawn promotion
      if (selected.type === 'pawn') {
        if (selected.color === 'W' && y === 0 || selected.color === 'B' && y === 7) {
          if (promotionCallback) {
            if (playAgainstAI && !playAgainstAI.mode && playAgainstAI.comingAI && selected.color === 'B') {
              playAgainstAI.customAIPromotion ? playAgainstAI.customAIPromotion() : this.promotePawn(selected, x, y, selected.color, 'queen');
            } else {
              promotionCallback(selected, x, y, selected.color);
            }
          }
        }
      };

      var checkmateColor = selected.color === 'W' ? 'B' : 'W';
      var checkmateValue = this.checkmate(checkmateColor);
      if (checkmateValue) checkmateCallback(checkmateValue);

      // Play AI
      if (playAgainstAI && playAgainstAI.mode && playAgainstAI.move) {
        if (playAgainstAI.customAIMovement) {
          playAgainstAI.customAIMovement();
        } else {
          var bestMove = (0, _AI2.default)(playAgainstAI.depth, this, false);
          this.moveSelected(this.board[bestMove.from.y][bestMove.from.x], bestMove.to, promotionCallback, checkmateCallback, false, true, simulate);
        }
      }
      // end
    }
    selected = null;
    return true;
  }
};

Game.prototype.promotePawn = function (pawn, x, y, color, type) {
  this.piece(type, x, y, color);
};

Game.prototype.simulateAndFilter = function (moves, piece) {
  var validMoves = [];
  var self = this;
  var board = this.board;

  moves.forEach(function (move, i) {
    var y = move.y;
    var x = move.x;
    var from = { x: piece.x, y: piece.y };
    var movePiece = board[y][x] ? {
      piece: board[y][x],
      from: { x: x, y: y },
      to: null
    } : null;

    if (move.movePiece) movePiece = move.movePiece;
    if (movePiece) self.simpleMovePiece(movePiece.piece, movePiece.from, movePiece.to);

    self.simpleMovePiece(piece, from, { x: x, y: y });
    var warning = self.warning(piece.color);

    // Return king
    self.simpleMovePiece(piece, { x: x, y: y }, from);

    // return the movePiece with simpleMovePiece() method
    if (movePiece) self.simpleMovePiece(movePiece.piece, movePiece.to, movePiece.from);

    if (!warning) validMoves.push(move);
  });
  return validMoves;
};

Game.prototype.checkmate = function (color) {
  // using let will allow us to make the code a bit simpler
  for (var i = 0; i < 8; i++) {
    for (var j = 0; j < 8; j++) {
      if (this.board[i][j] && this.board[i][j].color === color && this.board[i][j].getValidMoves(true).length) return false;
    }
  }
  if (this.warning(color)) return color;
  return 'D';
};

Game.prototype.simpleMovePiece = function (piece, from, to) {
  var board = this.board;
  if (to) {
    board[to.y][to.x] = piece;
    piece.x = to.x;
    piece.y = to.y;
  }
  if (from) board[from.y][from.x] = null;
};

Game.prototype.simpleMove = function (move) {
  var self = this;
  var board = self.board;
  var from = move.from;
  var to = move.to;
  var piece = board[from.y][from.x];
  var capturedPiece = this.board[to.y][to.x] ? this.board[to.y][to.x] : null;
  var movePiece = board[to.y][to.x] ? {
    piece: board[to.y][to.x],
    from: { x: to.x, y: to.y },
    to: null
  } : null;

  this.turn.push({
    from: from,
    to: { x: to.x, y: to.y },
    color: move.color,
    type: piece.type,
    piece: capturedPiece,
    movePiece: movePiece
  });

  if (to.movePiece) movePiece = to.movePiece;
  if (movePiece) self.simpleMovePiece(movePiece.piece, movePiece.from, movePiece.to);
  self.simpleMovePiece(piece, from, { x: to.x, y: to.y });

  return function () {
    // return the current move /ev/
    if (movePiece) self.simpleMovePiece(movePiece.piece, movePiece.to, movePiece.from);
    self.simpleMovePiece(piece, { x: to.x, y: to.y }, from);
    if (capturedPiece) board[to.y][to.x] = capturedPiece;
    self.turn.pop();
  };
};

Game.prototype.warning = function (color) {
  var result = false;
  var king;

  this.board.forEach(function (yyy) {
    yyy.forEach(function (xxx) {
      if (xxx && xxx.color === color && xxx.type === 'king') {
        king = xxx;
      }
    });
  });

  this.board.forEach(function (yyy) {
    yyy.forEach(function (xxx) {
      if (xxx && xxx.color !== color) {
        xxx.getValidMoves().forEach(function (mmm) {
          if (mmm.x === king.x && mmm.y === king.y) result = true;
        });
      }
    });
  });
  return result;
};

Game.prototype.threefoldCheck = function () {
  var threefold = this.threefold;
  var length = threefold.length;

  for (var i = 0; i < length; i++) {
    // using let will allow us to make the code simpler
    var count = 0;
    for (var j = i + 1; j < length; j++) {
      if (threefold[i] === threefold[j]) count += 1;
    }
    if (count >= 2) return true;
  }

  return false;
};

Game.prototype.pieceToAN = function (x, y) {
  var xChars = 'abcdefgh';
  return xChars.charAt(x) + (8 - y);
};

// Support FEN functions in the API
Game.prototype.boardToFEN = function () {
  var board = this.board;

  // Convert the board configuration into FEN
  var FENboard = '';
  var missingPieces = 0;
  for (var i = 0; i < 8; i++) {
    for (var j = 0; j < 8; j++) {
      if (board[i][j]) {
        if (missingPieces) FENboard += missingPieces;
        missingPieces = 0;
        FENboard += board[i][j].FENname;
      } else {
        missingPieces++;
      }
    }
    if (missingPieces) FENboard += missingPieces;
    missingPieces = 0;
    FENboard += i < 7 ? '/' : '';
  }

  return FENboard;
};

Game.prototype.halfmoveClock = function () {
  var turn = this.turn;
  var length = turn.length;
  var count = 0;
  if (turn.length === 0) return count;

  var ev = turn[length - 1 - count];
  while (count <= length - 1 && ev.type !== 'pawn' && !ev.piece) {
    count++;
    ev = turn[length - 1 - count];
  }

  return count;
};

Game.prototype.activeColour = function () {
  var turn = this.turn;
  var activeColor = turn.length && turn[turn.length - 1].color === 'W' ? 'b' : 'w';

  return activeColor;
};

Game.prototype.castlingTarget = function () {
  var board = this.board;
  var turn = this.turn;
  var possibleCastling = '';

  var whiteKingMoved;
  var blackKingMoved;
  turn.forEach(function (turn) {
    whiteKingMoved = turn.type === 'king' && turn.color === 'W';
    blackKingMoved = turn.type === 'king' && turn.color === 'B';
  });

  [[7, 0], [0, 0], [7, 7], [0, 7]].forEach(function (props) {
    var rookX = props[0];
    var rookY = props[1];
    var rook = board[rookY][rookX];

    if (rookY === 7 && whiteKingMoved) return;
    if (rookY === 0 && blackKingMoved) return;

    // Check rook on position
    if (!rook || !rook.type === 'rook') return;

    // Check rook hasn't moved
    if (turn.some(function (ev) {
      if (ev.type !== 'rook') return false;
      return ev.from.x === rookX && ev.from.y === rookY;
    })) return;

    var castlingSide = rookX === 0 ? 'q' : 'k';
    possibleCastling += rookY === 0 ? castlingSide.toUpperCase() : castlingSide;
  });

  if (!possibleCastling) possibleCastling = '-';
  return possibleCastling;
};

Game.prototype.enPassantTarget = function () {
  var turn = this.turn;
  var enPassantTarget = '';

  if (turn.length) {
    var ev = turn[turn.length - 1];
    if (ev.color === 'W' && ev.to.y === 4) {
      enPassantTarget = this.pieceToAN(ev.to.x, ev.to.y + 1);
    }

    if (ev.color === 'B' && ev.to.y === 3) {
      enPassantTarget = this.pieceToAN(ev.to.x, ev.to.y - 1);
    }
  }

  if (!enPassantTarget) enPassantTarget = '-';
  return enPassantTarget;
};

Game.prototype.fullmoveCount = function () {
  var count = 1;
  this.turn.forEach(function (ev) {
    if (ev.color === 'B') count += 1;
  });

  return count;
};

Game.prototype.gameToFEN = function () {
  var FEN = '';

  // Check the board configuration
  FEN += this.boardToFEN();

  // Find the active colour
  FEN += ' ' + this.activeColour();

  // Check castling availability
  FEN += ' ' + this.castlingTarget();

  // Check the En-passant target
  FEN += ' ' + this.enPassantTarget();

  // Add the halfmove clock
  FEN += ' ' + this.halfmoveClock();

  // Add the fullmove number
  FEN += ' ' + this.fullmoveCount();

  /*
    More information about the FEN notation:
    https://en.wikipedia.org/wiki/Forsyth%E2%80%93Edwards_Notation
    https://chessprogramming.wikispaces.com/Forsyth-Edwards+Notation
  */

  return FEN;
};

// Set up default game configuration
Game.prototype.initializeGame = function () {
  var defaultGame = new Game();

  // Pawns:
  for (var i = 0; i < 8; i++) {
    defaultGame.piece('pawn', i, 6, 'W');
    defaultGame.piece('pawn', i, 1, 'B');
  }

  // Black figs:
  defaultGame.piece('rook', 0, 0, 'B');
  defaultGame.piece('knight', 1, 0, 'B');
  defaultGame.piece('bishop', 2, 0, 'B');
  defaultGame.piece('queen', 3, 0, 'B');
  defaultGame.piece('king', 4, 0, 'B');
  defaultGame.piece('bishop', 5, 0, 'B');
  defaultGame.piece('knight', 6, 0, 'B');
  defaultGame.piece('rook', 7, 0, 'B');

  // White figs:
  defaultGame.piece('rook', 0, 7, 'W');
  defaultGame.piece('knight', 1, 7, 'W');
  defaultGame.piece('bishop', 2, 7, 'W');
  defaultGame.piece('queen', 3, 7, 'W');
  defaultGame.piece('king', 4, 7, 'W');
  defaultGame.piece('bishop', 5, 7, 'W');
  defaultGame.piece('knight', 6, 7, 'W');
  defaultGame.piece('rook', 7, 7, 'W');

  return defaultGame;
};

Game.prototype.allMoves = function () {
  var board = this.board;
  var allMoves = [];
  var activeColour = this.activeColour().toUpperCase();

  for (var i = 0; i < 8; i++) {
    for (var j = 0; j < 8; j++) {
      if (board[i][j] && board[i][j].color === activeColour) {
        var validMoves = board[i][j].getValidMoves(true);
        validMoves.forEach(function (ev) {
          allMoves.push({
            color: board[i][j].color,
            from: { x: j, y: i },
            to: ev,
            FENname: board[i][j].FENname
          });
        });
      }
    }
  }

  return allMoves;
};

exports.default = Game;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
//
// RSG Chess
// Licensed under Apache 2.0 LICENSE

var PIECE_CHARS = exports.PIECE_CHARS = {
  pawn: { W: '♙', B: '♟' },
  rook: { W: '♖', B: '♜' },
  knight: { W: '♘', B: '♞' },
  bishop: { W: '♗', B: '♝' },
  queen: { W: '♕', B: '♛' },
  king: { W: '♔', B: '♚' }
};

function Piece(x, y, charBase, color, game, type) {
  if (charBase) this.char = charBase[color];
  this.color = color;
  this.x = x;
  this.y = y;
  this.game = game;
  this.type = type;
  if (type) {
    var FENname = type === 'knight' ? 'n' : type.charAt(0);
    if (this.color === 'W') FENname = FENname.toUpperCase();
    this.FENname = FENname;
  }
}

Piece.empty = function () {
  return new Piece();
};

Piece.prototype.getValidMoves = function () {
  return [{ x: 0, y: 0 }, { x: 7, y: 7 }];
};

function Pawn(x, y, color, game) {
  Piece.call(this, x, y, PIECE_CHARS.pawn, color, game, 'pawn');
}

Pawn.prototype = Piece.empty();
Pawn.prototype.getValidMoves = function (simulate) {
  var game = this.game;
  var moves = [];
  /* eslint-disable */
  var y = this.y,
      x = this.x;
  var board = game.board,
      turn = game.turn,
      length = turn.length;
  var last, turnTo, turnFrom, figX, passantLast, passantFig;
  var colorY = this.color === 'W' ? y - 1 : y + 1;
  var colorY2 = this.color === 'W' ? y - 2 : y + 2;
  var passantY2 = this.color === 'W' ? 3 : 4;
  var figXArray = [x - 1, x + 1];
  /* eslint-enable */

  if (colorY < 8 && colorY >= 0 && !board[colorY][x]) {
    moves.push({ x: x, y: colorY });
    if ((y === 1 || y === 6) && colorY2 < 8 && colorY2 >= 0 && !game.board[colorY2][x]) {
      moves.push({ x: x, y: colorY2 });
    }
  }

  for (var i = 0; i < 2; i++) {
    figX = figXArray[i];
    if (colorY < 8 && colorY >= 0 && board[colorY][figX] && board[colorY][figX].color !== this.color) moves.push({ x: figX, y: colorY });
  }

  // Check for en-passant
  for (var _i = 0; _i < 2; _i++) {
    figX = figXArray[_i];
    last = turn[length - 1];

    if (last && last.type === 'pawn' && last.to.x === figX && last.to.y === y && last.color !== this.color && (last.from.y === 1 || last.from.y === 6) && (y === 3 || y === 4)) {
      moves.push({
        x: figX,
        y: colorY,
        movePiece: {
          piece: game.board[y][figX],
          from: {
            x: figX,
            y: y
          },
          to: null
        }
      });
    }
  }

  var validMoves = [];
  if (simulate) {
    validMoves = game.simulateAndFilter(moves, this);
  } else {
    validMoves = moves;
  }

  return validMoves;
};

Piece.pawn = function (x, y, color, game) {
  return new Pawn(x, y, color, game);
};

// //

function Rook(x, y, color, game) {
  Piece.call(this, x, y, PIECE_CHARS.rook, color, game, 'rook');
}

Rook.prototype = Piece.empty();
Rook.prototype.getValidMoves = function (simulate) {
  var game = this.game;
  var moves = [];

  [[-1, 0], [1, 0], [0, 1], [0, -1]].forEach(function (coef) {
    var index, x, y, piece;
    for (index = 1;; index++) {
      x = this.x + coef[0] * index;
      y = this.y + coef[1] * index;
      if (y < 0 || y > 7 || x < 0 || x > 7) break;

      piece = game.board[y][x];
      if (piece && piece.color === this.color) break;

      moves.push({ x: x, y: y });
      if (piece) break;
    }
  }, this);

  var validMoves = [];
  if (simulate) {
    validMoves = game.simulateAndFilter(moves, this);
  } else {
    validMoves = moves;
  }

  return validMoves;
};

Piece.rook = function (x, y, color, game) {
  return new Rook(x, y, color, game);
};

// //

function Knight(x, y, color, game) {
  Piece.call(this, x, y, PIECE_CHARS.knight, color, game, 'knight');
}

Knight.prototype = Piece.empty();
Knight.prototype.getValidMoves = function (simulate) {
  var game = this.game;
  var moves = [];

  var coordinates = [[2, 1], [-2, 1], [1, 2], [-1, 2], [2, -1], [-2, -1], [1, -2], [-1, -2]];

  var one, two;
  for (var i = 0; i < coordinates.length; i++) {
    var help = false;
    var boardPiece;
    one = coordinates[i][0];
    two = coordinates[i][1];

    if (this.x + one < 8 && this.x + one >= 0 && this.y + two < 8 && this.y + two >= 0) {
      boardPiece = game.board[this.y + two][this.x + one];
      help = boardPiece ? boardPiece.color !== this.color : true;
    }

    if (help) {
      moves.push({ x: this.x + one, y: this.y + two });
    }
  }

  var validMoves = [];
  if (simulate) {
    validMoves = game.simulateAndFilter(moves, this);
  } else {
    validMoves = moves;
  }

  return validMoves;
};

Piece.knight = function (x, y, color, game) {
  return new Knight(x, y, color, game);
};

// //

function Bishop(x, y, color, game) {
  Piece.call(this, x, y, PIECE_CHARS.bishop, color, game, 'bishop');
}

Bishop.prototype = Piece.empty();
Bishop.prototype.getValidMoves = function (simulate) {
  var game = this.game;
  var moves = [];

  [[-1, -1], [1, 1], [-1, 1], [1, -1]].forEach(function (coef) {
    var index, x, y, piece;
    for (index = 1;; index++) {
      x = this.x + coef[0] * index;
      y = this.y + coef[1] * index;
      if (y < 0 || y > 7 || x < 0 || x > 7) break;

      piece = game.board[y][x];
      if (piece && piece.color === this.color) break;

      moves.push({ x: x, y: y });
      if (piece) break;
    }
  }, this);

  var validMoves = [];
  if (simulate) {
    validMoves = game.simulateAndFilter(moves, this);
  } else {
    validMoves = moves;
  }

  return validMoves;
};

Piece.bishop = function (x, y, color, game) {
  return new Bishop(x, y, color, game);
};

// //

function Queen(x, y, color, game) {
  Piece.call(this, x, y, PIECE_CHARS.queen, color, game, 'queen');
}

Queen.prototype = Piece.empty();
Queen.prototype.getValidMoves = function (simulate) {
  var game = this.game;
  var rookMoves = Rook.prototype.getValidMoves.call(this);
  var bishopMoves = Bishop.prototype.getValidMoves.call(this);
  var moves = rookMoves.concat(bishopMoves);

  var validMoves = [];
  if (simulate) {
    validMoves = game.simulateAndFilter(moves, this);
  } else {
    validMoves = moves;
  }

  return validMoves;
};

Piece.queen = function (x, y, color, game) {
  return new Queen(x, y, color, game);
};

// //

function King(x, y, color, game) {
  Piece.call(this, x, y, PIECE_CHARS.king, color, game, 'king');
}

King.prototype = Piece.empty();
King.prototype.getValidMoves = function (simulate) {
  var moves = [];
  var coordinates = [[0, 1], [0, -1], [1, 1], [-1, -1], [1, -1], [-1, 1], [-1, 0], [1, 0]];
  var x = this.x;
  var y = this.y;
  var game = this.game;
  var turn = game.turn;
  var self = this;

  coordinates.forEach(function (coord) {
    var piece;
    var xx = x + coord[0];
    var yy = y + coord[1];

    if (xx < 8 && xx >= 0 && yy < 8 && yy >= 0) {
      piece = game.board[yy][xx];
      if (!piece || piece.color !== self.color) {
        moves.push({ x: xx, y: yy });
      }
    }
  });

  // Check king hasn't moved
  var kingMoved = turn.some(function (turn) {
    return turn.type === 'king' && turn.color === self.color;
  });

  if (!kingMoved) {
    [[0, 2, -1], [7, 6, +1]].forEach(function (props) {
      var rookX = props[0];
      var newKingX = props[1];
      var dir = props[2];
      var rook = game.board[y][rookX];

      // Check rook on position
      if (!rook || !rook.type === 'rook') return;

      // Check rook hasn't moved
      if (turn.some(function (ev) {
        return ev.from.x === rookX && ev.from.y === y;
      })) return;

      // Check squares empty and safe
      for (var xx = x + dir; xx !== rookX; xx += dir) {
        if (game.board[y][xx]) return;
        var safe = true;
        game.board.forEach(function (ev) {
          ev.forEach(function (evv) {
            if (evv && evv.type !== 'king' && evv.color !== self.color) {
              evv.getValidMoves().forEach(function (evMove) {
                if (evMove && evMove.y === y && evMove.x === xx) safe = false;
              });
            }
          });
        });
        if (!safe) return;
      }

      var rochade = {
        x: newKingX,
        y: y,
        movePiece: {
          piece: self.game.board[y][rookX],
          from: {
            x: rookX, y: y
          },
          to: {
            y: y, x: x + dir
          }
        }
      };

      moves.push(rochade);
    });
  }

  var validMoves = [];
  if (simulate) {
    validMoves = game.simulateAndFilter(moves, self);
  } else {
    validMoves = moves;
  }

  return validMoves;
};

Piece.king = function (x, y, color, game) {
  return new King(x, y, color, game);
};

exports.Piece = Piece;
exports.Pawn = Pawn;
exports.Rook = Rook;
exports.Knight = Knight;
exports.Bishop = Bishop;
exports.Queen = Queen;
exports.King = King;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _game = __webpack_require__(0);

var _game2 = _interopRequireDefault(_game);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ChessAI = function ChessAI(depth, gameState, isMaximisingPlayer) {
  // Clone the gameState to access all game associated methods.
  // This usually doesn't make sense, but sometimes you cannot post functions to a backend or a web-worker
  // and that's why we're touching the game methods from new game configuration intead from the passed argument.
  // So if you pass {board: [myBoard], turn:[myTurn],...} for the game argument it will actually work!
  // Already described here: https://github.com/RSG-Group/Chess/issues/8#issuecomment-381245794
  var game = _game2.default.prototype.initializeGame();

  for (var i = 0; i < 8; i++) {
    for (var j = 0; j < 8; j++) {
      if (gameState.board[i][j]) {
        var currentCell = gameState.board[i][j];
        game.piece(currentCell.type, j, i, currentCell.color);
      } else {
        game.board[i][j] = null;
      }
    }
  }

  game.turn = gameState.turn;
  game.threefold = gameState.threefold;
  game.FEN = gameState.FEN;
  game.FENboard = gameState.FENboard;

  // Start looping and simulating all valid moves
  var allMoves = game.allMoves();
  var bestValue = -9999;
  var bestMove;

  for (var i = 0; i < allMoves.length; i++) {
    var newGameMove = allMoves[i];
    var undo = game.simpleMove(newGameMove);
    var boradValue = minimax(depth - 1, game, -10000, 10000, !isMaximisingPlayer);
    undo();
    if (boradValue >= bestValue) {
      bestValue = boradValue;
      bestMove = newGameMove;
    }
  }
  return bestMove;
}; //
// RSG Chess
// Licensed under Apache 2.0 LICENSE

var minimax = function minimax(depth, game, alpha, beta, isMaximisingPlayer) {
  if (depth === 0) {
    return -evaluateBoard(game.board);
  }

  var allMoves = game.allMoves();
  if (isMaximisingPlayer) {
    var bestValue = -9999;
    for (var i = 0; i < allMoves.length; i++) {
      var undo = game.simpleMove(allMoves[i]);
      bestValue = Math.max(bestValue, minimax(depth - 1, game, alpha, beta, !isMaximisingPlayer));
      undo();
      alpha = Math.max(alpha, bestValue);
      if (beta <= alpha) {
        return bestValue;
      }
    }
    return bestValue;
  } else {
    var _bestValue = 9999;
    for (var _i = 0; _i < allMoves.length; _i++) {
      var _undo = game.simpleMove(allMoves[_i]);
      _bestValue = Math.min(_bestValue, minimax(depth - 1, game, alpha, beta, !isMaximisingPlayer));
      _undo();
      beta = Math.min(beta, _bestValue);
      if (beta <= alpha) {
        return _bestValue;
      }
    }
    return _bestValue;
  }
};

var evaluateBoard = function evaluateBoard(board) {
  var totalEvaluation = 0;
  for (var i = 0; i < 8; i++) {
    for (var j = 0; j < 8; j++) {
      // calculate the current evaluation
      totalEvaluation = totalEvaluation + getPieceValue(board[i][j]);
    }
  }
  // return the total evaluation
  return totalEvaluation;
};

var getPieceValue = function getPieceValue(piece) {
  if (piece === null) {
    return 0;
  }

  // get value for every piece on the board
  var getAbsoluteValue = function getAbsoluteValue(piece) {
    if (piece.type === 'pawn') {
      return 10;
    } else if (piece.type === 'rook') {
      return 50;
    } else if (piece.type === 'knight') {
      return 30;
    } else if (piece.type === 'bishop') {
      return 30;
    } else if (piece.type === 'queen') {
      return 90;
    } else if (piece.type === 'king') {
      return 900;
    }
  };

  // calculate the absolute value and return it
  var absoluteValue = getAbsoluteValue(piece, piece.color === 'W');
  return piece.color === 'W' ? absoluteValue : -absoluteValue;
};

// export the algorithm
exports.default = ChessAI;

// Written by Radi Cho
// RSG Chess - by RSG Group

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AI = exports.Pieces = exports.Game = undefined;

var _game = __webpack_require__(0);

var _game2 = _interopRequireDefault(_game);

var _pieces = __webpack_require__(1);

var Pieces = _interopRequireWildcard(_pieces);

var _AI = __webpack_require__(2);

var _AI2 = _interopRequireDefault(_AI);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// And export...
exports.Game = _game2.default;
exports.Pieces = Pieces;
exports.AI = _AI2.default; // Let's import...

/***/ })
/******/ ]);
});
//# sourceMappingURL=index.js.map

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgMDE4OTcwMjBkYzRkY2IwYWVlMzYiLCJ3ZWJwYWNrOi8vLy4vanMvd29ya2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yc2ctY2hlc3MvbGliL2luZGV4LmpzIl0sIm5hbWVzIjpbInNlbGYiLCJhZGRFdmVudExpc3RlbmVyIiwiZSIsImRhdGEiLCJnYW1lIiwicGxheUFnYWluc3RBSSIsImJlc3RNb3ZlIiwiZGVwdGgiLCJwb3N0TWVzc2FnZSJdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7O0FDNURBOztBQUVBQSxLQUFLQyxnQkFBTCxDQUFzQixTQUF0QixFQUFpQyxVQUFVQyxDQUFWLEVBQWE7QUFDNUMsTUFBSUEsRUFBRUMsSUFBRixJQUFVRCxFQUFFQyxJQUFGLENBQU9DLElBQWpCLElBQXlCRixFQUFFQyxJQUFGLENBQU9FLGFBQXBDLEVBQW1EO0FBQ2pELFFBQUlDLFdBQVcsa0JBQUdKLEVBQUVDLElBQUYsQ0FBT0UsYUFBUCxDQUFxQkUsS0FBeEIsRUFBK0JMLEVBQUVDLElBQUYsQ0FBT0MsSUFBdEMsRUFBNEMsSUFBNUMsQ0FBZjtBQUNBSixTQUFLUSxXQUFMLENBQWlCRixRQUFqQjtBQUNEO0FBQ0YsQ0FMRCxFLENBSEEsaUM7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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUNBQXVDLDZCQUE2QixZQUFZLEVBQUUsT0FBTyxpQkFBaUIsbUJBQW1CLHVCQUF1Qiw0RUFBNEUsRUFBRSxFQUFFLHNCQUFzQixlQUFlLEVBQUU7O0FBRTNRLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3RjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7O0FBRTFCLE9BQU87QUFDUDtBQUNBLENBQUM7QUFDRCxpQyIsImZpbGUiOiJ3b3JrZXIubWluLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgMDE4OTcwMjBkYzRkY2IwYWVlMzYiLCIvLyBzZWxmLmltcG9ydFNjcmlwdHMoXCJnYW1lLmpzXCIpO1xyXG5pbXBvcnQgeyBBSSB9IGZyb20gJ3JzZy1jaGVzcydcclxuXHJcbnNlbGYuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uIChlKSB7XHJcbiAgaWYgKGUuZGF0YSAmJiBlLmRhdGEuZ2FtZSAmJiBlLmRhdGEucGxheUFnYWluc3RBSSkge1xyXG4gICAgdmFyIGJlc3RNb3ZlID0gQUkoZS5kYXRhLnBsYXlBZ2FpbnN0QUkuZGVwdGgsIGUuZGF0YS5nYW1lLCB0cnVlKVxyXG4gICAgc2VsZi5wb3N0TWVzc2FnZShiZXN0TW92ZSlcclxuICB9XHJcbn0pXHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2pzL3dvcmtlci5qcyIsIihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFwicnNnLWNoZXNzXCIsIFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcInJzZy1jaGVzc1wiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJyc2ctY2hlc3NcIl0gPSBmYWN0b3J5KCk7XG59KSh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuLyoqKioqKi8gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuLyoqKioqKi8gXHRcdFx0XHRnZXQ6IGdldHRlclxuLyoqKioqKi8gXHRcdFx0fSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDMpO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3BpZWNlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBfQUkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgX0FJMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0FJKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gR2FtZShwcm9tb0NhbGxiYWNrKSB7XG4gIC8vIHRoZSBnYW1lIGJvYXJkXG4gIHRoaXMuYm9hcmQgPSBbXTtcbiAgLy8gZmlsbCB0aGUgYm9hcmRcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHtcbiAgICB2YXIgYXJyYXlJbiA9IFtdO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgODsgaisrKSB7XG4gICAgICBhcnJheUluLnB1c2gobnVsbCk7XG4gICAgfVxuICAgIHRoaXMuYm9hcmQucHVzaChhcnJheUluKTtcbiAgfVxuXG4gIC8vIHRoZSBoaXN0b3J5IG9mIGFsbCB0dXJuc1xuICB0aGlzLnR1cm4gPSBbXTtcbiAgLy8gdGhlIGN1cnJlbnQgRkVOIHN0YXR1c1xuICB0aGlzLkZFTiA9IFtdO1xuICAvLyB0aGUgY3VycmVudCBnYW1lIGNvbmZpZ3VyYXRpb24gYXMgRkVOXG4gIHRoaXMuRkVOYm9hcmQgPSBbXTtcbiAgLy8gdGhlIGhpc3Rvcnkgb2YgYWxsIGdhbWUgY29uZmlndXJhdGlvbnMgZGlzcGxheWVkIHVzaW5nIEZFTlxuICB0aGlzLnRocmVlZm9sZCA9IFtdO1xufVxuXG5HYW1lLnByb3RvdHlwZS5waWVjZSA9IGZ1bmN0aW9uICh0eXBlLCB4LCB5LCBjb2xvcikge1xuICB2YXIgcGllY2UgPSBfcGllY2VzLlBpZWNlW3R5cGVdKHgsIHksIGNvbG9yLCB0aGlzKTtcbiAgdGhpcy5ib2FyZFt5XVt4XSA9IHBpZWNlO1xuXG4gIHRoaXMuRkVOID0gdGhpcy5nYW1lVG9GRU4oKTtcbiAgdGhpcy5GRU5ib2FyZCA9IHRoaXMuYm9hcmRUb0ZFTigpO1xufTtcblxuR2FtZS5wcm90b3R5cGUubW92ZVNlbGVjdGVkID0gZnVuY3Rpb24gKHNlbGVjdGVkLCB0bywgcHJvbW90aW9uQ2FsbGJhY2ssIGNoZWNrbWF0ZUNhbGxiYWNrLCBwbGF5QWdhaW5zdEFJLCBzaW11bGF0ZSkge1xuICB2YXIgeCA9IHRvLng7XG4gIHZhciB5ID0gdG8ueTtcblxuICBpZiAoc2VsZWN0ZWQpIHtcbiAgICB2YXIgZnJvbSA9IHsgeDogc2VsZWN0ZWQueCwgeTogc2VsZWN0ZWQueSB9O1xuXG4gICAgaWYgKHRoaXMuYm9hcmRbeV1beF0gIT09IHNlbGVjdGVkKSB7XG4gICAgICB2YXIgdmFsaWRNb3ZlcyA9IHNlbGVjdGVkLmdldFZhbGlkTW92ZXMoIXNpbXVsYXRlKTtcbiAgICAgIHZhciB2YWxpZE1vdmUgPSBudWxsO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbGlkTW92ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHZtID0gdmFsaWRNb3Zlc1tpXTtcbiAgICAgICAgaWYgKHZtLnggPT09IHggJiYgdm0ueSA9PT0geSkge1xuICAgICAgICAgIHZhbGlkTW92ZSA9IHZtO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghdmFsaWRNb3ZlKSByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgbW92ZVBpZWNlID0gdmFsaWRNb3ZlLm1vdmVQaWVjZTtcbiAgICAgIHZhciB0YWtlLCBwYXN0ZSwgcm9vaztcbiAgICAgIGlmIChtb3ZlUGllY2UpIHtcbiAgICAgICAgdGFrZSA9IG1vdmVQaWVjZS5mcm9tO1xuICAgICAgICBwYXN0ZSA9IG1vdmVQaWVjZS50bztcbiAgICAgICAgaWYgKHBhc3RlID09PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5ib2FyZFt0YWtlLnldW3Rha2UueF0gPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJvb2sgPSB0aGlzLmJvYXJkW3Rha2UueV1bdGFrZS54XTtcbiAgICAgICAgICB0aGlzLmJvYXJkW3Bhc3RlLnldW3Bhc3RlLnhdID0gcm9vaztcbiAgICAgICAgICByb29rLnggPSBwYXN0ZS54O1xuICAgICAgICAgIHJvb2sueSA9IHBhc3RlLnk7XG4gICAgICAgICAgdGhpcy5ib2FyZFt0YWtlLnldW3Rha2UueF0gPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBwaWVjZSA9IHRoaXMuYm9hcmRbeV1beF0gPyB0aGlzLmJvYXJkW3ldW3hdIDogbnVsbDtcbiAgICAgIG1vdmVQaWVjZSA9IG1vdmVQaWVjZSA/IHZhbGlkTW92ZS5tb3ZlUGllY2UgOiBudWxsO1xuICAgICAgdGhpcy50dXJuLnB1c2goe1xuICAgICAgICBmcm9tOiBmcm9tLFxuICAgICAgICB0bzogdG8sXG4gICAgICAgIGNvbG9yOiBzZWxlY3RlZC5jb2xvcixcbiAgICAgICAgdHlwZTogc2VsZWN0ZWQudHlwZSxcbiAgICAgICAgcGllY2U6IHBpZWNlLFxuICAgICAgICBtb3ZlUGllY2U6IG1vdmVQaWVjZVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuYm9hcmRbeV1beF0gPSBzZWxlY3RlZDtcbiAgICAgIHRoaXMuYm9hcmRbc2VsZWN0ZWQueV1bc2VsZWN0ZWQueF0gPSBudWxsO1xuICAgICAgdGhpcy5ib2FyZFt5XVt4XS54ID0geDtcbiAgICAgIHRoaXMuYm9hcmRbeV1beF0ueSA9IHk7XG5cbiAgICAgIHRoaXMuRkVOID0gdGhpcy5nYW1lVG9GRU4oKTtcbiAgICAgIHRoaXMuRkVOYm9hcmQgPSB0aGlzLmJvYXJkVG9GRU4oKTtcbiAgICAgIC8vIGNoZWNrIGZvciB0aHJlZWZvbGQgcmVwZXRpdGlvblxuXG4gICAgICB0aGlzLnRocmVlZm9sZC5wdXNoKHRoaXMuRkVOYm9hcmQpO1xuICAgICAgaWYgKHNlbGVjdGVkLnR5cGUgPT09ICdwYXduJyB8fCBwaWVjZSkgdGhpcy50aHJlZWZvbGQgPSBbXTtcbiAgICAgIGlmICh0aGlzLnRocmVlZm9sZENoZWNrKCkpIGNoZWNrbWF0ZUNhbGxiYWNrKCdEJyk7XG5cbiAgICAgIC8vIGNoZWNrIGZvciB0aGUgZmlmdHktbW92ZSBydWxlXG4gICAgICBpZiAodGhpcy5oYWxmbW92ZUNsb2NrKCkgPj0gNTApIGNoZWNrbWF0ZUNhbGxiYWNrKCdEJyk7XG5cbiAgICAgIC8vIGNoZWNrIGZvciBwYXduIHByb21vdGlvblxuICAgICAgaWYgKHNlbGVjdGVkLnR5cGUgPT09ICdwYXduJykge1xuICAgICAgICBpZiAoc2VsZWN0ZWQuY29sb3IgPT09ICdXJyAmJiB5ID09PSAwIHx8IHNlbGVjdGVkLmNvbG9yID09PSAnQicgJiYgeSA9PT0gNykge1xuICAgICAgICAgIGlmIChwcm9tb3Rpb25DYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKHBsYXlBZ2FpbnN0QUkgJiYgIXBsYXlBZ2FpbnN0QUkubW9kZSAmJiBwbGF5QWdhaW5zdEFJLmNvbWluZ0FJICYmIHNlbGVjdGVkLmNvbG9yID09PSAnQicpIHtcbiAgICAgICAgICAgICAgcGxheUFnYWluc3RBSS5jdXN0b21BSVByb21vdGlvbiA/IHBsYXlBZ2FpbnN0QUkuY3VzdG9tQUlQcm9tb3Rpb24oKSA6IHRoaXMucHJvbW90ZVBhd24oc2VsZWN0ZWQsIHgsIHksIHNlbGVjdGVkLmNvbG9yLCAncXVlZW4nKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHByb21vdGlvbkNhbGxiYWNrKHNlbGVjdGVkLCB4LCB5LCBzZWxlY3RlZC5jb2xvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgY2hlY2ttYXRlQ29sb3IgPSBzZWxlY3RlZC5jb2xvciA9PT0gJ1cnID8gJ0InIDogJ1cnO1xuICAgICAgdmFyIGNoZWNrbWF0ZVZhbHVlID0gdGhpcy5jaGVja21hdGUoY2hlY2ttYXRlQ29sb3IpO1xuICAgICAgaWYgKGNoZWNrbWF0ZVZhbHVlKSBjaGVja21hdGVDYWxsYmFjayhjaGVja21hdGVWYWx1ZSk7XG5cbiAgICAgIC8vIFBsYXkgQUlcbiAgICAgIGlmIChwbGF5QWdhaW5zdEFJICYmIHBsYXlBZ2FpbnN0QUkubW9kZSAmJiBwbGF5QWdhaW5zdEFJLm1vdmUpIHtcbiAgICAgICAgaWYgKHBsYXlBZ2FpbnN0QUkuY3VzdG9tQUlNb3ZlbWVudCkge1xuICAgICAgICAgIHBsYXlBZ2FpbnN0QUkuY3VzdG9tQUlNb3ZlbWVudCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBiZXN0TW92ZSA9ICgwLCBfQUkyLmRlZmF1bHQpKHBsYXlBZ2FpbnN0QUkuZGVwdGgsIHRoaXMsIGZhbHNlKTtcbiAgICAgICAgICB0aGlzLm1vdmVTZWxlY3RlZCh0aGlzLmJvYXJkW2Jlc3RNb3ZlLmZyb20ueV1bYmVzdE1vdmUuZnJvbS54XSwgYmVzdE1vdmUudG8sIHByb21vdGlvbkNhbGxiYWNrLCBjaGVja21hdGVDYWxsYmFjaywgZmFsc2UsIHRydWUsIHNpbXVsYXRlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gZW5kXG4gICAgfVxuICAgIHNlbGVjdGVkID0gbnVsbDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuR2FtZS5wcm90b3R5cGUucHJvbW90ZVBhd24gPSBmdW5jdGlvbiAocGF3biwgeCwgeSwgY29sb3IsIHR5cGUpIHtcbiAgdGhpcy5waWVjZSh0eXBlLCB4LCB5LCBjb2xvcik7XG59O1xuXG5HYW1lLnByb3RvdHlwZS5zaW11bGF0ZUFuZEZpbHRlciA9IGZ1bmN0aW9uIChtb3ZlcywgcGllY2UpIHtcbiAgdmFyIHZhbGlkTW92ZXMgPSBbXTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgYm9hcmQgPSB0aGlzLmJvYXJkO1xuXG4gIG1vdmVzLmZvckVhY2goZnVuY3Rpb24gKG1vdmUsIGkpIHtcbiAgICB2YXIgeSA9IG1vdmUueTtcbiAgICB2YXIgeCA9IG1vdmUueDtcbiAgICB2YXIgZnJvbSA9IHsgeDogcGllY2UueCwgeTogcGllY2UueSB9O1xuICAgIHZhciBtb3ZlUGllY2UgPSBib2FyZFt5XVt4XSA/IHtcbiAgICAgIHBpZWNlOiBib2FyZFt5XVt4XSxcbiAgICAgIGZyb206IHsgeDogeCwgeTogeSB9LFxuICAgICAgdG86IG51bGxcbiAgICB9IDogbnVsbDtcblxuICAgIGlmIChtb3ZlLm1vdmVQaWVjZSkgbW92ZVBpZWNlID0gbW92ZS5tb3ZlUGllY2U7XG4gICAgaWYgKG1vdmVQaWVjZSkgc2VsZi5zaW1wbGVNb3ZlUGllY2UobW92ZVBpZWNlLnBpZWNlLCBtb3ZlUGllY2UuZnJvbSwgbW92ZVBpZWNlLnRvKTtcblxuICAgIHNlbGYuc2ltcGxlTW92ZVBpZWNlKHBpZWNlLCBmcm9tLCB7IHg6IHgsIHk6IHkgfSk7XG4gICAgdmFyIHdhcm5pbmcgPSBzZWxmLndhcm5pbmcocGllY2UuY29sb3IpO1xuXG4gICAgLy8gUmV0dXJuIGtpbmdcbiAgICBzZWxmLnNpbXBsZU1vdmVQaWVjZShwaWVjZSwgeyB4OiB4LCB5OiB5IH0sIGZyb20pO1xuXG4gICAgLy8gcmV0dXJuIHRoZSBtb3ZlUGllY2Ugd2l0aCBzaW1wbGVNb3ZlUGllY2UoKSBtZXRob2RcbiAgICBpZiAobW92ZVBpZWNlKSBzZWxmLnNpbXBsZU1vdmVQaWVjZShtb3ZlUGllY2UucGllY2UsIG1vdmVQaWVjZS50bywgbW92ZVBpZWNlLmZyb20pO1xuXG4gICAgaWYgKCF3YXJuaW5nKSB2YWxpZE1vdmVzLnB1c2gobW92ZSk7XG4gIH0pO1xuICByZXR1cm4gdmFsaWRNb3Zlcztcbn07XG5cbkdhbWUucHJvdG90eXBlLmNoZWNrbWF0ZSA9IGZ1bmN0aW9uIChjb2xvcikge1xuICAvLyB1c2luZyBsZXQgd2lsbCBhbGxvdyB1cyB0byBtYWtlIHRoZSBjb2RlIGEgYml0IHNpbXBsZXJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykge1xuICAgICAgaWYgKHRoaXMuYm9hcmRbaV1bal0gJiYgdGhpcy5ib2FyZFtpXVtqXS5jb2xvciA9PT0gY29sb3IgJiYgdGhpcy5ib2FyZFtpXVtqXS5nZXRWYWxpZE1vdmVzKHRydWUpLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAodGhpcy53YXJuaW5nKGNvbG9yKSkgcmV0dXJuIGNvbG9yO1xuICByZXR1cm4gJ0QnO1xufTtcblxuR2FtZS5wcm90b3R5cGUuc2ltcGxlTW92ZVBpZWNlID0gZnVuY3Rpb24gKHBpZWNlLCBmcm9tLCB0bykge1xuICB2YXIgYm9hcmQgPSB0aGlzLmJvYXJkO1xuICBpZiAodG8pIHtcbiAgICBib2FyZFt0by55XVt0by54XSA9IHBpZWNlO1xuICAgIHBpZWNlLnggPSB0by54O1xuICAgIHBpZWNlLnkgPSB0by55O1xuICB9XG4gIGlmIChmcm9tKSBib2FyZFtmcm9tLnldW2Zyb20ueF0gPSBudWxsO1xufTtcblxuR2FtZS5wcm90b3R5cGUuc2ltcGxlTW92ZSA9IGZ1bmN0aW9uIChtb3ZlKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGJvYXJkID0gc2VsZi5ib2FyZDtcbiAgdmFyIGZyb20gPSBtb3ZlLmZyb207XG4gIHZhciB0byA9IG1vdmUudG87XG4gIHZhciBwaWVjZSA9IGJvYXJkW2Zyb20ueV1bZnJvbS54XTtcbiAgdmFyIGNhcHR1cmVkUGllY2UgPSB0aGlzLmJvYXJkW3RvLnldW3RvLnhdID8gdGhpcy5ib2FyZFt0by55XVt0by54XSA6IG51bGw7XG4gIHZhciBtb3ZlUGllY2UgPSBib2FyZFt0by55XVt0by54XSA/IHtcbiAgICBwaWVjZTogYm9hcmRbdG8ueV1bdG8ueF0sXG4gICAgZnJvbTogeyB4OiB0by54LCB5OiB0by55IH0sXG4gICAgdG86IG51bGxcbiAgfSA6IG51bGw7XG5cbiAgdGhpcy50dXJuLnB1c2goe1xuICAgIGZyb206IGZyb20sXG4gICAgdG86IHsgeDogdG8ueCwgeTogdG8ueSB9LFxuICAgIGNvbG9yOiBtb3ZlLmNvbG9yLFxuICAgIHR5cGU6IHBpZWNlLnR5cGUsXG4gICAgcGllY2U6IGNhcHR1cmVkUGllY2UsXG4gICAgbW92ZVBpZWNlOiBtb3ZlUGllY2VcbiAgfSk7XG5cbiAgaWYgKHRvLm1vdmVQaWVjZSkgbW92ZVBpZWNlID0gdG8ubW92ZVBpZWNlO1xuICBpZiAobW92ZVBpZWNlKSBzZWxmLnNpbXBsZU1vdmVQaWVjZShtb3ZlUGllY2UucGllY2UsIG1vdmVQaWVjZS5mcm9tLCBtb3ZlUGllY2UudG8pO1xuICBzZWxmLnNpbXBsZU1vdmVQaWVjZShwaWVjZSwgZnJvbSwgeyB4OiB0by54LCB5OiB0by55IH0pO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gcmV0dXJuIHRoZSBjdXJyZW50IG1vdmUgL2V2L1xuICAgIGlmIChtb3ZlUGllY2UpIHNlbGYuc2ltcGxlTW92ZVBpZWNlKG1vdmVQaWVjZS5waWVjZSwgbW92ZVBpZWNlLnRvLCBtb3ZlUGllY2UuZnJvbSk7XG4gICAgc2VsZi5zaW1wbGVNb3ZlUGllY2UocGllY2UsIHsgeDogdG8ueCwgeTogdG8ueSB9LCBmcm9tKTtcbiAgICBpZiAoY2FwdHVyZWRQaWVjZSkgYm9hcmRbdG8ueV1bdG8ueF0gPSBjYXB0dXJlZFBpZWNlO1xuICAgIHNlbGYudHVybi5wb3AoKTtcbiAgfTtcbn07XG5cbkdhbWUucHJvdG90eXBlLndhcm5pbmcgPSBmdW5jdGlvbiAoY29sb3IpIHtcbiAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICB2YXIga2luZztcblxuICB0aGlzLmJvYXJkLmZvckVhY2goZnVuY3Rpb24gKHl5eSkge1xuICAgIHl5eS5mb3JFYWNoKGZ1bmN0aW9uICh4eHgpIHtcbiAgICAgIGlmICh4eHggJiYgeHh4LmNvbG9yID09PSBjb2xvciAmJiB4eHgudHlwZSA9PT0gJ2tpbmcnKSB7XG4gICAgICAgIGtpbmcgPSB4eHg7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIHRoaXMuYm9hcmQuZm9yRWFjaChmdW5jdGlvbiAoeXl5KSB7XG4gICAgeXl5LmZvckVhY2goZnVuY3Rpb24gKHh4eCkge1xuICAgICAgaWYgKHh4eCAmJiB4eHguY29sb3IgIT09IGNvbG9yKSB7XG4gICAgICAgIHh4eC5nZXRWYWxpZE1vdmVzKCkuZm9yRWFjaChmdW5jdGlvbiAobW1tKSB7XG4gICAgICAgICAgaWYgKG1tbS54ID09PSBraW5nLnggJiYgbW1tLnkgPT09IGtpbmcueSkgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuR2FtZS5wcm90b3R5cGUudGhyZWVmb2xkQ2hlY2sgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0aHJlZWZvbGQgPSB0aGlzLnRocmVlZm9sZDtcbiAgdmFyIGxlbmd0aCA9IHRocmVlZm9sZC5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIC8vIHVzaW5nIGxldCB3aWxsIGFsbG93IHVzIHRvIG1ha2UgdGhlIGNvZGUgc2ltcGxlclxuICAgIHZhciBjb3VudCA9IDA7XG4gICAgZm9yICh2YXIgaiA9IGkgKyAxOyBqIDwgbGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmICh0aHJlZWZvbGRbaV0gPT09IHRocmVlZm9sZFtqXSkgY291bnQgKz0gMTtcbiAgICB9XG4gICAgaWYgKGNvdW50ID49IDIpIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuR2FtZS5wcm90b3R5cGUucGllY2VUb0FOID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgdmFyIHhDaGFycyA9ICdhYmNkZWZnaCc7XG4gIHJldHVybiB4Q2hhcnMuY2hhckF0KHgpICsgKDggLSB5KTtcbn07XG5cbi8vIFN1cHBvcnQgRkVOIGZ1bmN0aW9ucyBpbiB0aGUgQVBJXG5HYW1lLnByb3RvdHlwZS5ib2FyZFRvRkVOID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYm9hcmQgPSB0aGlzLmJvYXJkO1xuXG4gIC8vIENvbnZlcnQgdGhlIGJvYXJkIGNvbmZpZ3VyYXRpb24gaW50byBGRU5cbiAgdmFyIEZFTmJvYXJkID0gJyc7XG4gIHZhciBtaXNzaW5nUGllY2VzID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IDg7IGorKykge1xuICAgICAgaWYgKGJvYXJkW2ldW2pdKSB7XG4gICAgICAgIGlmIChtaXNzaW5nUGllY2VzKSBGRU5ib2FyZCArPSBtaXNzaW5nUGllY2VzO1xuICAgICAgICBtaXNzaW5nUGllY2VzID0gMDtcbiAgICAgICAgRkVOYm9hcmQgKz0gYm9hcmRbaV1bal0uRkVObmFtZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1pc3NpbmdQaWVjZXMrKztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1pc3NpbmdQaWVjZXMpIEZFTmJvYXJkICs9IG1pc3NpbmdQaWVjZXM7XG4gICAgbWlzc2luZ1BpZWNlcyA9IDA7XG4gICAgRkVOYm9hcmQgKz0gaSA8IDcgPyAnLycgOiAnJztcbiAgfVxuXG4gIHJldHVybiBGRU5ib2FyZDtcbn07XG5cbkdhbWUucHJvdG90eXBlLmhhbGZtb3ZlQ2xvY2sgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0dXJuID0gdGhpcy50dXJuO1xuICB2YXIgbGVuZ3RoID0gdHVybi5sZW5ndGg7XG4gIHZhciBjb3VudCA9IDA7XG4gIGlmICh0dXJuLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGNvdW50O1xuXG4gIHZhciBldiA9IHR1cm5bbGVuZ3RoIC0gMSAtIGNvdW50XTtcbiAgd2hpbGUgKGNvdW50IDw9IGxlbmd0aCAtIDEgJiYgZXYudHlwZSAhPT0gJ3Bhd24nICYmICFldi5waWVjZSkge1xuICAgIGNvdW50Kys7XG4gICAgZXYgPSB0dXJuW2xlbmd0aCAtIDEgLSBjb3VudF07XG4gIH1cblxuICByZXR1cm4gY291bnQ7XG59O1xuXG5HYW1lLnByb3RvdHlwZS5hY3RpdmVDb2xvdXIgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0dXJuID0gdGhpcy50dXJuO1xuICB2YXIgYWN0aXZlQ29sb3IgPSB0dXJuLmxlbmd0aCAmJiB0dXJuW3R1cm4ubGVuZ3RoIC0gMV0uY29sb3IgPT09ICdXJyA/ICdiJyA6ICd3JztcblxuICByZXR1cm4gYWN0aXZlQ29sb3I7XG59O1xuXG5HYW1lLnByb3RvdHlwZS5jYXN0bGluZ1RhcmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGJvYXJkID0gdGhpcy5ib2FyZDtcbiAgdmFyIHR1cm4gPSB0aGlzLnR1cm47XG4gIHZhciBwb3NzaWJsZUNhc3RsaW5nID0gJyc7XG5cbiAgdmFyIHdoaXRlS2luZ01vdmVkO1xuICB2YXIgYmxhY2tLaW5nTW92ZWQ7XG4gIHR1cm4uZm9yRWFjaChmdW5jdGlvbiAodHVybikge1xuICAgIHdoaXRlS2luZ01vdmVkID0gdHVybi50eXBlID09PSAna2luZycgJiYgdHVybi5jb2xvciA9PT0gJ1cnO1xuICAgIGJsYWNrS2luZ01vdmVkID0gdHVybi50eXBlID09PSAna2luZycgJiYgdHVybi5jb2xvciA9PT0gJ0InO1xuICB9KTtcblxuICBbWzcsIDBdLCBbMCwgMF0sIFs3LCA3XSwgWzAsIDddXS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wcykge1xuICAgIHZhciByb29rWCA9IHByb3BzWzBdO1xuICAgIHZhciByb29rWSA9IHByb3BzWzFdO1xuICAgIHZhciByb29rID0gYm9hcmRbcm9va1ldW3Jvb2tYXTtcblxuICAgIGlmIChyb29rWSA9PT0gNyAmJiB3aGl0ZUtpbmdNb3ZlZCkgcmV0dXJuO1xuICAgIGlmIChyb29rWSA9PT0gMCAmJiBibGFja0tpbmdNb3ZlZCkgcmV0dXJuO1xuXG4gICAgLy8gQ2hlY2sgcm9vayBvbiBwb3NpdGlvblxuICAgIGlmICghcm9vayB8fCAhcm9vay50eXBlID09PSAncm9vaycpIHJldHVybjtcblxuICAgIC8vIENoZWNrIHJvb2sgaGFzbid0IG1vdmVkXG4gICAgaWYgKHR1cm4uc29tZShmdW5jdGlvbiAoZXYpIHtcbiAgICAgIGlmIChldi50eXBlICE9PSAncm9vaycpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiBldi5mcm9tLnggPT09IHJvb2tYICYmIGV2LmZyb20ueSA9PT0gcm9va1k7XG4gICAgfSkpIHJldHVybjtcblxuICAgIHZhciBjYXN0bGluZ1NpZGUgPSByb29rWCA9PT0gMCA/ICdxJyA6ICdrJztcbiAgICBwb3NzaWJsZUNhc3RsaW5nICs9IHJvb2tZID09PSAwID8gY2FzdGxpbmdTaWRlLnRvVXBwZXJDYXNlKCkgOiBjYXN0bGluZ1NpZGU7XG4gIH0pO1xuXG4gIGlmICghcG9zc2libGVDYXN0bGluZykgcG9zc2libGVDYXN0bGluZyA9ICctJztcbiAgcmV0dXJuIHBvc3NpYmxlQ2FzdGxpbmc7XG59O1xuXG5HYW1lLnByb3RvdHlwZS5lblBhc3NhbnRUYXJnZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0dXJuID0gdGhpcy50dXJuO1xuICB2YXIgZW5QYXNzYW50VGFyZ2V0ID0gJyc7XG5cbiAgaWYgKHR1cm4ubGVuZ3RoKSB7XG4gICAgdmFyIGV2ID0gdHVyblt0dXJuLmxlbmd0aCAtIDFdO1xuICAgIGlmIChldi5jb2xvciA9PT0gJ1cnICYmIGV2LnRvLnkgPT09IDQpIHtcbiAgICAgIGVuUGFzc2FudFRhcmdldCA9IHRoaXMucGllY2VUb0FOKGV2LnRvLngsIGV2LnRvLnkgKyAxKTtcbiAgICB9XG5cbiAgICBpZiAoZXYuY29sb3IgPT09ICdCJyAmJiBldi50by55ID09PSAzKSB7XG4gICAgICBlblBhc3NhbnRUYXJnZXQgPSB0aGlzLnBpZWNlVG9BTihldi50by54LCBldi50by55IC0gMSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFlblBhc3NhbnRUYXJnZXQpIGVuUGFzc2FudFRhcmdldCA9ICctJztcbiAgcmV0dXJuIGVuUGFzc2FudFRhcmdldDtcbn07XG5cbkdhbWUucHJvdG90eXBlLmZ1bGxtb3ZlQ291bnQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjb3VudCA9IDE7XG4gIHRoaXMudHVybi5mb3JFYWNoKGZ1bmN0aW9uIChldikge1xuICAgIGlmIChldi5jb2xvciA9PT0gJ0InKSBjb3VudCArPSAxO1xuICB9KTtcblxuICByZXR1cm4gY291bnQ7XG59O1xuXG5HYW1lLnByb3RvdHlwZS5nYW1lVG9GRU4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBGRU4gPSAnJztcblxuICAvLyBDaGVjayB0aGUgYm9hcmQgY29uZmlndXJhdGlvblxuICBGRU4gKz0gdGhpcy5ib2FyZFRvRkVOKCk7XG5cbiAgLy8gRmluZCB0aGUgYWN0aXZlIGNvbG91clxuICBGRU4gKz0gJyAnICsgdGhpcy5hY3RpdmVDb2xvdXIoKTtcblxuICAvLyBDaGVjayBjYXN0bGluZyBhdmFpbGFiaWxpdHlcbiAgRkVOICs9ICcgJyArIHRoaXMuY2FzdGxpbmdUYXJnZXQoKTtcblxuICAvLyBDaGVjayB0aGUgRW4tcGFzc2FudCB0YXJnZXRcbiAgRkVOICs9ICcgJyArIHRoaXMuZW5QYXNzYW50VGFyZ2V0KCk7XG5cbiAgLy8gQWRkIHRoZSBoYWxmbW92ZSBjbG9ja1xuICBGRU4gKz0gJyAnICsgdGhpcy5oYWxmbW92ZUNsb2NrKCk7XG5cbiAgLy8gQWRkIHRoZSBmdWxsbW92ZSBudW1iZXJcbiAgRkVOICs9ICcgJyArIHRoaXMuZnVsbG1vdmVDb3VudCgpO1xuXG4gIC8qXHJcbiAgICBNb3JlIGluZm9ybWF0aW9uIGFib3V0IHRoZSBGRU4gbm90YXRpb246XHJcbiAgICBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Gb3JzeXRoJUUyJTgwJTkzRWR3YXJkc19Ob3RhdGlvblxyXG4gICAgaHR0cHM6Ly9jaGVzc3Byb2dyYW1taW5nLndpa2lzcGFjZXMuY29tL0ZvcnN5dGgtRWR3YXJkcytOb3RhdGlvblxyXG4gICovXG5cbiAgcmV0dXJuIEZFTjtcbn07XG5cbi8vIFNldCB1cCBkZWZhdWx0IGdhbWUgY29uZmlndXJhdGlvblxuR2FtZS5wcm90b3R5cGUuaW5pdGlhbGl6ZUdhbWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBkZWZhdWx0R2FtZSA9IG5ldyBHYW1lKCk7XG5cbiAgLy8gUGF3bnM6XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgZGVmYXVsdEdhbWUucGllY2UoJ3Bhd24nLCBpLCA2LCAnVycpO1xuICAgIGRlZmF1bHRHYW1lLnBpZWNlKCdwYXduJywgaSwgMSwgJ0InKTtcbiAgfVxuXG4gIC8vIEJsYWNrIGZpZ3M6XG4gIGRlZmF1bHRHYW1lLnBpZWNlKCdyb29rJywgMCwgMCwgJ0InKTtcbiAgZGVmYXVsdEdhbWUucGllY2UoJ2tuaWdodCcsIDEsIDAsICdCJyk7XG4gIGRlZmF1bHRHYW1lLnBpZWNlKCdiaXNob3AnLCAyLCAwLCAnQicpO1xuICBkZWZhdWx0R2FtZS5waWVjZSgncXVlZW4nLCAzLCAwLCAnQicpO1xuICBkZWZhdWx0R2FtZS5waWVjZSgna2luZycsIDQsIDAsICdCJyk7XG4gIGRlZmF1bHRHYW1lLnBpZWNlKCdiaXNob3AnLCA1LCAwLCAnQicpO1xuICBkZWZhdWx0R2FtZS5waWVjZSgna25pZ2h0JywgNiwgMCwgJ0InKTtcbiAgZGVmYXVsdEdhbWUucGllY2UoJ3Jvb2snLCA3LCAwLCAnQicpO1xuXG4gIC8vIFdoaXRlIGZpZ3M6XG4gIGRlZmF1bHRHYW1lLnBpZWNlKCdyb29rJywgMCwgNywgJ1cnKTtcbiAgZGVmYXVsdEdhbWUucGllY2UoJ2tuaWdodCcsIDEsIDcsICdXJyk7XG4gIGRlZmF1bHRHYW1lLnBpZWNlKCdiaXNob3AnLCAyLCA3LCAnVycpO1xuICBkZWZhdWx0R2FtZS5waWVjZSgncXVlZW4nLCAzLCA3LCAnVycpO1xuICBkZWZhdWx0R2FtZS5waWVjZSgna2luZycsIDQsIDcsICdXJyk7XG4gIGRlZmF1bHRHYW1lLnBpZWNlKCdiaXNob3AnLCA1LCA3LCAnVycpO1xuICBkZWZhdWx0R2FtZS5waWVjZSgna25pZ2h0JywgNiwgNywgJ1cnKTtcbiAgZGVmYXVsdEdhbWUucGllY2UoJ3Jvb2snLCA3LCA3LCAnVycpO1xuXG4gIHJldHVybiBkZWZhdWx0R2FtZTtcbn07XG5cbkdhbWUucHJvdG90eXBlLmFsbE1vdmVzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYm9hcmQgPSB0aGlzLmJvYXJkO1xuICB2YXIgYWxsTW92ZXMgPSBbXTtcbiAgdmFyIGFjdGl2ZUNvbG91ciA9IHRoaXMuYWN0aXZlQ29sb3VyKCkudG9VcHBlckNhc2UoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgODsgaisrKSB7XG4gICAgICBpZiAoYm9hcmRbaV1bal0gJiYgYm9hcmRbaV1bal0uY29sb3IgPT09IGFjdGl2ZUNvbG91cikge1xuICAgICAgICB2YXIgdmFsaWRNb3ZlcyA9IGJvYXJkW2ldW2pdLmdldFZhbGlkTW92ZXModHJ1ZSk7XG4gICAgICAgIHZhbGlkTW92ZXMuZm9yRWFjaChmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICBhbGxNb3Zlcy5wdXNoKHtcbiAgICAgICAgICAgIGNvbG9yOiBib2FyZFtpXVtqXS5jb2xvcixcbiAgICAgICAgICAgIGZyb206IHsgeDogaiwgeTogaSB9LFxuICAgICAgICAgICAgdG86IGV2LFxuICAgICAgICAgICAgRkVObmFtZTogYm9hcmRbaV1bal0uRkVObmFtZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gYWxsTW92ZXM7XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBHYW1lO1xuXG4vKioqLyB9KSxcbi8qIDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbi8vXG4vLyBSU0cgQ2hlc3Ncbi8vIExpY2Vuc2VkIHVuZGVyIEFwYWNoZSAyLjAgTElDRU5TRVxuXG52YXIgUElFQ0VfQ0hBUlMgPSBleHBvcnRzLlBJRUNFX0NIQVJTID0ge1xuICBwYXduOiB7IFc6ICfimZknLCBCOiAn4pmfJyB9LFxuICByb29rOiB7IFc6ICfimZYnLCBCOiAn4pmcJyB9LFxuICBrbmlnaHQ6IHsgVzogJ+KZmCcsIEI6ICfimZ4nIH0sXG4gIGJpc2hvcDogeyBXOiAn4pmXJywgQjogJ+KZnScgfSxcbiAgcXVlZW46IHsgVzogJ+KZlScsIEI6ICfimZsnIH0sXG4gIGtpbmc6IHsgVzogJ+KZlCcsIEI6ICfimZonIH1cbn07XG5cbmZ1bmN0aW9uIFBpZWNlKHgsIHksIGNoYXJCYXNlLCBjb2xvciwgZ2FtZSwgdHlwZSkge1xuICBpZiAoY2hhckJhc2UpIHRoaXMuY2hhciA9IGNoYXJCYXNlW2NvbG9yXTtcbiAgdGhpcy5jb2xvciA9IGNvbG9yO1xuICB0aGlzLnggPSB4O1xuICB0aGlzLnkgPSB5O1xuICB0aGlzLmdhbWUgPSBnYW1lO1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICBpZiAodHlwZSkge1xuICAgIHZhciBGRU5uYW1lID0gdHlwZSA9PT0gJ2tuaWdodCcgPyAnbicgOiB0eXBlLmNoYXJBdCgwKTtcbiAgICBpZiAodGhpcy5jb2xvciA9PT0gJ1cnKSBGRU5uYW1lID0gRkVObmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgIHRoaXMuRkVObmFtZSA9IEZFTm5hbWU7XG4gIH1cbn1cblxuUGllY2UuZW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXcgUGllY2UoKTtcbn07XG5cblBpZWNlLnByb3RvdHlwZS5nZXRWYWxpZE1vdmVzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gW3sgeDogMCwgeTogMCB9LCB7IHg6IDcsIHk6IDcgfV07XG59O1xuXG5mdW5jdGlvbiBQYXduKHgsIHksIGNvbG9yLCBnYW1lKSB7XG4gIFBpZWNlLmNhbGwodGhpcywgeCwgeSwgUElFQ0VfQ0hBUlMucGF3biwgY29sb3IsIGdhbWUsICdwYXduJyk7XG59XG5cblBhd24ucHJvdG90eXBlID0gUGllY2UuZW1wdHkoKTtcblBhd24ucHJvdG90eXBlLmdldFZhbGlkTW92ZXMgPSBmdW5jdGlvbiAoc2ltdWxhdGUpIHtcbiAgdmFyIGdhbWUgPSB0aGlzLmdhbWU7XG4gIHZhciBtb3ZlcyA9IFtdO1xuICAvKiBlc2xpbnQtZGlzYWJsZSAqL1xuICB2YXIgeSA9IHRoaXMueSxcbiAgICAgIHggPSB0aGlzLng7XG4gIHZhciBib2FyZCA9IGdhbWUuYm9hcmQsXG4gICAgICB0dXJuID0gZ2FtZS50dXJuLFxuICAgICAgbGVuZ3RoID0gdHVybi5sZW5ndGg7XG4gIHZhciBsYXN0LCB0dXJuVG8sIHR1cm5Gcm9tLCBmaWdYLCBwYXNzYW50TGFzdCwgcGFzc2FudEZpZztcbiAgdmFyIGNvbG9yWSA9IHRoaXMuY29sb3IgPT09ICdXJyA/IHkgLSAxIDogeSArIDE7XG4gIHZhciBjb2xvclkyID0gdGhpcy5jb2xvciA9PT0gJ1cnID8geSAtIDIgOiB5ICsgMjtcbiAgdmFyIHBhc3NhbnRZMiA9IHRoaXMuY29sb3IgPT09ICdXJyA/IDMgOiA0O1xuICB2YXIgZmlnWEFycmF5ID0gW3ggLSAxLCB4ICsgMV07XG4gIC8qIGVzbGludC1lbmFibGUgKi9cblxuICBpZiAoY29sb3JZIDwgOCAmJiBjb2xvclkgPj0gMCAmJiAhYm9hcmRbY29sb3JZXVt4XSkge1xuICAgIG1vdmVzLnB1c2goeyB4OiB4LCB5OiBjb2xvclkgfSk7XG4gICAgaWYgKCh5ID09PSAxIHx8IHkgPT09IDYpICYmIGNvbG9yWTIgPCA4ICYmIGNvbG9yWTIgPj0gMCAmJiAhZ2FtZS5ib2FyZFtjb2xvclkyXVt4XSkge1xuICAgICAgbW92ZXMucHVzaCh7IHg6IHgsIHk6IGNvbG9yWTIgfSk7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICBmaWdYID0gZmlnWEFycmF5W2ldO1xuICAgIGlmIChjb2xvclkgPCA4ICYmIGNvbG9yWSA+PSAwICYmIGJvYXJkW2NvbG9yWV1bZmlnWF0gJiYgYm9hcmRbY29sb3JZXVtmaWdYXS5jb2xvciAhPT0gdGhpcy5jb2xvcikgbW92ZXMucHVzaCh7IHg6IGZpZ1gsIHk6IGNvbG9yWSB9KTtcbiAgfVxuXG4gIC8vIENoZWNrIGZvciBlbi1wYXNzYW50XG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCAyOyBfaSsrKSB7XG4gICAgZmlnWCA9IGZpZ1hBcnJheVtfaV07XG4gICAgbGFzdCA9IHR1cm5bbGVuZ3RoIC0gMV07XG5cbiAgICBpZiAobGFzdCAmJiBsYXN0LnR5cGUgPT09ICdwYXduJyAmJiBsYXN0LnRvLnggPT09IGZpZ1ggJiYgbGFzdC50by55ID09PSB5ICYmIGxhc3QuY29sb3IgIT09IHRoaXMuY29sb3IgJiYgKGxhc3QuZnJvbS55ID09PSAxIHx8IGxhc3QuZnJvbS55ID09PSA2KSAmJiAoeSA9PT0gMyB8fCB5ID09PSA0KSkge1xuICAgICAgbW92ZXMucHVzaCh7XG4gICAgICAgIHg6IGZpZ1gsXG4gICAgICAgIHk6IGNvbG9yWSxcbiAgICAgICAgbW92ZVBpZWNlOiB7XG4gICAgICAgICAgcGllY2U6IGdhbWUuYm9hcmRbeV1bZmlnWF0sXG4gICAgICAgICAgZnJvbToge1xuICAgICAgICAgICAgeDogZmlnWCxcbiAgICAgICAgICAgIHk6IHlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRvOiBudWxsXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHZhciB2YWxpZE1vdmVzID0gW107XG4gIGlmIChzaW11bGF0ZSkge1xuICAgIHZhbGlkTW92ZXMgPSBnYW1lLnNpbXVsYXRlQW5kRmlsdGVyKG1vdmVzLCB0aGlzKTtcbiAgfSBlbHNlIHtcbiAgICB2YWxpZE1vdmVzID0gbW92ZXM7XG4gIH1cblxuICByZXR1cm4gdmFsaWRNb3Zlcztcbn07XG5cblBpZWNlLnBhd24gPSBmdW5jdGlvbiAoeCwgeSwgY29sb3IsIGdhbWUpIHtcbiAgcmV0dXJuIG5ldyBQYXduKHgsIHksIGNvbG9yLCBnYW1lKTtcbn07XG5cbi8vIC8vXG5cbmZ1bmN0aW9uIFJvb2soeCwgeSwgY29sb3IsIGdhbWUpIHtcbiAgUGllY2UuY2FsbCh0aGlzLCB4LCB5LCBQSUVDRV9DSEFSUy5yb29rLCBjb2xvciwgZ2FtZSwgJ3Jvb2snKTtcbn1cblxuUm9vay5wcm90b3R5cGUgPSBQaWVjZS5lbXB0eSgpO1xuUm9vay5wcm90b3R5cGUuZ2V0VmFsaWRNb3ZlcyA9IGZ1bmN0aW9uIChzaW11bGF0ZSkge1xuICB2YXIgZ2FtZSA9IHRoaXMuZ2FtZTtcbiAgdmFyIG1vdmVzID0gW107XG5cbiAgW1stMSwgMF0sIFsxLCAwXSwgWzAsIDFdLCBbMCwgLTFdXS5mb3JFYWNoKGZ1bmN0aW9uIChjb2VmKSB7XG4gICAgdmFyIGluZGV4LCB4LCB5LCBwaWVjZTtcbiAgICBmb3IgKGluZGV4ID0gMTs7IGluZGV4KyspIHtcbiAgICAgIHggPSB0aGlzLnggKyBjb2VmWzBdICogaW5kZXg7XG4gICAgICB5ID0gdGhpcy55ICsgY29lZlsxXSAqIGluZGV4O1xuICAgICAgaWYgKHkgPCAwIHx8IHkgPiA3IHx8IHggPCAwIHx8IHggPiA3KSBicmVhaztcblxuICAgICAgcGllY2UgPSBnYW1lLmJvYXJkW3ldW3hdO1xuICAgICAgaWYgKHBpZWNlICYmIHBpZWNlLmNvbG9yID09PSB0aGlzLmNvbG9yKSBicmVhaztcblxuICAgICAgbW92ZXMucHVzaCh7IHg6IHgsIHk6IHkgfSk7XG4gICAgICBpZiAocGllY2UpIGJyZWFrO1xuICAgIH1cbiAgfSwgdGhpcyk7XG5cbiAgdmFyIHZhbGlkTW92ZXMgPSBbXTtcbiAgaWYgKHNpbXVsYXRlKSB7XG4gICAgdmFsaWRNb3ZlcyA9IGdhbWUuc2ltdWxhdGVBbmRGaWx0ZXIobW92ZXMsIHRoaXMpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkTW92ZXMgPSBtb3ZlcztcbiAgfVxuXG4gIHJldHVybiB2YWxpZE1vdmVzO1xufTtcblxuUGllY2Uucm9vayA9IGZ1bmN0aW9uICh4LCB5LCBjb2xvciwgZ2FtZSkge1xuICByZXR1cm4gbmV3IFJvb2soeCwgeSwgY29sb3IsIGdhbWUpO1xufTtcblxuLy8gLy9cblxuZnVuY3Rpb24gS25pZ2h0KHgsIHksIGNvbG9yLCBnYW1lKSB7XG4gIFBpZWNlLmNhbGwodGhpcywgeCwgeSwgUElFQ0VfQ0hBUlMua25pZ2h0LCBjb2xvciwgZ2FtZSwgJ2tuaWdodCcpO1xufVxuXG5LbmlnaHQucHJvdG90eXBlID0gUGllY2UuZW1wdHkoKTtcbktuaWdodC5wcm90b3R5cGUuZ2V0VmFsaWRNb3ZlcyA9IGZ1bmN0aW9uIChzaW11bGF0ZSkge1xuICB2YXIgZ2FtZSA9IHRoaXMuZ2FtZTtcbiAgdmFyIG1vdmVzID0gW107XG5cbiAgdmFyIGNvb3JkaW5hdGVzID0gW1syLCAxXSwgWy0yLCAxXSwgWzEsIDJdLCBbLTEsIDJdLCBbMiwgLTFdLCBbLTIsIC0xXSwgWzEsIC0yXSwgWy0xLCAtMl1dO1xuXG4gIHZhciBvbmUsIHR3bztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZGluYXRlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBoZWxwID0gZmFsc2U7XG4gICAgdmFyIGJvYXJkUGllY2U7XG4gICAgb25lID0gY29vcmRpbmF0ZXNbaV1bMF07XG4gICAgdHdvID0gY29vcmRpbmF0ZXNbaV1bMV07XG5cbiAgICBpZiAodGhpcy54ICsgb25lIDwgOCAmJiB0aGlzLnggKyBvbmUgPj0gMCAmJiB0aGlzLnkgKyB0d28gPCA4ICYmIHRoaXMueSArIHR3byA+PSAwKSB7XG4gICAgICBib2FyZFBpZWNlID0gZ2FtZS5ib2FyZFt0aGlzLnkgKyB0d29dW3RoaXMueCArIG9uZV07XG4gICAgICBoZWxwID0gYm9hcmRQaWVjZSA/IGJvYXJkUGllY2UuY29sb3IgIT09IHRoaXMuY29sb3IgOiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChoZWxwKSB7XG4gICAgICBtb3Zlcy5wdXNoKHsgeDogdGhpcy54ICsgb25lLCB5OiB0aGlzLnkgKyB0d28gfSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHZhbGlkTW92ZXMgPSBbXTtcbiAgaWYgKHNpbXVsYXRlKSB7XG4gICAgdmFsaWRNb3ZlcyA9IGdhbWUuc2ltdWxhdGVBbmRGaWx0ZXIobW92ZXMsIHRoaXMpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkTW92ZXMgPSBtb3ZlcztcbiAgfVxuXG4gIHJldHVybiB2YWxpZE1vdmVzO1xufTtcblxuUGllY2Uua25pZ2h0ID0gZnVuY3Rpb24gKHgsIHksIGNvbG9yLCBnYW1lKSB7XG4gIHJldHVybiBuZXcgS25pZ2h0KHgsIHksIGNvbG9yLCBnYW1lKTtcbn07XG5cbi8vIC8vXG5cbmZ1bmN0aW9uIEJpc2hvcCh4LCB5LCBjb2xvciwgZ2FtZSkge1xuICBQaWVjZS5jYWxsKHRoaXMsIHgsIHksIFBJRUNFX0NIQVJTLmJpc2hvcCwgY29sb3IsIGdhbWUsICdiaXNob3AnKTtcbn1cblxuQmlzaG9wLnByb3RvdHlwZSA9IFBpZWNlLmVtcHR5KCk7XG5CaXNob3AucHJvdG90eXBlLmdldFZhbGlkTW92ZXMgPSBmdW5jdGlvbiAoc2ltdWxhdGUpIHtcbiAgdmFyIGdhbWUgPSB0aGlzLmdhbWU7XG4gIHZhciBtb3ZlcyA9IFtdO1xuXG4gIFtbLTEsIC0xXSwgWzEsIDFdLCBbLTEsIDFdLCBbMSwgLTFdXS5mb3JFYWNoKGZ1bmN0aW9uIChjb2VmKSB7XG4gICAgdmFyIGluZGV4LCB4LCB5LCBwaWVjZTtcbiAgICBmb3IgKGluZGV4ID0gMTs7IGluZGV4KyspIHtcbiAgICAgIHggPSB0aGlzLnggKyBjb2VmWzBdICogaW5kZXg7XG4gICAgICB5ID0gdGhpcy55ICsgY29lZlsxXSAqIGluZGV4O1xuICAgICAgaWYgKHkgPCAwIHx8IHkgPiA3IHx8IHggPCAwIHx8IHggPiA3KSBicmVhaztcblxuICAgICAgcGllY2UgPSBnYW1lLmJvYXJkW3ldW3hdO1xuICAgICAgaWYgKHBpZWNlICYmIHBpZWNlLmNvbG9yID09PSB0aGlzLmNvbG9yKSBicmVhaztcblxuICAgICAgbW92ZXMucHVzaCh7IHg6IHgsIHk6IHkgfSk7XG4gICAgICBpZiAocGllY2UpIGJyZWFrO1xuICAgIH1cbiAgfSwgdGhpcyk7XG5cbiAgdmFyIHZhbGlkTW92ZXMgPSBbXTtcbiAgaWYgKHNpbXVsYXRlKSB7XG4gICAgdmFsaWRNb3ZlcyA9IGdhbWUuc2ltdWxhdGVBbmRGaWx0ZXIobW92ZXMsIHRoaXMpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkTW92ZXMgPSBtb3ZlcztcbiAgfVxuXG4gIHJldHVybiB2YWxpZE1vdmVzO1xufTtcblxuUGllY2UuYmlzaG9wID0gZnVuY3Rpb24gKHgsIHksIGNvbG9yLCBnYW1lKSB7XG4gIHJldHVybiBuZXcgQmlzaG9wKHgsIHksIGNvbG9yLCBnYW1lKTtcbn07XG5cbi8vIC8vXG5cbmZ1bmN0aW9uIFF1ZWVuKHgsIHksIGNvbG9yLCBnYW1lKSB7XG4gIFBpZWNlLmNhbGwodGhpcywgeCwgeSwgUElFQ0VfQ0hBUlMucXVlZW4sIGNvbG9yLCBnYW1lLCAncXVlZW4nKTtcbn1cblxuUXVlZW4ucHJvdG90eXBlID0gUGllY2UuZW1wdHkoKTtcblF1ZWVuLnByb3RvdHlwZS5nZXRWYWxpZE1vdmVzID0gZnVuY3Rpb24gKHNpbXVsYXRlKSB7XG4gIHZhciBnYW1lID0gdGhpcy5nYW1lO1xuICB2YXIgcm9va01vdmVzID0gUm9vay5wcm90b3R5cGUuZ2V0VmFsaWRNb3Zlcy5jYWxsKHRoaXMpO1xuICB2YXIgYmlzaG9wTW92ZXMgPSBCaXNob3AucHJvdG90eXBlLmdldFZhbGlkTW92ZXMuY2FsbCh0aGlzKTtcbiAgdmFyIG1vdmVzID0gcm9va01vdmVzLmNvbmNhdChiaXNob3BNb3Zlcyk7XG5cbiAgdmFyIHZhbGlkTW92ZXMgPSBbXTtcbiAgaWYgKHNpbXVsYXRlKSB7XG4gICAgdmFsaWRNb3ZlcyA9IGdhbWUuc2ltdWxhdGVBbmRGaWx0ZXIobW92ZXMsIHRoaXMpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkTW92ZXMgPSBtb3ZlcztcbiAgfVxuXG4gIHJldHVybiB2YWxpZE1vdmVzO1xufTtcblxuUGllY2UucXVlZW4gPSBmdW5jdGlvbiAoeCwgeSwgY29sb3IsIGdhbWUpIHtcbiAgcmV0dXJuIG5ldyBRdWVlbih4LCB5LCBjb2xvciwgZ2FtZSk7XG59O1xuXG4vLyAvL1xuXG5mdW5jdGlvbiBLaW5nKHgsIHksIGNvbG9yLCBnYW1lKSB7XG4gIFBpZWNlLmNhbGwodGhpcywgeCwgeSwgUElFQ0VfQ0hBUlMua2luZywgY29sb3IsIGdhbWUsICdraW5nJyk7XG59XG5cbktpbmcucHJvdG90eXBlID0gUGllY2UuZW1wdHkoKTtcbktpbmcucHJvdG90eXBlLmdldFZhbGlkTW92ZXMgPSBmdW5jdGlvbiAoc2ltdWxhdGUpIHtcbiAgdmFyIG1vdmVzID0gW107XG4gIHZhciBjb29yZGluYXRlcyA9IFtbMCwgMV0sIFswLCAtMV0sIFsxLCAxXSwgWy0xLCAtMV0sIFsxLCAtMV0sIFstMSwgMV0sIFstMSwgMF0sIFsxLCAwXV07XG4gIHZhciB4ID0gdGhpcy54O1xuICB2YXIgeSA9IHRoaXMueTtcbiAgdmFyIGdhbWUgPSB0aGlzLmdhbWU7XG4gIHZhciB0dXJuID0gZ2FtZS50dXJuO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgY29vcmRpbmF0ZXMuZm9yRWFjaChmdW5jdGlvbiAoY29vcmQpIHtcbiAgICB2YXIgcGllY2U7XG4gICAgdmFyIHh4ID0geCArIGNvb3JkWzBdO1xuICAgIHZhciB5eSA9IHkgKyBjb29yZFsxXTtcblxuICAgIGlmICh4eCA8IDggJiYgeHggPj0gMCAmJiB5eSA8IDggJiYgeXkgPj0gMCkge1xuICAgICAgcGllY2UgPSBnYW1lLmJvYXJkW3l5XVt4eF07XG4gICAgICBpZiAoIXBpZWNlIHx8IHBpZWNlLmNvbG9yICE9PSBzZWxmLmNvbG9yKSB7XG4gICAgICAgIG1vdmVzLnB1c2goeyB4OiB4eCwgeTogeXkgfSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvLyBDaGVjayBraW5nIGhhc24ndCBtb3ZlZFxuICB2YXIga2luZ01vdmVkID0gdHVybi5zb21lKGZ1bmN0aW9uICh0dXJuKSB7XG4gICAgcmV0dXJuIHR1cm4udHlwZSA9PT0gJ2tpbmcnICYmIHR1cm4uY29sb3IgPT09IHNlbGYuY29sb3I7XG4gIH0pO1xuXG4gIGlmICgha2luZ01vdmVkKSB7XG4gICAgW1swLCAyLCAtMV0sIFs3LCA2LCArMV1dLmZvckVhY2goZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICB2YXIgcm9va1ggPSBwcm9wc1swXTtcbiAgICAgIHZhciBuZXdLaW5nWCA9IHByb3BzWzFdO1xuICAgICAgdmFyIGRpciA9IHByb3BzWzJdO1xuICAgICAgdmFyIHJvb2sgPSBnYW1lLmJvYXJkW3ldW3Jvb2tYXTtcblxuICAgICAgLy8gQ2hlY2sgcm9vayBvbiBwb3NpdGlvblxuICAgICAgaWYgKCFyb29rIHx8ICFyb29rLnR5cGUgPT09ICdyb29rJykgcmV0dXJuO1xuXG4gICAgICAvLyBDaGVjayByb29rIGhhc24ndCBtb3ZlZFxuICAgICAgaWYgKHR1cm4uc29tZShmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgcmV0dXJuIGV2LmZyb20ueCA9PT0gcm9va1ggJiYgZXYuZnJvbS55ID09PSB5O1xuICAgICAgfSkpIHJldHVybjtcblxuICAgICAgLy8gQ2hlY2sgc3F1YXJlcyBlbXB0eSBhbmQgc2FmZVxuICAgICAgZm9yICh2YXIgeHggPSB4ICsgZGlyOyB4eCAhPT0gcm9va1g7IHh4ICs9IGRpcikge1xuICAgICAgICBpZiAoZ2FtZS5ib2FyZFt5XVt4eF0pIHJldHVybjtcbiAgICAgICAgdmFyIHNhZmUgPSB0cnVlO1xuICAgICAgICBnYW1lLmJvYXJkLmZvckVhY2goZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgZXYuZm9yRWFjaChmdW5jdGlvbiAoZXZ2KSB7XG4gICAgICAgICAgICBpZiAoZXZ2ICYmIGV2di50eXBlICE9PSAna2luZycgJiYgZXZ2LmNvbG9yICE9PSBzZWxmLmNvbG9yKSB7XG4gICAgICAgICAgICAgIGV2di5nZXRWYWxpZE1vdmVzKCkuZm9yRWFjaChmdW5jdGlvbiAoZXZNb3ZlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2TW92ZSAmJiBldk1vdmUueSA9PT0geSAmJiBldk1vdmUueCA9PT0geHgpIHNhZmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXNhZmUpIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHJvY2hhZGUgPSB7XG4gICAgICAgIHg6IG5ld0tpbmdYLFxuICAgICAgICB5OiB5LFxuICAgICAgICBtb3ZlUGllY2U6IHtcbiAgICAgICAgICBwaWVjZTogc2VsZi5nYW1lLmJvYXJkW3ldW3Jvb2tYXSxcbiAgICAgICAgICBmcm9tOiB7XG4gICAgICAgICAgICB4OiByb29rWCwgeTogeVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdG86IHtcbiAgICAgICAgICAgIHk6IHksIHg6IHggKyBkaXJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIG1vdmVzLnB1c2gocm9jaGFkZSk7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgdmFsaWRNb3ZlcyA9IFtdO1xuICBpZiAoc2ltdWxhdGUpIHtcbiAgICB2YWxpZE1vdmVzID0gZ2FtZS5zaW11bGF0ZUFuZEZpbHRlcihtb3Zlcywgc2VsZik7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWRNb3ZlcyA9IG1vdmVzO1xuICB9XG5cbiAgcmV0dXJuIHZhbGlkTW92ZXM7XG59O1xuXG5QaWVjZS5raW5nID0gZnVuY3Rpb24gKHgsIHksIGNvbG9yLCBnYW1lKSB7XG4gIHJldHVybiBuZXcgS2luZyh4LCB5LCBjb2xvciwgZ2FtZSk7XG59O1xuXG5leHBvcnRzLlBpZWNlID0gUGllY2U7XG5leHBvcnRzLlBhd24gPSBQYXduO1xuZXhwb3J0cy5Sb29rID0gUm9vaztcbmV4cG9ydHMuS25pZ2h0ID0gS25pZ2h0O1xuZXhwb3J0cy5CaXNob3AgPSBCaXNob3A7XG5leHBvcnRzLlF1ZWVuID0gUXVlZW47XG5leHBvcnRzLktpbmcgPSBLaW5nO1xuXG4vKioqLyB9KSxcbi8qIDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9nYW1lID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9nYW1lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dhbWUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgQ2hlc3NBSSA9IGZ1bmN0aW9uIENoZXNzQUkoZGVwdGgsIGdhbWVTdGF0ZSwgaXNNYXhpbWlzaW5nUGxheWVyKSB7XG4gIC8vIENsb25lIHRoZSBnYW1lU3RhdGUgdG8gYWNjZXNzIGFsbCBnYW1lIGFzc29jaWF0ZWQgbWV0aG9kcy5cbiAgLy8gVGhpcyB1c3VhbGx5IGRvZXNuJ3QgbWFrZSBzZW5zZSwgYnV0IHNvbWV0aW1lcyB5b3UgY2Fubm90IHBvc3QgZnVuY3Rpb25zIHRvIGEgYmFja2VuZCBvciBhIHdlYi13b3JrZXJcbiAgLy8gYW5kIHRoYXQncyB3aHkgd2UncmUgdG91Y2hpbmcgdGhlIGdhbWUgbWV0aG9kcyBmcm9tIG5ldyBnYW1lIGNvbmZpZ3VyYXRpb24gaW50ZWFkIGZyb20gdGhlIHBhc3NlZCBhcmd1bWVudC5cbiAgLy8gU28gaWYgeW91IHBhc3Mge2JvYXJkOiBbbXlCb2FyZF0sIHR1cm46W215VHVybl0sLi4ufSBmb3IgdGhlIGdhbWUgYXJndW1lbnQgaXQgd2lsbCBhY3R1YWxseSB3b3JrIVxuICAvLyBBbHJlYWR5IGRlc2NyaWJlZCBoZXJlOiBodHRwczovL2dpdGh1Yi5jb20vUlNHLUdyb3VwL0NoZXNzL2lzc3Vlcy84I2lzc3VlY29tbWVudC0zODEyNDU3OTRcbiAgdmFyIGdhbWUgPSBfZ2FtZTIuZGVmYXVsdC5wcm90b3R5cGUuaW5pdGlhbGl6ZUdhbWUoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgODsgaisrKSB7XG4gICAgICBpZiAoZ2FtZVN0YXRlLmJvYXJkW2ldW2pdKSB7XG4gICAgICAgIHZhciBjdXJyZW50Q2VsbCA9IGdhbWVTdGF0ZS5ib2FyZFtpXVtqXTtcbiAgICAgICAgZ2FtZS5waWVjZShjdXJyZW50Q2VsbC50eXBlLCBqLCBpLCBjdXJyZW50Q2VsbC5jb2xvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnYW1lLmJvYXJkW2ldW2pdID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBnYW1lLnR1cm4gPSBnYW1lU3RhdGUudHVybjtcbiAgZ2FtZS50aHJlZWZvbGQgPSBnYW1lU3RhdGUudGhyZWVmb2xkO1xuICBnYW1lLkZFTiA9IGdhbWVTdGF0ZS5GRU47XG4gIGdhbWUuRkVOYm9hcmQgPSBnYW1lU3RhdGUuRkVOYm9hcmQ7XG5cbiAgLy8gU3RhcnQgbG9vcGluZyBhbmQgc2ltdWxhdGluZyBhbGwgdmFsaWQgbW92ZXNcbiAgdmFyIGFsbE1vdmVzID0gZ2FtZS5hbGxNb3ZlcygpO1xuICB2YXIgYmVzdFZhbHVlID0gLTk5OTk7XG4gIHZhciBiZXN0TW92ZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbE1vdmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5ld0dhbWVNb3ZlID0gYWxsTW92ZXNbaV07XG4gICAgdmFyIHVuZG8gPSBnYW1lLnNpbXBsZU1vdmUobmV3R2FtZU1vdmUpO1xuICAgIHZhciBib3JhZFZhbHVlID0gbWluaW1heChkZXB0aCAtIDEsIGdhbWUsIC0xMDAwMCwgMTAwMDAsICFpc01heGltaXNpbmdQbGF5ZXIpO1xuICAgIHVuZG8oKTtcbiAgICBpZiAoYm9yYWRWYWx1ZSA+PSBiZXN0VmFsdWUpIHtcbiAgICAgIGJlc3RWYWx1ZSA9IGJvcmFkVmFsdWU7XG4gICAgICBiZXN0TW92ZSA9IG5ld0dhbWVNb3ZlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYmVzdE1vdmU7XG59OyAvL1xuLy8gUlNHIENoZXNzXG4vLyBMaWNlbnNlZCB1bmRlciBBcGFjaGUgMi4wIExJQ0VOU0VcblxudmFyIG1pbmltYXggPSBmdW5jdGlvbiBtaW5pbWF4KGRlcHRoLCBnYW1lLCBhbHBoYSwgYmV0YSwgaXNNYXhpbWlzaW5nUGxheWVyKSB7XG4gIGlmIChkZXB0aCA9PT0gMCkge1xuICAgIHJldHVybiAtZXZhbHVhdGVCb2FyZChnYW1lLmJvYXJkKTtcbiAgfVxuXG4gIHZhciBhbGxNb3ZlcyA9IGdhbWUuYWxsTW92ZXMoKTtcbiAgaWYgKGlzTWF4aW1pc2luZ1BsYXllcikge1xuICAgIHZhciBiZXN0VmFsdWUgPSAtOTk5OTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbE1vdmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdW5kbyA9IGdhbWUuc2ltcGxlTW92ZShhbGxNb3Zlc1tpXSk7XG4gICAgICBiZXN0VmFsdWUgPSBNYXRoLm1heChiZXN0VmFsdWUsIG1pbmltYXgoZGVwdGggLSAxLCBnYW1lLCBhbHBoYSwgYmV0YSwgIWlzTWF4aW1pc2luZ1BsYXllcikpO1xuICAgICAgdW5kbygpO1xuICAgICAgYWxwaGEgPSBNYXRoLm1heChhbHBoYSwgYmVzdFZhbHVlKTtcbiAgICAgIGlmIChiZXRhIDw9IGFscGhhKSB7XG4gICAgICAgIHJldHVybiBiZXN0VmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBiZXN0VmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIF9iZXN0VmFsdWUgPSA5OTk5O1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhbGxNb3Zlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfdW5kbyA9IGdhbWUuc2ltcGxlTW92ZShhbGxNb3Zlc1tfaV0pO1xuICAgICAgX2Jlc3RWYWx1ZSA9IE1hdGgubWluKF9iZXN0VmFsdWUsIG1pbmltYXgoZGVwdGggLSAxLCBnYW1lLCBhbHBoYSwgYmV0YSwgIWlzTWF4aW1pc2luZ1BsYXllcikpO1xuICAgICAgX3VuZG8oKTtcbiAgICAgIGJldGEgPSBNYXRoLm1pbihiZXRhLCBfYmVzdFZhbHVlKTtcbiAgICAgIGlmIChiZXRhIDw9IGFscGhhKSB7XG4gICAgICAgIHJldHVybiBfYmVzdFZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gX2Jlc3RWYWx1ZTtcbiAgfVxufTtcblxudmFyIGV2YWx1YXRlQm9hcmQgPSBmdW5jdGlvbiBldmFsdWF0ZUJvYXJkKGJvYXJkKSB7XG4gIHZhciB0b3RhbEV2YWx1YXRpb24gPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgODsgaisrKSB7XG4gICAgICAvLyBjYWxjdWxhdGUgdGhlIGN1cnJlbnQgZXZhbHVhdGlvblxuICAgICAgdG90YWxFdmFsdWF0aW9uID0gdG90YWxFdmFsdWF0aW9uICsgZ2V0UGllY2VWYWx1ZShib2FyZFtpXVtqXSk7XG4gICAgfVxuICB9XG4gIC8vIHJldHVybiB0aGUgdG90YWwgZXZhbHVhdGlvblxuICByZXR1cm4gdG90YWxFdmFsdWF0aW9uO1xufTtcblxudmFyIGdldFBpZWNlVmFsdWUgPSBmdW5jdGlvbiBnZXRQaWVjZVZhbHVlKHBpZWNlKSB7XG4gIGlmIChwaWVjZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgLy8gZ2V0IHZhbHVlIGZvciBldmVyeSBwaWVjZSBvbiB0aGUgYm9hcmRcbiAgdmFyIGdldEFic29sdXRlVmFsdWUgPSBmdW5jdGlvbiBnZXRBYnNvbHV0ZVZhbHVlKHBpZWNlKSB7XG4gICAgaWYgKHBpZWNlLnR5cGUgPT09ICdwYXduJykge1xuICAgICAgcmV0dXJuIDEwO1xuICAgIH0gZWxzZSBpZiAocGllY2UudHlwZSA9PT0gJ3Jvb2snKSB7XG4gICAgICByZXR1cm4gNTA7XG4gICAgfSBlbHNlIGlmIChwaWVjZS50eXBlID09PSAna25pZ2h0Jykge1xuICAgICAgcmV0dXJuIDMwO1xuICAgIH0gZWxzZSBpZiAocGllY2UudHlwZSA9PT0gJ2Jpc2hvcCcpIHtcbiAgICAgIHJldHVybiAzMDtcbiAgICB9IGVsc2UgaWYgKHBpZWNlLnR5cGUgPT09ICdxdWVlbicpIHtcbiAgICAgIHJldHVybiA5MDtcbiAgICB9IGVsc2UgaWYgKHBpZWNlLnR5cGUgPT09ICdraW5nJykge1xuICAgICAgcmV0dXJuIDkwMDtcbiAgICB9XG4gIH07XG5cbiAgLy8gY2FsY3VsYXRlIHRoZSBhYnNvbHV0ZSB2YWx1ZSBhbmQgcmV0dXJuIGl0XG4gIHZhciBhYnNvbHV0ZVZhbHVlID0gZ2V0QWJzb2x1dGVWYWx1ZShwaWVjZSwgcGllY2UuY29sb3IgPT09ICdXJyk7XG4gIHJldHVybiBwaWVjZS5jb2xvciA9PT0gJ1cnID8gYWJzb2x1dGVWYWx1ZSA6IC1hYnNvbHV0ZVZhbHVlO1xufTtcblxuLy8gZXhwb3J0IHRoZSBhbGdvcml0aG1cbmV4cG9ydHMuZGVmYXVsdCA9IENoZXNzQUk7XG5cbi8vIFdyaXR0ZW4gYnkgUmFkaSBDaG9cbi8vIFJTRyBDaGVzcyAtIGJ5IFJTRyBHcm91cFxuXG4vKioqLyB9KSxcbi8qIDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuQUkgPSBleHBvcnRzLlBpZWNlcyA9IGV4cG9ydHMuR2FtZSA9IHVuZGVmaW5lZDtcblxudmFyIF9nYW1lID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIF9nYW1lMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dhbWUpO1xuXG52YXIgX3BpZWNlcyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBQaWVjZXMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfcGllY2VzKTtcblxudmFyIF9BSSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBfQUkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfQUkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHsgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGVsc2UgeyB2YXIgbmV3T2JqID0ge307IGlmIChvYmogIT0gbnVsbCkgeyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gbmV3T2JqLmRlZmF1bHQgPSBvYmo7IHJldHVybiBuZXdPYmo7IH0gfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vLyBBbmQgZXhwb3J0Li4uXG5leHBvcnRzLkdhbWUgPSBfZ2FtZTIuZGVmYXVsdDtcbmV4cG9ydHMuUGllY2VzID0gUGllY2VzO1xuZXhwb3J0cy5BSSA9IF9BSTIuZGVmYXVsdDsgLy8gTGV0J3MgaW1wb3J0Li4uXG5cbi8qKiovIH0pXG4vKioqKioqLyBdKTtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcnNnLWNoZXNzL2xpYi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9